{"version":3,"file":"entry-server.js","sources":["../../src/contexts/ColorContext.tsx","../../src/contexts/ImageProcessingContext.tsx","../../src/lib/api.ts","../../src/hooks/query/useFolderImages.ts","../../src/workers/imageProcessor.ts","../../src/workers/workerPool.ts","../../src/lib/cache/feedStateCache.ts","../../src/types/index.ts","../../src/utils/ScrollTriggerManager.ts","../../src/utils/AnimationSystem.ts","../../src/utils/layoutCalculator.ts","../../src/components/AuraBackground.tsx","../../src/utils/stringUtils.ts","../../src/components/ImageItem.tsx","../../src/components/ImageRow.tsx","../../src/components/ImageSkeleton.tsx","../../src/components/views/BannerView.tsx","../../src/components/views/CarouselView.tsx","../../src/components/views/MasonryView.tsx","../../src/components/ImageFeed.tsx","../../src/hooks/useWindowSize.ts","../../src/hooks/usePrefetchManager.ts","../../src/components/ImageViewer.tsx","../../src/components/MainContent.tsx","../../src/components/CurrentDirectoryButton.tsx","../../src/hooks/query/useCurrentDirectory.ts","../../src/components/SearchBar.tsx","../../src/components/ZoomSlider.tsx","../../src/components/Navbar.tsx","../../src/utils/settings.ts","../../src/components/Sidebar.tsx","../../src/hooks/query/useFolders.ts","../../src/utils/constants.ts","../../src/components/Layout.tsx","../../src/hooks/useCustomProperties.ts","../../src/pages/Home.tsx","../../src/App.tsx","../../src/entry-server.tsx"],"sourcesContent":["import React, { createContext, ReactNode, useCallback, useMemo, useState } from 'react';\n\n// Define hover state structure\ninterface HoverState {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates [0, 1] relative to background\n  color: string | null; // Optional: Dominant color of hovered item\n}\n\n// Define the shape of the context data\ninterface ColorContextProps {\n  // Store maybe 1 or 2 dominant colors. Using string[] for flexibility.\n  dominantColors: string[];\n  setDominantColors: (colors: string[]) => void;\n  // Add hover state\n  hoverState: HoverState;\n  setHoverState: (newState: Partial<HoverState>) => void; // Allow partial updates\n}\n\n// Default initial background color (dark blueish)\nconst initialDefaultColor = '#041024';\n\n// Initial hover state\nconst initialHoverState: HoverState = {\n  isHovering: false,\n  position: null,\n  color: null,\n};\n\n// Create the context with a default value\nexport const ColorContext = createContext<ColorContextProps>({\n  dominantColors: [initialDefaultColor],\n  setDominantColors: () => {}, // No-op function as default\n  hoverState: initialHoverState,\n  setHoverState: () => {}, // No-op\n});\n\n// Create the provider component\ninterface ColorProviderProps {\n  children: ReactNode;\n}\n\nexport const ColorProvider: React.FC<ColorProviderProps> = ({ children }) => {\n  const [dominantColors, setDominantColorsState] = useState<string[]>([initialDefaultColor]);\n  const [hoverState, setHoverStateInternal] = useState<HoverState>(initialHoverState);\n\n  // Create a stable setter function that allows partial updates\n  const setHoverState = useCallback((newState: Partial<HoverState>) => {\n    setHoverStateInternal(prevState => ({ ...prevState, ...newState }));\n  }, []);\n\n  // Avoid re-creating the context value object on every render\n  const contextValue = useMemo(\n    () => ({\n      dominantColors,\n      setDominantColors: setDominantColorsState,\n      hoverState,\n      setHoverState, // Provide the stable setter\n    }),\n    [dominantColors, hoverState, setHoverState] // Add dependencies\n  );\n\n  return <ColorContext.Provider value={contextValue}>{children}</ColorContext.Provider>;\n};\n","import React, { createContext, ReactNode, useCallback, useContext, useMemo } from 'react';\r\n\r\n// Type for the data sent when an image is processed\r\nexport interface ProcessedImageUpdate {\r\n  id: string;\r\n  quality: 'low' | 'high';\r\n  imageUrl: string;\r\n  // Include dimensions if available and needed by ImageItem\r\n  width?: number;\r\n  height?: number;\r\n}\r\n\r\n// Type for the callback function used by subscribers\r\ntype ImageUpdateCallback = (data: ProcessedImageUpdate) => void;\r\n\r\n// Type for the context value\r\ninterface ImageProcessingContextType {\r\n  subscribeToImageUpdates: (imageId: string, callback: ImageUpdateCallback) => () => void; // Returns unsubscribe function\r\n  publishImageUpdate: (data: ProcessedImageUpdate) => void;\r\n}\r\n\r\n// Create the context with a default value (can be null or a dummy implementation)\r\nconst ImageProcessingContext = createContext<ImageProcessingContextType | null>(null);\r\n\r\n// Provider component props\r\ninterface ImageProcessingProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n// Keep track of subscriptions outside the component state if preferred\r\n// This avoids re-rendering the provider on every subscription change\r\nconst subscriptions = new Map<string, Set<ImageUpdateCallback>>();\r\n\r\n// Provider component implementation\r\nexport const ImageProcessingProvider: React.FC<ImageProcessingProviderProps> = ({ children }) => {\r\n  const subscribeToImageUpdates = useCallback(\r\n    (imageId: string, callback: ImageUpdateCallback): (() => void) => {\r\n      if (!subscriptions.has(imageId)) {\r\n        subscriptions.set(imageId, new Set());\r\n      }\r\n      const imageSubscriptions = subscriptions.get(imageId)!;\r\n      imageSubscriptions.add(callback);\r\n\r\n      // Return unsubscribe function\r\n      return () => {\r\n        if (subscriptions.has(imageId)) {\r\n          subscriptions.get(imageId)!.delete(callback);\r\n          // Optional: Clean up Set/Map entry if no subscribers left\r\n          if (subscriptions.get(imageId)!.size === 0) {\r\n            subscriptions.delete(imageId);\r\n          }\r\n        }\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  const publishImageUpdate = useCallback((data: ProcessedImageUpdate) => {\r\n    if (subscriptions.has(data.id)) {\r\n      const imageSubscriptions = subscriptions.get(data.id)!;\r\n      // Notify all subscribers for this image ID\r\n      imageSubscriptions.forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`Error in image update callback for ID ${data.id}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  // Memoize the context value\r\n  const contextValue = useMemo(\r\n    () => ({\r\n      subscribeToImageUpdates,\r\n      publishImageUpdate,\r\n    }),\r\n    [subscribeToImageUpdates, publishImageUpdate]\r\n  );\r\n\r\n  return (\r\n    <ImageProcessingContext.Provider value={contextValue}>\r\n      {children}\r\n    </ImageProcessingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook for easy context consumption\r\nexport const useImageProcessing = (): ImageProcessingContextType => {\r\n  const context = useContext(ImageProcessingContext);\r\n  if (!context) {\r\n    throw new Error('useImageProcessing must be used within an ImageProcessingProvider');\r\n  }\r\n  return context;\r\n};\r\n","import axios from 'axios';\nimport { FolderInfo, ImageInfo } from '../types/index.js';\n\nconst api = axios.create({\n  baseURL: '/api', // Assuming your API routes are under /api\n});\n\n/**\n * Fetches the list of folders from the server.\n *\n * @returns {Promise<FolderInfo[]>} A promise that resolves to an array of folder information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getFolders(): Promise<FolderInfo[]> {\n  try {\n    const response = await api.get('/folders');\n    return response.data.map((folder: { name: string; path: string }) => ({\n      name: folder.name,\n      path: folder.path,\n    }));\n  } catch (error) {\n    console.error('Error in getFolders:', error);\n    throw new Error('Failed to fetch folders');\n  }\n}\n\n/**\n * Fetches the list of images for a specific folder from the server.\n *\n * @param {string} folder - The name of the folder to fetch images from.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getImages(folder: string): Promise<ImageInfo[]> {\n  if (!folder) {\n    throw new Error('Folder parameter is required');\n  }\n\n  try {\n    const response = await api.get(`/images?folder=${encodeURIComponent(folder)}`);\n\n    if (!Array.isArray(response.data)) {\n      console.error('Invalid response data:', response.data);\n      throw new Error('Invalid response format from server');\n    }\n\n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      const message = error.response.data?.error || error.response.statusText;\n      throw new Error(`Server error: ${message}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      throw new Error('No response from server');\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.error('Error in getImages:', error);\n      throw new Error(error.message || 'Failed to fetch images');\n    }\n  }\n}\n/**\n * Uploads files to a specified folder on the server.\n *\n * @param {string} folder - The name of the folder to upload files to.\n * @param {File[]} files - An array of File objects to be uploaded.\n * @param {function} onProgress - A callback function to report upload progress.\n * @returns {Promise<void>} A promise that resolves when the upload is complete.\n * @throws Will throw an error if the API request fails.\n */\nexport async function uploadFiles(\n  folder: string,\n  files: File[],\n  onProgress: (progress: number) => void\n): Promise<void> {\n  const formData = new FormData();\n  formData.append('folder', folder);\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    await api.post('/upload', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data',\n      },\n      onUploadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(percentCompleted);\n        }\n      },\n    });\n  } catch (error) {\n    console.error('Error in uploadFiles:', error);\n    throw new Error('Failed to upload files');\n  }\n}\n/**\n * Searches for images across all folders based on a query string.\n *\n * @param {string} query - The search query string.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information matching the search query.\n * @throws Will throw an error if the API request fails.\n */\nexport async function searchImages(query: string): Promise<ImageInfo[]> {\n  try {\n    const response = await api.get(`/search?q=${encodeURIComponent(query)}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error in searchImages:', error);\n    throw new Error('Failed to search images');\n  }\n}\n\n/**\n * Fetches the current main directory from the server.\n *\n * @returns {Promise<string>} A promise that resolves to the current main directory path.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getCurrentDirectory(): Promise<string> {\n  try {\n    const response = await api.get('/getCurrentDirectory');\n    return response.data.currentDirectory;\n  } catch (error) {\n    console.error('Error in getCurrentDirectory:', error);\n    throw new Error('Failed to get current directory');\n  }\n}\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getImages } from '../../lib/api';\r\nimport { ImageInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch images for a specific folder using React Query.\r\n *\r\n * @param {string} folder - The name of the folder to fetch images from.\r\n * @returns The result object from useQuery, containing image data, loading state, error state, etc.\r\n */\r\nexport function useFolderImages(folder: string) {\r\n  return useQuery<ImageInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Includes the folder name so data is cached per folder.\r\n    queryKey: ['images', folder],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: () => getImages(folder),\r\n    // Enabled option: prevents the query from running if the folder is falsy (e.g., empty string, null, undefined).\r\n    enabled: !!folder,\r\n    // Use placeholderData to keep displaying the previous data while the new data is loading.\r\n    placeholderData: previousData => previousData,\r\n  });\r\n}\r\n","import * as Comlink from 'comlink'; // Import Comlink namespace for releaseProxy\nimport { Remote, wrap } from 'comlink'; // Import wrap, Remote, and releaseProxy\nimport { IDBPDatabase, openDB } from 'idb';\nimport PQueue from 'p-queue'; // Import p-queue\nimport { ImageInfo, ImageProcessorWorkerAPI, ProcessedImageCacheEntry } from '../types/index.js'; // Import the API type\n// Import the context update type\nimport { ProcessedImageUpdate } from '../contexts/ImageProcessingContext';\n\n// Remove the message interface - no longer needed\n// interface ImageProcessorMessage { ... }\n\nconst DB_NAME = 'image-processor-cache';\nconst STORE_NAME = 'processed-images';\nconst DB_VERSION = 1;\n\ninterface ImageProcessorOptions {\n  onImageProcessed?: (\n    id: string,\n    quality: 'low' | 'high',\n    imageUrl: string,\n    width: number,\n    height: number\n  ) => void;\n  onError?: (id: string, error: string) => void;\n  concurrency?: number; // Allow overriding concurrency\n}\n\n// --- Cache Management ---\nlet dbPromise: Promise<IDBPDatabase> | null = null;\n\nconst getDb = (): Promise<IDBPDatabase> => {\n  if (!dbPromise) {\n    dbPromise = openDB(DB_NAME, DB_VERSION, {\n      upgrade(db) {\n        if (!db.objectStoreNames.contains(STORE_NAME)) {\n          db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n        }\n      },\n    });\n  }\n  return dbPromise;\n};\n\nclass ImageProcessor {\n  private worker: Worker;\n  private proxy: Remote<ImageProcessorWorkerAPI>; // Store the Comlink proxy\n  private queue: PQueue; // Add queue instance\n  private onError?: (id: string, error: string) => void;\n  // Store AbortControllers for active requests\n  private activeRequests = new Map<string, AbortController>();\n  // Add property to hold the publisher function\n  private publisher: ((data: ProcessedImageUpdate) => void) | null = null;\n\n  constructor(options?: ImageProcessorOptions) {\n    this.onError = options?.onError;\n\n    // Initialize the queue\n    const concurrency =\n      options?.concurrency ?? Math.max(1, (navigator.hardwareConcurrency || 4) - 1);\n    this.queue = new PQueue({ concurrency });\n    console.log(`ImageProcessor: Initialized queue with concurrency ${concurrency}`);\n\n    // Initialize the worker and wrap it with Comlink\n    this.worker = new Worker(new URL('./imageProcessorWorker.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n    this.proxy = wrap<ImageProcessorWorkerAPI>(this.worker);\n\n    // Remove the onmessage handler - results come via promise\n    // this.worker.onmessage = (event: MessageEvent<ImageProcessorMessage>) => {\n    //   this.handleWorkerMessage(event);\n    // };\n\n    this.worker.onerror = error => {\n      console.error('Unhandled error in ImageProcessorWorker:', error);\n      // This usually indicates a setup or non-recoverable worker error\n      // Consider notifying the UI about a general failure\n      this.onError?.('WORKER_FATAL', error.message || 'Worker failed');\n    };\n\n    this.initializeCacheCheck();\n  }\n\n  private async initializeCacheCheck() {\n    try {\n      await this.checkCacheForStaleBlobs();\n    } catch (error) {\n      console.error('Failed initial cache check:', error);\n    }\n  }\n\n  // Method to set the publisher function after initialization\n  public setPublisher(publisher: (data: ProcessedImageUpdate) => void) {\n    console.log('[ImageProcessor] Publisher function set.');\n    this.publisher = publisher;\n  }\n\n  // --- Cache Management Methods ---\n  private async getCacheEntry(id: string): Promise<ProcessedImageCacheEntry | undefined> {\n    const db = await getDb();\n    return db.get(STORE_NAME, id);\n  }\n\n  private async setCacheEntry(entry: ProcessedImageCacheEntry): Promise<void> {\n    const db = await getDb();\n    await db.put(STORE_NAME, entry);\n  }\n\n  private async deleteCacheEntry(id: string): Promise<void> {\n    const db = await getDb();\n    await db.delete(STORE_NAME, id);\n  }\n\n  private async checkCacheForStaleBlobs() {\n    console.log('ImageProcessor: Checking cache for stale blob URLs...');\n    const db = await getDb();\n    const allEntries = await db.getAll(STORE_NAME);\n    let staleCount = 0;\n\n    for (const entry of allEntries) {\n      let shouldDelete = false;\n      try {\n        // Check low-res blob\n        if (entry.lowResUrl && entry.lowResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.lowResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale low-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true; // Mark for deletion if blob is invalid\n          }\n        }\n        // Check high-res blob\n        if (entry.highResUrl && entry.highResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.highResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale high-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true;\n          }\n        }\n      } catch (e) {\n        console.warn(`Error checking blob URL for ${entry.id}. Assuming stale.`, e);\n        shouldDelete = true;\n      }\n\n      if (shouldDelete) {\n        await this.deleteCacheEntry(entry.id);\n        staleCount++;\n        // console.log(`ImageProcessor: Deleted stale cache entry for ${entry.id}`);\n      }\n    }\n\n    if (staleCount > 0) {\n      console.log(`ImageProcessor: Removed ${staleCount} stale cache entries.`);\n    } else {\n      console.log('ImageProcessor: No stale blob URLs found in cache.');\n    }\n  }\n\n  // --- Public Processing Methods (using Comlink) ---\n\n  async processImage(image: ImageInfo): Promise<void> {\n    const { id, src, width, height } = image;\n\n    if (!id || !src || !width || !height) {\n      console.error('Invalid image data provided to processImage:', image);\n      this.onError?.(id || 'unknown', 'Invalid image data');\n      return;\n    }\n\n    // Check cache immediately before queueing\n    try {\n      const cachedEntry = await this.getCacheEntry(id);\n      const lowResMatches =\n        cachedEntry?.lowResWidth === Math.round(width / 4) &&\n        cachedEntry?.lowResHeight === Math.round(height / 4);\n      const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n      if (cachedEntry?.lowResUrl && cachedEntry?.highResUrl && lowResMatches && highResMatches) {\n        console.log(`ImageProcessor: Cache hit for ${id} (pre-queue). Skipping queue.`);\n        // Publish low-res from cache\n        this.publisher?.({\n          id,\n          quality: 'low',\n          imageUrl: cachedEntry.lowResUrl,\n          width: cachedEntry.lowResWidth!,\n          height: cachedEntry.lowResHeight!,\n        });\n        // Publish high-res from cache\n        this.publisher?.({\n          id,\n          quality: 'high',\n          imageUrl: cachedEntry.highResUrl,\n          width: cachedEntry.width!,\n          height: cachedEntry.height!,\n        });\n        return; // Already cached, no need to queue\n      }\n    } catch (cacheError) {\n      console.error(`ImageProcessor: Error checking cache pre-queue for ${id}:`, cacheError);\n      // Proceed to queue anyway?\n    }\n\n    // Check if already actively being processed or queued\n    if (this.activeRequests.has(id)) {\n      console.log(`ImageProcessor: Request for ${id} is already active/queued. Skipping.`);\n      return;\n    }\n\n    // Create controller and add to active requests *before* queueing\n    const controller = new AbortController();\n    this.activeRequests.set(id, controller);\n\n    // Add the processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued task for ${id}. Queue size: ${this.queue.size}`\n        );\n        let createdBitmap: ImageBitmap | null = null;\n        try {\n          // Re-check cache inside queue in case it was populated while waiting\n          const cachedEntry = await this.getCacheEntry(id);\n          const lowResMatches =\n            cachedEntry?.lowResWidth === Math.round(width / 4) &&\n            cachedEntry?.lowResHeight === Math.round(height / 4);\n          const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n          if (\n            cachedEntry?.lowResUrl &&\n            cachedEntry?.highResUrl &&\n            lowResMatches &&\n            highResMatches\n          ) {\n            console.log(`ImageProcessor: Cache hit for ${id} (in-queue). Skipping processing.`);\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n            // Publish high-res from cache\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: cachedEntry.highResUrl,\n              width: cachedEntry.width!,\n              height: cachedEntry.height!,\n            });\n            return; // Exit queued task\n          }\n\n          // Check signal before potentially long operations\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before processing', 'AbortError');\n\n          // --- Prepare / Fetch Bitmap (same logic as before) ---\n          let reason = 'No cache entry';\n          let needsProcessing = true;\n\n          if (cachedEntry && (!lowResMatches || !highResMatches)) {\n            reason = `Cache found for ${id} but dimensions mismatch. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          } else if (cachedEntry?.lowResUrl && lowResMatches) {\n            reason = `Low-res cache hit for ${id}, processing for high-res.`;\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n          } else if (cachedEntry) {\n            reason = `Inconsistent cache state for ${id}. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          }\n\n          console.log(`ImageProcessor: Fetching image ${id} to create ImageBitmap (queued).`);\n          try {\n            const response = await fetch(src, { signal: controller.signal });\n            if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);\n            const blob = await response.blob();\n            if (controller.signal.aborted) throw new DOMException('Aborted', 'AbortError');\n            createdBitmap = await createImageBitmap(blob);\n          } catch (fetchError: any) {\n            if (fetchError.name !== 'AbortError') {\n              console.error(\n                `ImageProcessor: Error fetching/creating bitmap for ${id} (queued):`,\n                fetchError\n              );\n              this.onError?.(id, fetchError.message || 'Failed to load image data');\n            }\n            // Rethrow to be caught by outer try/catch\n            throw fetchError;\n          }\n\n          // --- Call Worker ---\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before worker call', 'AbortError');\n          console.log(\n            `ImageProcessor: Sending image ${id} to worker via Comlink (queued). Reason: ${reason}`\n          );\n          const result = await this.proxy.processImage(\n            Comlink.transfer(\n              { id, imageBitmap: createdBitmap, width, height /* signal: controller.signal */ },\n              [createdBitmap]\n            )\n          );\n          createdBitmap = null; // Nullify after transfer\n\n          // --- Process Result ---\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Processing for ${id} aborted after worker call (queued).`);\n            if (result.lowResUrl) URL.revokeObjectURL(result.lowResUrl);\n            if (result.highResUrl) URL.revokeObjectURL(result.highResUrl);\n            return;\n          }\n\n          console.log(`ImageProcessor: Received results for ${id} from worker (queued).`);\n          const finalEntry: ProcessedImageCacheEntry = {\n            ...((await this.getCacheEntry(id)) || { id }),\n            id,\n            lowResUrl: result.lowResUrl ?? cachedEntry?.lowResUrl,\n            lowResWidth: result.lowResUrl ? Math.round(width / 4) : cachedEntry?.lowResWidth,\n            lowResHeight: result.lowResUrl ? Math.round(height / 4) : cachedEntry?.lowResHeight,\n            highResUrl: result.highResUrl,\n            width: result.highResUrl ? width : cachedEntry?.width,\n            height: result.highResUrl ? height : cachedEntry?.height,\n            timestamp: Date.now(),\n          };\n\n          await this.setCacheEntry(finalEntry);\n\n          // Publish results using the publisher function\n          if (result.lowResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: finalEntry.lowResUrl!,\n              width: finalEntry.lowResWidth!,\n              height: finalEntry.lowResHeight!,\n            });\n          }\n          if (result.highResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: finalEntry.highResUrl!,\n              width: finalEntry.width!,\n              height: finalEntry.height!,\n            });\n          }\n        } catch (error: any) {\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued task for ${id} aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error during queued processing for ${id}:`, error);\n            this.onError?.(id, error.message || 'Queued processing failed');\n          }\n        } finally {\n          if (createdBitmap) {\n            try {\n              createdBitmap.close();\n            } catch (e) {\n              console.warn(`Error closing untransferred bitmap for ${id} (queued):`, e);\n            }\n          }\n          // Remove from active requests only when the queued task finishes/errors/aborts\n          this.activeRequests.delete(id);\n          console.log(\n            `ImageProcessor: Finished queued task for ${id}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself (rare)\n        console.error(`ImageProcessor: Error adding task to queue for ${id}:`, error);\n        this.activeRequests.delete(id); // Ensure cleanup if add fails\n        this.onError?.(id, error.message || 'Failed to queue task');\n      });\n  }\n\n  async processBatch(images: ImageInfo[]): Promise<void> {\n    const batchId = `batch-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\n    // Check if a batch request is already active/queued (using a placeholder ID structure)\n    // This simple check might not be sufficient if overlapping batches are possible\n    if (this.activeRequests.has(batchId)) {\n      // Use generated batchId for tracking\n      console.log(\n        `ImageProcessor: Batch request ${batchId} appears to be already active/queued. Skipping.`\n      );\n      return;\n    }\n\n    const controller = new AbortController();\n    this.activeRequests.set(batchId, controller);\n\n    // Add batch processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued batch task ${batchId}. Queue size: ${this.queue.size}`\n        );\n        const imagesToProcess: Array<{\n          id: string;\n          imageBitmap: ImageBitmap;\n          width: number;\n          height: number;\n        }> = [];\n        const transferList: ImageBitmap[] = [];\n        const preCheckPromises: Promise<void>[] = [];\n        const createdBitmaps: ImageBitmap[] = [];\n        let batchError: Error | null = null; // Track error within the queued task\n\n        try {\n          console.log(\n            `ImageProcessor: Starting batch preparation for ${images.length} images (queued). Batch ID: ${batchId}`\n          );\n\n          // --- Pre-check Cache and Fetch Bitmaps (inside queue task) ---\n          for (const image of images) {\n            const { id, src, width, height } = image;\n            if (!id || !src || !width || !height) {\n              console.error('Invalid image data in batch (queued):', image);\n              this.onError?.(id || 'unknown-batch', 'Invalid image data in batch');\n              continue;\n            }\n\n            preCheckPromises.push(\n              (async () => {\n                if (controller.signal.aborted) return;\n                let localBitmap: ImageBitmap | null = null;\n                try {\n                  const cachedEntry = await this.getCacheEntry(id);\n                  const lowResMatches =\n                    cachedEntry?.lowResWidth === Math.round(width / 4) &&\n                    cachedEntry?.lowResHeight === Math.round(height / 4);\n                  const highResMatches =\n                    cachedEntry?.width === width && cachedEntry?.height === height;\n\n                  if (\n                    cachedEntry?.lowResUrl &&\n                    cachedEntry?.highResUrl &&\n                    lowResMatches &&\n                    highResMatches\n                  ) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                    // Publish high-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'high',\n                      imageUrl: cachedEntry.highResUrl,\n                      width: cachedEntry.width!,\n                      height: cachedEntry.height!,\n                    });\n                    return;\n                  }\n\n                  if (cachedEntry && (!lowResMatches || !highResMatches)) {\n                    if (controller.signal.aborted) return;\n                    console.log(\n                      `ImageProcessor: Clearing mismatched cache for batch item ${id} (queued)`\n                    );\n                    await this.deleteCacheEntry(id);\n                  }\n\n                  if (controller.signal.aborted) return;\n                  console.log(`ImageProcessor: Fetching batch item ${id} (queued)`);\n                  const response = await fetch(src, { signal: controller.signal });\n                  if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);\n                  const blob = await response.blob();\n                  if (controller.signal.aborted) return;\n                  localBitmap = await createImageBitmap(blob);\n                  createdBitmaps.push(localBitmap);\n\n                  imagesToProcess.push({ id, imageBitmap: localBitmap, width, height });\n                  transferList.push(localBitmap);\n\n                  if (cachedEntry?.lowResUrl && lowResMatches) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                  }\n                } catch (error: any) {\n                  if (localBitmap) {\n                    try {\n                      localBitmap.close();\n                    } catch {}\n                    const index = createdBitmaps.indexOf(localBitmap);\n                    if (index > -1) createdBitmaps.splice(index, 1);\n                  }\n                  if (error.name !== 'AbortError') {\n                    console.error(\n                      `ImageProcessor: Error preparing batch item ${id} (queued):`,\n                      error\n                    );\n                    this.onError?.(id, error.message || 'Batch item preparation failed');\n                  } else {\n                    // Re-throw abort error to stop Promise.all\n                    throw error;\n                  }\n                }\n              })()\n            );\n          }\n\n          // Wait for preparation inside the queue task\n          await Promise.all(preCheckPromises);\n\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Batch ${batchId} aborted during preparation (queued).`);\n            throw new DOMException('Batch preparation aborted', 'AbortError');\n          }\n\n          // --- Call Worker ---\n          if (imagesToProcess.length > 0) {\n            console.log(\n              `ImageProcessor: Sending batch ${batchId} of ${imagesToProcess.length} images to worker via Comlink (queued).`\n            );\n            const batchResults = await this.proxy.processBatch(\n              Comlink.transfer(\n                { images: imagesToProcess /* signal: controller.signal */ },\n                transferList\n              )\n            );\n\n            // --- Process Results ---\n            if (controller.signal.aborted) {\n              console.log(\n                `ImageProcessor: Batch ${batchId} aborted after worker completed (queued).`\n              );\n              batchResults.forEach(r => {\n                if (r.lowResUrl) URL.revokeObjectURL(r.lowResUrl);\n                if (r.highResUrl) URL.revokeObjectURL(r.highResUrl);\n              });\n              // Still need to throw abort error to trigger finally cleanup correctly\n              throw new DOMException('Batch aborted post-worker', 'AbortError');\n            }\n\n            console.log(\n              `ImageProcessor: Received ${batchResults.length} results for batch ${batchId} (queued).`\n            );\n            const cacheUpdatePromises: Promise<void>[] = [];\n            for (const result of batchResults) {\n              const { id: resultId, lowResUrl, highResUrl } = result;\n              const originalItem = imagesToProcess.find(item => item.id === resultId);\n              const originalWidth = originalItem?.width;\n              const originalHeight = originalItem?.height;\n\n              if (!originalWidth || !originalHeight) continue;\n              const existingEntry = await this.getCacheEntry(resultId);\n              const finalEntry: ProcessedImageCacheEntry = {\n                id: resultId,\n                lowResUrl: result.lowResUrl ?? existingEntry?.lowResUrl,\n                lowResWidth: result.lowResUrl\n                  ? Math.round(originalWidth / 4)\n                  : existingEntry?.lowResWidth,\n                lowResHeight: result.lowResUrl\n                  ? Math.round(originalHeight / 4)\n                  : existingEntry?.lowResHeight,\n                highResUrl: result.highResUrl ?? existingEntry?.highResUrl,\n                width: result.highResUrl ? originalWidth : existingEntry?.width,\n                height: result.highResUrl ? originalHeight : existingEntry?.height,\n                timestamp: Date.now(),\n              };\n              cacheUpdatePromises.push(this.setCacheEntry(finalEntry));\n              // Publish results using the publisher function\n              if (result.lowResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'low',\n                  imageUrl: finalEntry.lowResUrl!,\n                  width: finalEntry.lowResWidth!,\n                  height: finalEntry.lowResHeight!,\n                });\n              }\n              if (result.highResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'high',\n                  imageUrl: finalEntry.highResUrl!,\n                  width: finalEntry.width!,\n                  height: finalEntry.height!,\n                });\n              }\n            }\n            await Promise.all(cacheUpdatePromises);\n          } else {\n            console.log(\n              `ImageProcessor: No images needed processing for batch ${batchId} (queued).`\n            );\n          }\n        } catch (error: any) {\n          batchError = error; // Store error to handle in finally\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued batch ${batchId} processing aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error processing queued batch ${batchId}:`, error);\n            this.onError?.(batchId, error.message || 'Queued batch processing failed');\n          }\n        } finally {\n          // Ensure bitmaps not transferred are closed if aborted/errored during prep\n          // Also close bitmaps if a non-abort error occurred after prep\n          if (batchError?.name === 'AbortError' || batchError) {\n            createdBitmaps.forEach(bitmap => {\n              // Check if it was actually transferred before trying to close\n              if (!transferList.includes(bitmap)) {\n                try {\n                  bitmap.close();\n                } catch {}\n              }\n            });\n          }\n          // Worker handles closing transferred bitmaps\n          this.activeRequests.delete(batchId);\n          console.log(\n            `ImageProcessor: Finished queued batch task ${batchId}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself\n        console.error(`ImageProcessor: Error adding batch task to queue ${batchId}:`, error);\n        this.activeRequests.delete(batchId); // Ensure cleanup\n        this.onError?.(batchId, error.message || 'Failed to queue batch task');\n      });\n  }\n\n  // --- Control Methods ---\n  cancel(id?: string) {\n    if (id) {\n      const controller = this.activeRequests.get(id);\n      if (controller) {\n        console.log(`ImageProcessor: Aborting request ${id}.`);\n        controller.abort();\n        // Don't delete immediately, let the queued task handle cleanup in finally\n        // this.activeRequests.delete(id);\n      } else {\n        console.log(`ImageProcessor: No active request found for ID ${id} to cancel.`);\n      }\n    } else {\n      console.log(\n        `ImageProcessor: Aborting all ${this.activeRequests.size} active requests and clearing queue.`\n      );\n      // Abort all active controllers\n      this.activeRequests.forEach(controller => controller.abort());\n      // Clear pending tasks from the queue\n      this.queue.clear();\n      // Clear the tracking map\n      this.activeRequests.clear();\n    }\n  }\n\n  cancelAll() {\n    this.cancel(); // cancel() without id now handles clearing everything\n  }\n\n  terminate() {\n    console.log(\n      'ImageProcessor: Terminating worker, cancelling active requests, clearing queue, and closing DB.'\n    );\n    this.cancelAll(); // Abort ongoing and clear pending\n    // Add a small delay to allow abort signals to propagate potentially?\n    // setTimeout(() => {...\n    try {\n      this.proxy[Comlink.releaseProxy]();\n    } catch (e) {\n      console.warn('ImageProcessor: Error releasing Comlink proxy:', e);\n    }\n    this.worker.terminate();\n    if (dbPromise) {\n      getDb().then(db => db.close());\n      dbPromise = null;\n    }\n    // }, 50); // Example delay\n  }\n}\n\nexport function createImageProcessor(options?: Omit<ImageProcessorOptions, 'onImageProcessed'>) {\n  return new ImageProcessor(options);\n}\n","import { createImageProcessor } from './imageProcessor.js';\n// Import the actual worker type for type safety\nimport LayoutWorker from './layoutWorker.worker.ts?worker'; // Vite worker import syntax\n// Import the new color extractor worker\nimport ColorExtractorWorker from './colorExtractor.worker.ts?worker';\n// Import the new grouping worker\nimport PQueue from 'p-queue'; // Import p-queue\nimport { v4 as uuidv4 } from 'uuid'; // Use UUID for unique request IDs\nimport GroupingWorker from './groupingWorker.worker.ts?worker';\n\n// Define the type for the processor instance more explicitly\ntype ImageProcessorInstance = ReturnType<typeof createImageProcessor>;\n// Define the type for the layout worker instance\ntype LayoutWorkerInstance = Worker;\n// Define the type for the color extractor worker instance\ntype ColorExtractorWorkerInstance = Worker;\n// Define the type for the grouping worker instance\ntype GroupingWorkerInstance = Worker;\ntype WorkerInstance = LayoutWorkerInstance | ColorExtractorWorkerInstance | GroupingWorkerInstance;\ntype WorkerType = 'layout' | 'color' | 'grouping';\n\n// Interface for messages sent TO workers (includes requestId)\ninterface WorkerRequestMessage<T = any> {\n  type: string; // Original message type\n  payload: T;\n  requestId: string;\n}\n\n// Interface for messages received FROM workers (includes requestId)\ninterface WorkerResponseMessage<T = any> {\n  type: string; // e.g., 'layoutResult', 'colorResult', 'groupingResult', 'error'\n  payload: T;\n  requestId: string;\n}\n\ninterface WorkerErrorMessage {\n  type: 'error';\n  message: string;\n  requestId?: string; // Optional: Worker might include ID with error\n}\n\ninterface PendingRequest<T> {\n  resolve: (value: T | PromiseLike<T>) => void; // Allow PromiseLike for better compatibility\n  reject: (reason?: any) => void;\n  timer?: ReturnType<typeof setTimeout>; // Optional: Timeout timer\n}\n\nclass WorkerPool {\n  private static instance: WorkerPool;\n  // Use the more specific type\n  private imageProcessor: ImageProcessorInstance | null = null;\n  private layoutWorker: LayoutWorkerInstance | null = null;\n  private colorExtractorWorker: ColorExtractorWorkerInstance | null = null; // Add state for color worker\n  private groupingWorker: GroupingWorkerInstance | null = null; // Add state for grouping worker\n  private isImageProcessorInitialized = false;\n  private isLayoutWorkerInitialized = false;\n  private isColorExtractorInitialized = false; // Add flag for color worker\n  private isGroupingWorkerInitialized = false; // Add flag for grouping worker\n  private layoutWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for color worker\n  private colorExtractorListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for grouping worker\n  private groupingWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n\n  // Initialization Promises\n  private layoutWorkerPromise: Promise<LayoutWorkerInstance> | null = null;\n  private colorExtractorWorkerPromise: Promise<ColorExtractorWorkerInstance> | null = null;\n  private groupingWorkerPromise: Promise<GroupingWorkerInstance> | null = null;\n\n  // Pending Requests Maps\n  private pendingLayoutRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingColorRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingGroupingRequests: Map<string, PendingRequest<any>> = new Map();\n\n  // --- p-queue Instances --- >\n  private layoutQueue: PQueue;\n  private colorQueue: PQueue;\n  private groupingQueue: PQueue;\n\n  private constructor() {\n    // Initialize queues with desired concurrency\n    // Layout and grouping are likely sequential operations affecting the whole view\n    this.layoutQueue = new PQueue({ concurrency: 1 });\n    this.groupingQueue = new PQueue({ concurrency: 1 });\n    // Color extraction can often run more concurrently\n    this.colorQueue = new PQueue({\n      concurrency: Math.max(1, (navigator.hardwareConcurrency || 4) - 1),\n    });\n    console.log(\n      `[WorkerPool] Initialized queues. Concurrency - Layout: ${this.layoutQueue.concurrency}, Grouping: ${this.groupingQueue.concurrency}, Color: ${this.colorQueue.concurrency}`\n    );\n  }\n\n  public static getInstance(): WorkerPool {\n    if (!WorkerPool.instance) {\n      WorkerPool.instance = new WorkerPool();\n    }\n    return WorkerPool.instance;\n  }\n\n  // --- Generic Worker Initializer ---\n  private initializeWorker<W extends WorkerInstance>(\n    workerType: WorkerType,\n    WorkerConstructor: new () => W,\n    setupListenersFn: (worker: W) => void\n  ): Promise<W> {\n    console.log(`WorkerPool: Initializing ${workerType} Worker...`);\n    return new Promise<W>((resolve, reject) => {\n      try {\n        const worker = new WorkerConstructor();\n        setupListenersFn(worker);\n        console.log(`WorkerPool: ${workerType} Worker initialized successfully.`);\n        resolve(worker);\n      } catch (error) {\n        console.error(`[WorkerPool] Failed to initialize ${workerType} Worker:`, error);\n        reject(new Error(`Failed to initialize ${workerType} Worker`));\n      }\n    });\n  }\n\n  // --- Image Processor Management ---\n\n  public getImageProcessor(): ImageProcessorInstance {\n    if (!this.imageProcessor) {\n      console.log('WorkerPool: Initializing Image Processor...');\n      this.imageProcessor = createImageProcessor();\n      this.isImageProcessorInitialized = true;\n    } else {\n      // console.log('WorkerPool: Returning existing Image Processor.');\n    }\n    return this.imageProcessor;\n  }\n\n  // Add method to cancel pending image processing tasks\n  public cancelPendingImageTasks() {\n    if (this.imageProcessor && this.isImageProcessorInitialized) {\n      console.log('WorkerPool: Cancelling pending image processing tasks...');\n      this.imageProcessor.cancel?.(); // Use optional chaining\n    } else {\n      // console.log('WorkerPool: No active image processor to cancel tasks for.');\n    }\n  }\n\n  // --- Layout Worker Management (Promise-based) ---\n  public getLayoutWorker(): Promise<LayoutWorkerInstance> {\n    if (!this.layoutWorkerPromise) {\n      this.layoutWorkerPromise = this.initializeWorker('layout', LayoutWorker, worker => {\n        this.layoutWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'layout',\n          this.pendingLayoutRequests,\n          this.layoutWorkerListeners\n        );\n      }).catch(err => {\n        this.layoutWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.layoutWorkerPromise;\n  }\n\n  // --- Color Extractor Worker Management (Promise-based) ---\n  public getColorExtractorWorker(): Promise<ColorExtractorWorkerInstance> {\n    if (!this.colorExtractorWorkerPromise) {\n      this.colorExtractorWorkerPromise = this.initializeWorker(\n        'color',\n        ColorExtractorWorker,\n        worker => {\n          this.colorExtractorWorker = worker; // Store the instance\n          this.setupWorkerMessageHandler(\n            worker,\n            'color',\n            this.pendingColorRequests,\n            this.colorExtractorListeners\n          );\n        }\n      ).catch(err => {\n        this.colorExtractorWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.colorExtractorWorkerPromise;\n  }\n\n  // --- Grouping Worker Management (Promise-based) ---\n  public getGroupingWorker(): Promise<GroupingWorkerInstance> {\n    if (!this.groupingWorkerPromise) {\n      this.groupingWorkerPromise = this.initializeWorker('grouping', GroupingWorker, worker => {\n        this.groupingWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'grouping',\n          this.pendingGroupingRequests,\n          this.groupingWorkerListeners\n        );\n      }).catch(err => {\n        this.groupingWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.groupingWorkerPromise;\n  }\n\n  // --- Generic Message Handler Setup ---\n  private setupWorkerMessageHandler<T>(\n    worker: WorkerInstance,\n    workerType: WorkerType,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    generalListeners: Map<string, (event: MessageEvent) => void>\n  ): void {\n    worker.onmessage = (event: MessageEvent<WorkerResponseMessage<T> | WorkerErrorMessage>) => {\n      const { data } = event;\n      const requestId = data.requestId;\n\n      // console.log(`[WorkerPool] Received message from ${workerType} worker:`, data);\n\n      if (requestId && pendingRequests.has(requestId)) {\n        const request = pendingRequests.get(requestId)!;\n        clearTimeout(request.timer); // Clear timeout if response received\n\n        if (data.type === 'error') {\n          console.error(\n            `[WorkerPool] Error response for request ${requestId} from ${workerType}:`,\n            (data as WorkerErrorMessage).message\n          );\n          request.reject(\n            new Error((data as WorkerErrorMessage).message || 'Worker returned an error')\n          );\n        } else {\n          // Assume other types are successful results\n          // console.log(`[WorkerPool] Resolving request ${requestId} for ${workerType}`);\n          request.resolve((data as WorkerResponseMessage<T>).payload);\n        }\n        pendingRequests.delete(requestId);\n      } else if (requestId) {\n        console.warn(\n          `[WorkerPool] Received message with unknown or stale requestId ${requestId} from ${workerType}:`,\n          data\n        );\n        // Optionally dispatch to general listeners if it's a non-error message?\n        // generalListeners.forEach(listener => listener(event));\n      } else {\n        // Message without requestId - likely a general status or unhandled message\n        // console.log(`[WorkerPool] Received non-request message from ${workerType}:`, data);\n        generalListeners.forEach(listener => listener(event));\n      }\n    };\n\n    worker.onerror = (event: ErrorEvent) => {\n      console.error(`[WorkerPool] Generic error from ${workerType} Worker:`, event.message, event);\n      // Attempt to reject related pending requests, though we lack specific request ID here\n      // This is a limitation if the worker crashes without sending a request-specific error\n      const error = new Error(`Worker ${workerType} encountered an error: ${event.message}`);\n      pendingRequests.forEach((request, requestId) => {\n        console.warn(\n          `[WorkerPool] Rejecting pending request ${requestId} due to generic ${workerType} worker error.`\n        );\n        clearTimeout(request.timer);\n        request.reject(error);\n      });\n      pendingRequests.clear(); // Clear all pending requests for this worker on generic error\n\n      // Also notify general listeners\n      generalListeners.forEach(listener => listener(event as any));\n\n      // Consider terminating and resetting the worker promise here?\n      // worker.terminate(); // Be careful with immediate termination\n      // this[`${workerType}WorkerPromise`] = null;\n      // this[`${workerType}Worker`] = null;\n    };\n  }\n\n  // --- Unified Request Posting (Uses p-queue) ---\n  public postRequest<RequestPayload, ResponsePayload>(\n    workerType: WorkerType,\n    messageType: string,\n    payload: RequestPayload,\n    options?: { priority?: number; timeoutMs?: number }\n  ): Promise<ResponsePayload> {\n    let queue: PQueue;\n    let pendingRequests: Map<string, PendingRequest<ResponsePayload>>;\n    let getWorkerPromise: () => Promise<WorkerInstance>;\n\n    // Select the appropriate queue, map, and getter\n    switch (workerType) {\n      case 'layout':\n        queue = this.layoutQueue;\n        pendingRequests = this.pendingLayoutRequests;\n        getWorkerPromise = this.getLayoutWorker.bind(this);\n        break;\n      case 'color':\n        queue = this.colorQueue;\n        pendingRequests = this.pendingColorRequests;\n        getWorkerPromise = this.getColorExtractorWorker.bind(this);\n        break;\n      case 'grouping':\n        queue = this.groupingQueue;\n        pendingRequests = this.pendingGroupingRequests;\n        getWorkerPromise = this.getGroupingWorker.bind(this);\n        break;\n      default:\n        return Promise.reject(new Error(`Invalid worker type: ${workerType}`));\n    }\n\n    // The task added to the queue - *Removed async keyword here*\n    const task = (): Promise<ResponsePayload> => {\n      // Return a new promise that encapsulates the entire worker interaction\n      return new Promise<ResponsePayload>(async (resolveTask, rejectTask) => {\n        const requestId = uuidv4();\n        // console.log(`[WorkerPool] Starting task ${requestId} (${messageType}) for ${workerType}`);\n\n        let worker: WorkerInstance;\n        try {\n          // Ensure worker is initialized within the promise executor\n          worker = await getWorkerPromise();\n        } catch (initError) {\n          console.error(\n            `[WorkerPool] Failed to initialize worker ${workerType} for task ${requestId}:`,\n            initError\n          );\n          rejectTask(initError); // Reject the task promise if init fails\n          return;\n        }\n\n        // Now, manage the specific response via the pendingRequests map\n        let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n        const responsePromise = new Promise<ResponsePayload>((resolveResponse, rejectResponse) => {\n          // Store the inner promise's resolve/reject for the message handler\n          pendingRequests.set(requestId, {\n            resolve: resolveResponse,\n            reject: rejectResponse,\n            timer,\n          });\n        });\n\n        // Setup timeout if specified for the *response* part\n        if (options?.timeoutMs) {\n          timer = setTimeout(() => {\n            if (pendingRequests.has(requestId)) {\n              console.warn(\n                `[WorkerPool] Request ${requestId} to ${workerType} timed out after ${options.timeoutMs}ms.`\n              );\n              // Reject the *response* promise via the map\n              pendingRequests.get(requestId)?.reject(new Error(`Request ${requestId} timed out`));\n              pendingRequests.delete(requestId);\n            }\n          }, options.timeoutMs);\n          // Update the timer reference in the map\n          if (pendingRequests.has(requestId)) {\n            pendingRequests.get(requestId)!.timer = timer;\n          }\n        }\n\n        // Construct the message\n        const workerMessage: WorkerRequestMessage<RequestPayload> = {\n          type: messageType,\n          payload,\n          requestId,\n        };\n\n        // Post the message to the worker\n        try {\n          // console.log(`[WorkerPool] Posting message for ${requestId} to ${workerType}`);\n          worker.postMessage(workerMessage);\n        } catch (postError) {\n          console.error(\n            `[WorkerPool] Error posting message for request ${requestId} to ${workerType}:`,\n            postError\n          );\n          clearTimeout(timer);\n          pendingRequests.delete(requestId);\n          rejectTask(postError); // Reject the outer task promise if postMessage fails\n          return;\n        }\n\n        // Link the outer task promise to the inner response promise\n        try {\n          const result = await responsePromise;\n          resolveTask(result);\n        } catch (error) {\n          rejectTask(error);\n        } finally {\n          clearTimeout(timer); // Ensure timer is cleared if response promise settles\n        }\n      });\n    };\n\n    // Add the task function to the queue\n    return queue.add(task, { priority: options?.priority ?? 0 }) as Promise<ResponsePayload>;\n  }\n\n  // --- Listener Management (for general messages, if still needed) ---\n\n  public addLayoutWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for LayoutWorker: ${id}`);\n    this.layoutWorkerListeners.set(id, listener);\n    this.getLayoutWorker(); // Ensure worker is initialized to receive potential messages\n  }\n\n  public removeLayoutWorkerListener(id: string): void {\n    if (this.layoutWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for LayoutWorker: ${id}`);\n      this.layoutWorkerListeners.delete(id);\n    }\n  }\n\n  public addColorExtractorListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for ColorExtractorWorker: ${id}`);\n    this.colorExtractorListeners.set(id, listener);\n    this.getColorExtractorWorker();\n  }\n\n  public removeColorExtractorListener(id: string): void {\n    if (this.colorExtractorListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for ColorExtractorWorker: ${id}`);\n      this.colorExtractorListeners.delete(id);\n    }\n  }\n\n  public addGroupingWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for GroupingWorker: ${id}`);\n    this.groupingWorkerListeners.set(id, listener);\n    this.getGroupingWorker();\n  }\n\n  public removeGroupingWorkerListener(id: string): void {\n    if (this.groupingWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for GroupingWorker: ${id}`);\n      this.groupingWorkerListeners.delete(id);\n    }\n  }\n\n  // --- Cancellation ---\n\n  public cancelPendingLayoutTasks(all: boolean = false) {\n    this.cancelTasks('layout', this.layoutQueue, this.pendingLayoutRequests, all);\n  }\n  public cancelPendingColorTasks(all: boolean = false) {\n    this.cancelTasks('color', this.colorQueue, this.pendingColorRequests, all);\n  }\n  public cancelPendingGroupingTasks(all: boolean = false) {\n    this.cancelTasks('grouping', this.groupingQueue, this.pendingGroupingRequests, all);\n  }\n\n  private cancelTasks<T>(\n    workerType: WorkerType,\n    queue: PQueue,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    all: boolean = true // Default to cancelling all\n  ) {\n    if (!all) {\n      console.warn(\n        `[WorkerPool] Specific request cancellation via ID is not directly supported with queue.clear(). Use cancelAllPendingTasks() or implement AbortSignal.`\n      );\n      return;\n    }\n\n    console.log(`[WorkerPool] Cancelling pending tasks and clearing queue for ${workerType}...`);\n\n    // 1. Clear tasks waiting in the queue (these haven't started)\n    queue.clear();\n\n    // 2. Reject promises for tasks already sent to the worker (in-flight)\n    pendingRequests.forEach((request, id) => {\n      console.warn(\n        `[WorkerPool] Rejecting in-flight request ${id} for ${workerType} due to cancellation.`\n      );\n      clearTimeout(request.timer);\n      request.reject(new Error(`Request ${id} for ${workerType} was cancelled.`));\n      // Optionally, try to notify the worker if it supports cancellation messages\n      // const worker = this[`${workerType}Worker`];\n      // if (worker) {\n      //     try { worker.postMessage({ type: 'cancel', requestId: id }); } catch(e) {}\n      // }\n    });\n    pendingRequests.clear(); // Clear the map after rejecting\n  }\n\n  // --- General Cleanup ---\n\n  public cleanup() {\n    console.log('WorkerPool: Starting cleanup...');\n    this.cancelAllPendingTasks(); // Cancel everything first\n\n    // Terminate Workers\n    this.terminateWorker('layout', this.layoutWorker);\n    this.layoutWorker = null;\n    this.layoutWorkerPromise = null;\n    this.layoutWorkerListeners.clear();\n\n    this.terminateWorker('color', this.colorExtractorWorker);\n    this.colorExtractorWorker = null;\n    this.colorExtractorWorkerPromise = null;\n    this.colorExtractorListeners.clear();\n\n    this.terminateWorker('grouping', this.groupingWorker);\n    this.groupingWorker = null;\n    this.groupingWorkerPromise = null;\n    this.groupingWorkerListeners.clear();\n\n    // Cleanup Image Processor\n    if (this.imageProcessor) {\n      console.log('WorkerPool: Cleaning up Image Processor...');\n      this.imageProcessor.terminate?.();\n      this.imageProcessor = null;\n    }\n\n    // Clear queues (should be empty after cancelAll, but good practice)\n    this.layoutQueue.clear();\n    this.groupingQueue.clear();\n    this.colorQueue.clear();\n\n    console.log('WorkerPool: Cleanup complete.');\n  }\n\n  private terminateWorker(workerType: WorkerType, worker: WorkerInstance | null) {\n    if (worker) {\n      console.log(`WorkerPool: Terminating ${workerType} worker...`);\n      try {\n        worker.terminate();\n      } catch (e) {\n        console.error(`Error terminating ${workerType} worker:`, e);\n      }\n    }\n  }\n\n  // Optional: Combined cancel function\n  public cancelAllPendingTasks() {\n    this.cancelPendingImageTasks(); // Assuming this one is different\n    this.cancelPendingLayoutTasks(true);\n    this.cancelPendingColorTasks(true);\n    this.cancelPendingGroupingTasks(true);\n  }\n}\n\nexport default WorkerPool;\n// Export types needed by consumers\nexport type { WorkerErrorMessage, WorkerRequestMessage, WorkerResponseMessage, WorkerType };\n","import { DBSchema, IDBPDatabase, openDB } from 'idb';\r\n\r\nconst UI_STATE_DB_NAME = 'mediaFlowUIScrollDB';\r\nconst SCROLL_STATE_STORE_NAME = 'scrollPosition';\r\nconst DB_VERSION = 1;\r\n\r\n// Define the structure of the state we want to store - ONLY scrollTop\r\nexport interface ScrollState {\r\n  scrollTop: number;\r\n  timestamp: number;\r\n}\r\n\r\n// Define the database schema\r\ninterface ScrollStateDB extends DBSchema {\r\n  [SCROLL_STATE_STORE_NAME]: {\r\n    key: string; // folderPath\r\n    value: ScrollState;\r\n  };\r\n}\r\n\r\n// Singleton promise to ensure DB is opened only once\r\nlet dbPromise: Promise<IDBPDatabase<ScrollStateDB>> | null = null;\r\n\r\nfunction openScrollStateDB(): Promise<IDBPDatabase<ScrollStateDB>> {\r\n  if (!dbPromise) {\r\n    dbPromise = openDB<ScrollStateDB>(UI_STATE_DB_NAME, DB_VERSION, {\r\n      upgrade(db) {\r\n        // Create the object store if it doesn't exist\r\n        if (!db.objectStoreNames.contains(SCROLL_STATE_STORE_NAME)) {\r\n          db.createObjectStore(SCROLL_STATE_STORE_NAME);\r\n        }\r\n      },\r\n    });\r\n  }\r\n  return dbPromise;\r\n}\r\n\r\n/**\r\n * Saves the scroll top position for a specific folder path to IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @param scrollTop - The scroll position to save.\r\n */\r\nexport async function saveScrollState(folderPath: string, scrollTop: number): Promise<void> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const stateToSave: ScrollState = {\r\n      scrollTop: scrollTop,\r\n      timestamp: Date.now(),\r\n    };\r\n    await store.put(stateToSave, folderPath);\r\n    await tx.done;\r\n  } catch (error) {\r\n    console.error('Failed to save scroll state for path:', folderPath, error);\r\n  }\r\n}\r\n\r\n/**\r\n * Loads the scroll state for a specific folder path from IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @returns The saved ScrollState object (containing scrollTop and timestamp) or null.\r\n */\r\nexport async function loadScrollState(folderPath: string): Promise<ScrollState | null> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readonly');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const state = await store.get(folderPath);\r\n    await tx.done;\r\n    return state ?? null;\r\n  } catch (error) {\r\n    console.error('Failed to load scroll state for path:', folderPath, error);\r\n    return null;\r\n  }\r\n}\r\n","import { createImageProcessor } from '../workers/imageProcessor.js';\n\nexport interface ImageInfo {\n  id: string;\n  src: string;\n  alt: string;\n  title: string;\n  width: number;\n  height: number;\n  group?: {\n    key: string;\n    images: ImageInfo[];\n    isCarousel: boolean;\n  };\n}\n\nexport interface FolderInfo {\n  name: string;\n  path: string;\n}\n\nexport interface UploadProps {\n  selectedFolder: string;\n  onUploadComplete: () => void;\n}\n\nexport interface SearchProps {\n  onSearch: (query: string) => void;\n}\n\nexport interface ImageFeedProps {\n  images: ImageInfo[];\n  isLoading: boolean;\n}\n\nexport interface ImageRowProps {\n  images: ImageInfo[];\n  onImageClick: (image: ImageInfo, groupImages: ImageInfo[]) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  imageProcessor: ReturnType<typeof createImageProcessor>;\n}\n\nexport interface LayoutProps {\n  children: React.ReactNode;\n  folders: FolderInfo[];\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface NavbarProps {\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface GroupedImageInfo {\n  id: string;\n  title: string;\n  images: ImageInfo[];\n}\n\nexport enum ViewMode {\n  GRID = 'grid',\n  BANNER = 'banner',\n  MASONRY = 'masonry',\n  CAROUSEL = 'carousel',\n}\n\n// Interface for the data stored in IndexedDB for cached images\nexport interface ProcessedImageCacheEntry {\n  id: string;\n  lowResUrl?: string; // Blob URL for low-res\n  lowResWidth?: number;\n  lowResHeight?: number;\n  highResUrl?: string; // Blob URL for high-res\n  width?: number; // Original requested width\n  height?: number; // Original requested height\n  timestamp?: number; // When it was cached\n}\n\n// Interface for the Comlink-exposed worker API\nexport interface ImageProcessorWorkerAPI {\n  processImage(data: {\n    id: string;\n    // Accept ImageBitmap directly\n    imageBitmap: ImageBitmap;\n    width: number;\n    height: number;\n    signal?: AbortSignal;\n  }): Promise<{ lowResUrl?: string; highResUrl?: string }>; // Return URLs\n\n  processBatch(data: {\n    // Batch expects bitmaps now\n    images: Array<{ id: string; imageBitmap: ImageBitmap; width: number; height: number }>;\n    signal?: AbortSignal;\n    // Add callback for progress? Comlink supports callbacks\n    // onProgress?: (processed: { id: string; lowResUrl?: string; highResUrl?: string }) => void;\n  }): Promise<Array<{ id: string; lowResUrl?: string; highResUrl?: string }>>; // Return array of results\n}\n","import gsap from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\n\r\ngsap.registerPlugin(ScrollTrigger);\r\n\r\ninterface AnimationTarget {\r\n  element: HTMLElement;\r\n  animation: gsap.core.Tween | gsap.core.Timeline;\r\n}\r\n\r\nclass ScrollTriggerManager {\r\n  private static instance: ScrollTriggerManager;\r\n  private targets: Map<string, AnimationTarget> = new Map();\r\n  private timeline: gsap.core.Timeline;\r\n  private mainTrigger: ScrollTrigger;\r\n\r\n  private constructor() {\r\n    this.timeline = gsap.timeline({\r\n      paused: true,\r\n      smoothChildTiming: true,\r\n    });\r\n\r\n    // Create one main ScrollTrigger\r\n    this.mainTrigger = ScrollTrigger.create({\r\n      trigger: document.body,\r\n      start: 'top top',\r\n      end: 'bottom bottom',\r\n      onUpdate: self => {\r\n        // Update timeline progress based on scroll\r\n        this.timeline.progress(self.progress);\r\n      },\r\n      markers: false, // Always disable markers\r\n    });\r\n  }\r\n\r\n  static getInstance(): ScrollTriggerManager {\r\n    if (!ScrollTriggerManager.instance) {\r\n      ScrollTriggerManager.instance = new ScrollTriggerManager();\r\n    }\r\n    return ScrollTriggerManager.instance;\r\n  }\r\n\r\n  addAnimation(id: string, element: HTMLElement, animationProps: gsap.TweenVars) {\r\n    // Create the animation but don't play it yet\r\n    const animation = gsap.to(element, {\r\n      ...animationProps,\r\n      paused: true,\r\n    });\r\n\r\n    // Add it to our timeline\r\n    this.timeline.add(animation, 0);\r\n\r\n    // Store reference\r\n    this.targets.set(id, { element, animation });\r\n\r\n    return animation;\r\n  }\r\n\r\n  removeAnimation(id: string) {\r\n    const target = this.targets.get(id);\r\n    if (target) {\r\n      this.timeline.remove(target.animation);\r\n      this.targets.delete(id);\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    // Kill all ScrollTriggers to prevent memory leaks\r\n    this.targets.forEach(({ animation }) => {\r\n      animation.kill();\r\n    });\r\n\r\n    if (this.mainTrigger) {\r\n      this.mainTrigger.kill();\r\n    }\r\n\r\n    this.timeline.kill();\r\n    this.targets.clear();\r\n    ScrollTrigger.getAll().forEach(trigger => trigger.kill());\r\n  }\r\n}\r\n\r\nexport default ScrollTriggerManager;\r\n","import gsap from 'gsap';\nimport { CustomEase } from 'gsap/CustomEase';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport ScrollTriggerManager from './ScrollTriggerManager';\n\ngsap.registerPlugin(ScrollTrigger, CustomEase);\n\n// Simplified animation system without ripples and energy mechanics\nexport class AnimationSystem {\n  private static instance: AnimationSystem;\n  private scrollTriggerManager: ScrollTriggerManager;\n\n  private constructor() {\n    this.initializeCustomEases();\n    this.scrollTriggerManager = ScrollTriggerManager.getInstance();\n  }\n\n  private initializeCustomEases() {\n    CustomEase.create(\n      'smoothOut',\n      'M0,0 C0.126,0.382 0.282,0.674 0.44,0.822 0.632,1.002 0.818,1 1,1'\n    );\n    CustomEase.create('gentleIn', 'M0,0 C0.39,0 0.575,0.565 0.669,0.782 0.762,1 0.846,1 1,1');\n  }\n\n  static getInstance(): AnimationSystem {\n    if (!AnimationSystem.instance) {\n      AnimationSystem.instance = new AnimationSystem();\n    }\n    return AnimationSystem.instance;\n  }\n\n  getAnimationProperties(itemId: string): gsap.TweenVars {\n    return {\n      duration: 0.5,\n      ease: 'power2.out',\n      transformOrigin: 'center center',\n      scale: 1,\n      rotation: 0,\n    };\n  }\n\n  createHoverAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      scale: 1.05,\n      duration: 0.3,\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  createMorphAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      duration: 0.5,\n      borderRadius: '8px',\n      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  // New method that uses the ScrollTriggerManager for scroll-based animations\n  createScrollAnimation(element: HTMLElement, itemId: string, animationProps: gsap.TweenVars) {\n    return this.scrollTriggerManager.addAnimation(itemId, element, animationProps);\n  }\n}\n\nexport default AnimationSystem;\n","import { ImageInfo, ViewMode } from '../types/index.js';\n\n// Constants\nexport const MIN_IMAGE_WIDTH = 200;\nexport const MAX_COLUMNS = 7;\nexport const MIN_COLUMNS = 1;\nexport const BASE_GAP = 4;\nexport const MIN_GAP = 2;\nexport const MAX_GAP = 12;\nexport const MIN_ZOOM = 0.5;\nexport const MAX_ZOOM = 3;\n\n// Types\nexport interface LayoutConfig {\n  containerWidth: number;\n  zoom: number;\n  viewMode: ViewMode;\n  isGrouped: boolean;\n}\n\nexport interface RowConfig {\n  width: number;\n  height: number;\n  gap: number;\n  images: ImageInfo[];\n  imageWidths?: number[];\n  offset?: number;\n}\n\nexport interface ImageDimensions {\n  width: number;\n  height: number;\n  aspectRatio: number;\n}\n\n// Cache for aspect ratios and dimensions\nconst aspectRatioCache = new WeakMap<ImageInfo, number>();\nconst layoutCache = new Map<string, RowConfig[]>();\n\n// Example: Caching sorted order of images\nconst sortedImagesCache = new Map<string, ImageInfo[]>();\n\nconst getSortedImages = (images: ImageInfo[]): ImageInfo[] => {\n  // Generate an identifier for the current order; could be a hash of ids\n  const cacheKey = images.map(img => img.id).join(',');\n  if (sortedImagesCache.has(cacheKey)) {\n    return sortedImagesCache.get(cacheKey)!;\n  }\n  // Sort images by aspect ratio (or any other criteria)\n  const sorted = [...images].sort((a, b) => a.width / a.height - b.width / b.height);\n  sortedImagesCache.set(cacheKey, sorted);\n  return sorted;\n};\n\n// Enhanced cache key generation with size awareness\nconst generateCacheKey = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  viewMode: string\n): string => {\n  return `${containerWidth}-${zoom}-${viewMode}-${images.map(img => img.id).join(',')}`;\n};\n\n// Cache invalidation threshold (in pixels)\nconst CACHE_INVALIDATION_THRESHOLD = 8;\n\nclass SizeAwareCache<T> {\n  private cache: Map<string, { data: T; width: number }>;\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, width: number): void {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, { data: value, width });\n  }\n\n  get(key: string, currentWidth: number): T | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    // Invalidate cache if width difference exceeds threshold\n    if (Math.abs(entry.width - currentWidth) > CACHE_INVALIDATION_THRESHOLD) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Replace existing caches with size-aware versions\nconst rowLayoutCache = new SizeAwareCache<RowConfig>(100);\nconst dimensionsCache = new SizeAwareCache<ImageDimensions>(500);\n\n// Core calculation functions\nexport const calculateColumns = (containerWidth: number, zoom: number): number => {\n  const effectiveWidth = containerWidth / zoom;\n  const baseColumns = Math.floor(effectiveWidth / (MIN_IMAGE_WIDTH * zoom));\n  return Math.min(Math.max(baseColumns, MIN_COLUMNS), MAX_COLUMNS);\n};\n\n// Add smooth zoom transition helper\nexport const interpolateZoom = (\n  currentZoom: number,\n  targetZoom: number,\n  progress: number\n): number => {\n  return currentZoom + (targetZoom - currentZoom) * progress;\n};\n\nexport const calculateGapSize = (zoom: number): number => {\n  // Normalize zoom level\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  // Calculate base gap size with finer granularity\n  const zoomFactor = (normalizedZoom - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);\n  const baseGap = BASE_GAP * (1 + zoomFactor * 0.25);\n\n  // Round to nearest even number to ensure consistent spacing\n  const roundedGap = Math.round(baseGap * 2) / 2;\n\n  // Ensure gap stays within bounds\n  return Math.min(Math.max(roundedGap, MIN_GAP), MAX_GAP);\n};\n\n// Optimized aspect ratio calculation with caching\nconst getAspectRatio = (image: ImageInfo): number => {\n  let ratio = aspectRatioCache.get(image);\n  if (!ratio) {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      ratio = image.width / image.height;\n      aspectRatioCache.set(image, ratio);\n    } else {\n      ratio = 1; // Default fallback\n    }\n  }\n  return ratio;\n};\n\n// Batch process aspect ratios\nconst batchProcessAspectRatios = (images: ImageInfo[]): number[] => {\n  return images.map(getAspectRatio);\n};\n\n// Optimized image dimensions calculation with caching\nexport const calculateImageDimensions = (\n  image: ImageInfo,\n  containerWidth: number,\n  zoom: number\n): ImageDimensions => {\n  const cacheKey = generateCacheKey([image], containerWidth, zoom, 'dimensions');\n  const cachedDimensions = dimensionsCache.get(cacheKey, containerWidth);\n\n  if (cachedDimensions) {\n    return cachedDimensions;\n  }\n\n  const aspectRatio = getAspectRatio(image);\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  const maxWidth = Math.min(containerWidth, MIN_IMAGE_WIDTH * MAX_COLUMNS);\n  const baseWidth = Math.min(\n    Math.max(MIN_IMAGE_WIDTH * normalizedZoom, containerWidth / MAX_COLUMNS),\n    maxWidth\n  );\n\n  const width = Math.round(baseWidth);\n  const height = Math.round(width / aspectRatio);\n\n  const dimensions = { width, height, aspectRatio };\n  dimensionsCache.set(cacheKey, dimensions, containerWidth);\n\n  return dimensions;\n};\n\nexport const detectOverflow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number\n): boolean => {\n  const gap = calculateGapSize(zoom);\n  const totalWidth = images.reduce((sum, image) => {\n    const { width } = calculateImageDimensions(image, containerWidth, zoom);\n    return sum + width + gap;\n  }, -gap); // Subtract last gap\n\n  return totalWidth > containerWidth;\n};\n\n// Add new helper function for calculating optimal row distribution\nconst calculateOptimalDistribution = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { idealHeight: number; widths: number[] } => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate ideal height that would make images fill the width perfectly\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate widths based on aspect ratios and ideal height\n  const widths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  return { idealHeight, widths };\n};\n\n// Enhanced checkRowFit function\nconst checkRowFit = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { fits: boolean; idealHeight: number; predictedWidths: number[] } => {\n  const { idealHeight, widths } = calculateOptimalDistribution(images, containerWidth, zoom, gap);\n  const minWidth = MIN_IMAGE_WIDTH * zoom;\n\n  // Check if any image would be too narrow based on aspect ratio\n  const allImagesWideEnough = widths.every(width => width >= minWidth);\n\n  // Calculate total width including gaps\n  const totalWidth = widths.reduce((sum, width) => sum + width, 0) + (images.length - 1) * gap;\n\n  return {\n    fits: allImagesWideEnough && totalWidth <= containerWidth,\n    idealHeight,\n    predictedWidths: widths,\n  };\n};\n\n// Update distributeImages function\nexport const distributeImages = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  targetRowHeight: number = 200\n): RowConfig[] => {\n  if (containerWidth <= 0 || images.length === 0) {\n    console.warn('Invalid input detected');\n    return [];\n  }\n\n  const sortedImages = getSortedImages(images);\n  const gap = calculateGapSize(zoom);\n  const rows: RowConfig[] = [];\n  let currentRow: ImageInfo[] = [];\n  let currentRowAspectRatio = 0;\n\n  for (let i = 0; i < sortedImages.length; i++) {\n    const testRow = [...currentRow, sortedImages[i]];\n    const { fits, idealHeight, predictedWidths } = checkRowFit(testRow, containerWidth, zoom, gap);\n\n    if (!fits && currentRow.length > 0) {\n      // --- Finalize the current row ---\n      const { idealHeight, widths: currentWidths } = calculateOptimalDistribution(\n        currentRow,\n        containerWidth,\n        zoom,\n        gap\n      );\n      const rowHeight = Math.floor(idealHeight);\n      // Adjust widths to fit exactly\n      const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n      let calculatedWidthSum = 0;\n      const adjustedWidths = currentRow.map((img, index) => {\n        const width = Math.floor(getAspectRatio(img) * rowHeight);\n        calculatedWidthSum += width;\n        return width;\n      });\n\n      // Distribute remainder/deficit due to flooring\n      const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n      if (discrepancy !== 0 && adjustedWidths.length > 0) {\n        // Add discrepancy to the last image for simplicity\n        adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n      }\n\n      rows.push({\n        width: containerWidth,\n        height: rowHeight,\n        gap,\n        images: currentRow,\n        imageWidths: adjustedWidths, // Use adjusted widths\n        offset: 0,\n      });\n      // --- End finalize current row ---\n\n      // Start new row with current image\n      currentRow = [sortedImages[i]];\n      currentRowAspectRatio = getAspectRatio(sortedImages[i]);\n    } else {\n      // Add image to current row\n      currentRow = testRow;\n      currentRowAspectRatio += getAspectRatio(sortedImages[i]);\n    }\n  }\n\n  // Handle last row\n  if (currentRow.length > 0) {\n    // --- Finalize the last row ---\n    const { idealHeight, widths: initialWidths } = calculateOptimalDistribution(\n      currentRow,\n      containerWidth,\n      zoom,\n      gap\n    );\n    const rowHeight = Math.floor(idealHeight);\n    // Adjust widths to fit exactly\n    const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n    let calculatedWidthSum = 0;\n    const adjustedWidths = currentRow.map((img, index) => {\n      const width = Math.floor(getAspectRatio(img) * rowHeight);\n      calculatedWidthSum += width;\n      return width;\n    });\n\n    // Distribute remainder/deficit due to flooring\n    const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n    if (discrepancy !== 0 && adjustedWidths.length > 0) {\n      // Add discrepancy to the last image for simplicity\n      adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n    }\n\n    rows.push({\n      width: containerWidth,\n      height: rowHeight,\n      gap,\n      images: currentRow,\n      imageWidths: adjustedWidths, // Use adjusted widths\n      offset: 0,\n    });\n    // --- End finalize last row ---\n  }\n\n  return rows;\n};\n\n// Helper function to create a centered row\nconst createCenteredRow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): RowConfig => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate row height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate image widths based on aspect ratios and available width\n  const imageWidths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  // Calculate actual total width including gaps\n  const totalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n\n  // Distribute any remaining pixels to prevent rounding issues\n  const remainingPixels = containerWidth - totalWidth;\n  if (remainingPixels > 0 && imageWidths.length > 0) {\n    // Add remaining pixels to the first image to maintain alignment\n    imageWidths[0] += remainingPixels;\n  }\n\n  // Calculate centering offset\n  const offset = Math.floor((containerWidth - totalWidth) / 2);\n\n  return {\n    width: containerWidth,\n    height: Math.floor(idealHeight),\n    gap,\n    images,\n    imageWidths,\n    offset,\n  };\n};\n\n// Optimized row layout calculation\nexport const optimizeRowLayout = (\n  row: RowConfig,\n  containerWidth: number,\n  zoom: number\n): RowConfig => {\n  if (containerWidth <= 0) {\n    console.warn('Invalid container width detected in optimizeRowLayout');\n    return row;\n  }\n\n  const cacheKey = generateCacheKey(row.images, containerWidth, zoom, 'row');\n  const cachedLayout = rowLayoutCache.get(cacheKey, containerWidth);\n  if (cachedLayout) {\n    return cachedLayout;\n  }\n\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n  const baseGap = calculateGapSize(normalizedZoom);\n\n  // Ensure integer gaps to prevent rounding issues\n  const gap = Math.round(baseGap);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (row.images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting all gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  const aspectRatios = batchProcessAspectRatios(row.images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate ideal height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n  const minRequiredHeight = (MIN_IMAGE_WIDTH * zoom) / Math.max(...aspectRatios);\n  const maxAllowedHeight = availableWidth / totalAspectRatio;\n  const rowHeight = Math.round(\n    Math.max(minRequiredHeight, Math.min(maxAllowedHeight, idealHeight))\n  );\n\n  // Calculate initial image widths based on aspect ratios\n  const imageWidths = aspectRatios.map(ratio => Math.floor(rowHeight * ratio));\n\n  // Calculate total width of all images\n  const totalImageWidth = imageWidths.reduce((sum, width) => sum + width, 0);\n\n  // Calculate the remaining width to distribute\n  const remainingWidth = availableWidth - totalImageWidth;\n\n  if (remainingWidth !== 0 && imageWidths.length > 0) {\n    // Distribute remaining width evenly among all images\n    const widthPerImage = Math.floor(remainingWidth / imageWidths.length);\n    const extraPixels = remainingWidth % imageWidths.length;\n\n    // Add base distribution to all images\n    imageWidths.forEach((_, index) => {\n      imageWidths[index] += widthPerImage;\n    });\n\n    // Add any extra pixels to the first few images\n    for (let i = 0; i < extraPixels; i++) {\n      imageWidths[i] += 1;\n    }\n  }\n\n  // Verify total width matches container width exactly\n  const finalTotalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n  if (finalTotalWidth !== containerWidth && imageWidths.length > 0) {\n    // Add any remaining pixels to the first image\n    const diff = containerWidth - finalTotalWidth;\n    imageWidths[0] += diff;\n  }\n\n  const optimizedRow = {\n    ...row,\n    width: containerWidth,\n    height: rowHeight,\n    gap,\n    imageWidths,\n  };\n\n  rowLayoutCache.set(cacheKey, optimizedRow, containerWidth);\n  return optimizedRow;\n};\n\n// Layout calculation for different view modes\nexport const calculateLayout = (config: LayoutConfig) => {\n  const { containerWidth, zoom, viewMode, isGrouped } = config;\n  const columns = calculateColumns(containerWidth, zoom);\n  const gap = calculateGapSize(zoom);\n\n  return {\n    columns,\n    gap,\n    minImageWidth: MIN_IMAGE_WIDTH * zoom,\n    maxImageWidth: containerWidth / columns - gap,\n  };\n};\n\n// Utility function for maintaining aspect ratio\nexport const maintainAspectRatio = (\n  image: ImageInfo,\n  containerWidth: number,\n  containerHeight: number\n): { width: number; height: number } => {\n  const imgRatio = getAspectRatio(image);\n  const containerRatio = containerWidth / containerHeight;\n  let width: number;\n  let height: number;\n\n  if (imgRatio > containerRatio) {\n    // Image is wider than container\n    width = containerWidth;\n    height = width / imgRatio;\n  } else {\n    // Image is taller than container\n    height = containerHeight;\n    width = height * imgRatio;\n  }\n\n  return { width: Math.round(width), height: Math.round(height) };\n};\n","import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { ColorContext } from '../contexts/ColorContext'; // Import ColorContext\nimport styles from '../styles/ParticleBackground.module.scss'; // Reuse or create new styles\n\n// Convert hex color string to vec3 [r, g, b] (normalized 0-1)\nconst hexToVec3 = (hex: string): [number, number, number] => {\n  let r = 0,\n    g = 0,\n    b = 0;\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(hex[1] + hex[1], 16);\n    g = parseInt(hex[2] + hex[2], 16);\n    b = parseInt(hex[3] + hex[3], 16);\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(hex[1] + hex[2], 16);\n    g = parseInt(hex[3] + hex[4], 16);\n    b = parseInt(hex[5] + hex[6], 16);\n  }\n  return [r / 255, g / 255, b / 255];\n};\n\n// Linear interpolation function for arrays (like colors)\nconst lerpArray = (start: number[], end: number[], t: number): number[] => {\n  return start.map((val, i) => val + (end[i] - val) * t);\n};\n\n// Linear interpolation for single values\nconst lerp = (start: number, end: number, t: number): number => {\n  return start + (end - start) * t;\n};\n\n// --- WebGL Shaders (Refined for Aura Effect) ---\n\n// Vertex Shader (Remains the same - simple quad pass-through)\nconst vertexShaderSource = `\n  precision mediump float;\n  attribute vec2 a_position; // Vertex position (-1 to 1)\n  varying vec2 v_uv;         // Pass UV coordinates (0 to 1) to fragment shader\n\n  void main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_uv = (a_position + 1.0) * 0.5; // Convert clip space to UV space\n    v_uv.y = 1.0 - v_uv.y; // Flip Y for texture/canvas coordinate system\n  }\n`;\n\n// Fragment Shader: Updated with noise functions for a more organic background\nconst fragmentShaderSource = `\n  precision mediump float;\n  varying vec2 v_uv; // UV coordinates from vertex shader\n\n  uniform vec2 u_resolution;    // Canvas resolution\n  uniform float u_time;        // Time for animations\n  uniform vec3 u_colorTarget1;  // Base color 1\n  uniform vec3 u_colorTarget2;  // Base color 2\n  uniform float u_colorMixFactor; // Mix factor for base colors\n\n  // Hover state uniforms\n  uniform bool u_isHovering;\n  uniform vec2 u_hoverPos;      // Normalized hover position (0-1)\n  uniform vec3 u_hoverColor;    // Optional: Color associated with hover\n\n  // --- Noise Functions ---\n  // Simple pseudo-random number generator\n  float random (vec2 st) {\n      // Adjusted seed based on example, can be tweaked\n      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n  }\n\n  // Basic Value Noise function\n  float noise (vec2 st) {\n      vec2 i = floor(st); // Integer part\n      vec2 f = fract(st); // Fractional part\n\n      // Get random values for the 4 corners surrounding the point\n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n\n      // Smoothly interpolate between the corner values (smoothstep)\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      // Interpolate horizontally, then vertically\n      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n  }\n\n  // Fractional Brownian Motion (fBm) - layering noise\n  #define OCTAVES 4 // Number of noise layers (adjust for detail/performance)\n  float fbm (vec2 st) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 0.0;\n      // Loop through octaves, adding noise at different frequencies/amplitudes\n      for (int i = 0; i < OCTAVES; i++) {\n          value += amplitude * noise(st);\n          st *= 2.0; // Double frequency for next octave\n          amplitude *= 0.5; // Halve amplitude for next octave\n      }\n      return value;\n  }\n  // --- End Noise Functions ---\n\n  // Function to calculate distance from hover point (same as before)\n  float getHoverDist(vec2 pos) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    vec2 diff = pos - u_hoverPos;\n    diff.x *= aspectRatio;\n    return distance(vec2(0.0), diff);\n  }\n\n  void main() {\n    // --- Calculate Base Aura Color using Noise ---\n    // Scale UV and add time for animation. Adjust scale (e.g., * 3.0) for noise detail.\n    vec2 noisyCoord = v_uv * 2.5 + vec2(u_time * 0.02, u_time * 0.03); // Slow movement\n    float noisePattern = fbm(noisyCoord);\n\n    // Base color blend - mix between target colors\n    vec3 baseColor = mix(u_colorTarget1, u_colorTarget2, u_colorMixFactor);\n\n    // Modulate the base color blend using the noise pattern\n    // Mix based on noise value AND vertical position for variety\n    vec3 auraColor = mix(baseColor, mix(u_colorTarget1, u_colorTarget2, v_uv.y * 0.8 + 0.1), noisePattern * 0.6);\n    // Add subtle contrast/brightness variation based on noise\n    auraColor *= (0.9 + noisePattern * 0.2);\n\n    // --- Hover Effect (Applied on top of aura) ---\n    vec3 finalColor = auraColor;\n    if (u_isHovering) {\n      float dist = getHoverDist(v_uv);\n      // Ripple/glow effect - use smoothstep for soft edges\n      float hoverIntensity = smoothstep(0.20, 0.0, dist); // Increased radius slightly\n\n      // Make the glow slightly colored (e.g., whitish or based on u_hoverColor if available)\n      vec3 glowColor = vec3(0.8, 0.8, 0.9); // Whitish glow\n      // Optionally use u_hoverColor: mix(glowColor, u_hoverColor, 0.5)\n\n      // Additive blend for glow, stronger near center\n      finalColor += glowColor * hoverIntensity * 0.6; // Adjust intensity multiplier\n\n      // Optional: Slight displacement/warp effect (more complex)\n      // vec2 displacement = normalize(v_uv - u_hoverPos) * hoverIntensity * 0.01;\n      // Recalculate noise/color at v_uv - displacement ? (performance cost)\n    }\n\n    // Ensure color values stay within valid range\n    gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n  }\n`;\n\n// --- Component ---\nconst AuraBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const bufferRef = useRef<WebGLBuffer | null>(null); // Single buffer for a quad\n  const attribLocationsRef = useRef<{ [key: string]: number }>({});\n  const uniformLocationsRef = useRef<{ [key: string]: WebGLUniformLocation | null }>({});\n  const animationFrameRef = useRef<number>();\n  const { dominantColors, hoverState } = useContext(ColorContext);\n\n  // Refs for animated uniform values (colors and hover state)\n  const animatedColor1 = useRef(hexToVec3(dominantColors[0] || '#041024'));\n  const animatedColor2 = useRef(hexToVec3(dominantColors[1] || dominantColors[0] || '#041024'));\n  const animatedMixFactor = useRef(dominantColors.length > 1 ? 1.0 : 0.0);\n  const animatedHoverPos = useRef<[number, number] | null>(\n    hoverState.position ? [hoverState.position.x, hoverState.position.y] : null\n  );\n  const animatedIsHovering = useRef(hoverState.isHovering ? 1.0 : 0.0); // Use float for smooth transition\n\n  // --- WebGL Helper Functions ---\n  const createShader = useCallback(\n    (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\n          `Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`,\n          gl.getShaderInfoLog(shader)\n        );\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    },\n    []\n  );\n\n  const createProgram = useCallback(\n    (\n      gl: WebGLRenderingContext,\n      vertexShader: WebGLShader,\n      fragmentShader: WebGLShader\n    ): WebGLProgram | null => {\n      const program = gl.createProgram();\n      if (!program) return null;\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program link error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return null;\n      }\n      return program;\n    },\n    []\n  );\n\n  // --- Animation Loop ---\n  const renderLoop = useCallback(\n    (time: number) => {\n      const gl = glRef.current;\n      const program = programRef.current;\n      if (!gl || !program) {\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\n        return;\n      }\n      const timeSeconds = time / 1000.0;\n\n      // --- Smooth Animation Logic (Lerping) ---\n      const lerpSpeed = 0.08; // Adjust for desired transition speed\n\n      // Animate Colors\n      const targetColor1 = hexToVec3(dominantColors[0] || '#041024');\n      const targetColor2 = hexToVec3(dominantColors[1] || dominantColors[0] || '#041024');\n      const targetMix = dominantColors.length > 1 ? 1.0 : 0.0;\n      animatedColor1.current = lerpArray(animatedColor1.current, targetColor1, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedColor2.current = lerpArray(animatedColor2.current, targetColor2, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedMixFactor.current = lerp(animatedMixFactor.current, targetMix, lerpSpeed);\n\n      // Animate Hover State\n      const targetIsHovering = hoverState.isHovering ? 1.0 : 0.0;\n      animatedIsHovering.current = lerp(\n        animatedIsHovering.current,\n        targetIsHovering,\n        lerpSpeed * 2\n      ); // Faster hover transition\n\n      if (hoverState.isHovering && hoverState.position) {\n        const targetPos: [number, number] = [hoverState.position.x, hoverState.position.y];\n        if (!animatedHoverPos.current) {\n          animatedHoverPos.current = targetPos; // Snap if starting from null\n        } else {\n          animatedHoverPos.current = lerpArray(\n            animatedHoverPos.current,\n            targetPos,\n            lerpSpeed * 2\n          ) as [number, number];\n        }\n      } else {\n        // Optionally, let the hover position fade out or just keep the last known position\n        // For now, we'll just use the latest position when hovering is true\n      }\n\n      // --- WebGL Rendering ---\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      // No need to clear if drawing a full-screen quad that covers everything\n      // gl.clearColor(0, 0, 0, 0);\n      // gl.clear(gl.COLOR_BUFFER_BIT);\n\n      // Log context state and calculated animation values\n      // console.log('[AuraBackground Loop] Context HoverState:', hoverState);\n      // console.log('[AuraBackground Loop] Animated Hover:', { isHovering: animatedIsHovering.current, pos: animatedHoverPos.current });\n\n      gl.useProgram(program);\n\n      // Bind the quad buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n      const posLocation = attribLocationsRef.current.position;\n      if (posLocation !== -1) {\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(posLocation);\n      }\n\n      // Set Uniforms\n      gl.uniform2f(uniformLocationsRef.current.resolution, gl.canvas.width, gl.canvas.height);\n      gl.uniform1f(uniformLocationsRef.current.time, timeSeconds);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget1, animatedColor1.current);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget2, animatedColor2.current);\n      gl.uniform1f(uniformLocationsRef.current.colorMixFactor, animatedMixFactor.current);\n\n      // Hover Uniforms\n      gl.uniform1f(\n        uniformLocationsRef.current.isHovering,\n        animatedIsHovering.current > 0.01 ? 1.0 : 0.0\n      ); // Use threshold for bool\n      if (animatedHoverPos.current) {\n        gl.uniform2fv(uniformLocationsRef.current.hoverPos, animatedHoverPos.current);\n      }\n      // gl.uniform3fv(uniformLocationsRef.current.hoverColor, hoverState.color ? hexToVec3(hoverState.color) : [0,0,0]); // TODO: Add hover color logic\n\n      // Draw the quad (2 triangles)\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      animationFrameRef.current = requestAnimationFrame(renderLoop);\n    },\n    [dominantColors, hoverState]\n  ); // Dependencies for lerp targets\n\n  // --- Initialization Effect ---\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    if (!canvasElement) return;\n\n    const gl = canvasElement.getContext('webgl', { alpha: false, antialias: true }); // alpha: false maybe faster? antialias: true for smoother gradients\n    if (!gl) {\n      console.error('WebGL not supported or context creation failed.');\n      return;\n    }\n    glRef.current = gl;\n\n    // Compile shaders\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!vertexShader || !fragmentShader) return;\n\n    // Link program\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    if (!program) return;\n    programRef.current = program;\n\n    // Detach and delete shaders after linking\n    gl.detachShader(program, vertexShader);\n    gl.detachShader(program, fragmentShader);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    // --- Create Buffer for Fullscreen Quad ---\n    // Vertices for two triangles covering the screen (-1 to 1)\n    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n    bufferRef.current = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    // --- Look up locations ---\n    attribLocationsRef.current.position = gl.getAttribLocation(program, 'a_position');\n    uniformLocationsRef.current.resolution = gl.getUniformLocation(program, 'u_resolution');\n    uniformLocationsRef.current.time = gl.getUniformLocation(program, 'u_time');\n    uniformLocationsRef.current.colorTarget1 = gl.getUniformLocation(program, 'u_colorTarget1');\n    uniformLocationsRef.current.colorTarget2 = gl.getUniformLocation(program, 'u_colorTarget2');\n    uniformLocationsRef.current.colorMixFactor = gl.getUniformLocation(program, 'u_colorMixFactor');\n    uniformLocationsRef.current.isHovering = gl.getUniformLocation(program, 'u_isHovering');\n    uniformLocationsRef.current.hoverPos = gl.getUniformLocation(program, 'u_hoverPos');\n    uniformLocationsRef.current.hoverColor = gl.getUniformLocation(program, 'u_hoverColor');\n\n    // --- Resize Handling ---\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!entries || entries.length === 0) return;\n      const { width, height } = entries[0].contentRect;\n      if (glRef.current) {\n        glRef.current.canvas.width = width;\n        glRef.current.canvas.height = height;\n      }\n    });\n    resizeObserver.observe(canvasElement);\n\n    // Start render loop\n    animationFrameRef.current = requestAnimationFrame(renderLoop);\n\n    // --- Cleanup ---\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      resizeObserver.disconnect();\n\n      const currentGl = glRef.current;\n      if (currentGl) {\n        if (bufferRef.current) currentGl.deleteBuffer(bufferRef.current);\n        if (programRef.current) currentGl.deleteProgram(programRef.current);\n      }\n      glRef.current = null;\n      programRef.current = null;\n      bufferRef.current = null;\n    };\n    // Add renderLoop to dependencies if its definition relies on changing props/state from outside\n  }, [createShader, createProgram, renderLoop]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={styles.particleBackground} // Reuse style or create AuraBackground.module.scss\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        pointerEvents: 'none',\n        zIndex: -1, // Keep behind content\n        // backgroundColor: '#041024', // Optional fallback bg\n      }}\n    />\n  );\n};\n\nexport default React.memo(AuraBackground);\n","export function truncateImageTitle(title: string | undefined): string {\n  if (!title) return 'Untitled';\n\n  // Remove file extensions and common suffixes anywhere in the string\n  const cleanTitle = title\n    // Remove file extensions and version numbers\n    .replace(/\\.(preview|thumbnail|jpg|jpeg|png|gif|webp)/gi, '')\n    .replace(/[-_.](v\\d+|example|intro|concept)[-_.]?\\d*/gi, '')\n    // Remove technical suffixes and common patterns\n    .replace(/[-_.]?(flux|lora|ai|toolkit|preview|example\\d*|poster)[-_.]?/gi, ' ')\n    // Remove numbered suffixes like .0, .1, .2\n    .replace(/\\.\\d+$/, '')\n    // Remove long number sequences and IDs\n    .replace(/[-_.]?\\d{6,}[-_.]?/g, '')\n    // Remove underscore/dash/dot between numbers\n    .replace(/(\\d)[-_.](\\d)/g, '$1$2')\n    // Remove numbers at the end of titles (like \"Character Style 1\")\n    .replace(/\\s+\\d+$/, '')\n    // Clean up remaining underscores, dashes, dots and extra spaces\n    .replace(/[-_.]+/g, ' ')\n    .replace(/\\s+/g, ' ');\n\n  // Split into words and properly capitalize each word\n  const formattedTitle = cleanTitle\n    .split(' ')\n    .map(word => {\n      // Keep acronyms uppercase, capitalize first letter of other words\n      return word.match(/^[A-Z]{2,}$/)\n        ? word\n        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ')\n    .trim();\n\n  // Truncate if necessary\n  const maxLength = 30;\n  return formattedTitle.length > maxLength\n    ? formattedTitle.substring(0, maxLength) + '...'\n    : formattedTitle;\n}\n","import { motion } from 'framer-motion';\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ProcessedImageUpdate, useImageProcessing } from '../contexts/ImageProcessingContext';\nimport styles from '../styles/ImageItem.module.scss';\nimport { ImageInfo } from '../types/index.js';\nimport { truncateImageTitle } from '../utils/stringUtils.js';\n\n// Define hover data payload\nexport interface ImageHoverData {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates relative to viewport/background\n  color: string | null; // Dominant color of the image, if available\n  imageId: string;\n}\n\n// Type for the processed image callback data\ninterface ProcessedImageData {\n  id: string;\n  quality: 'low' | 'high';\n  processedImage: string;\n}\n\ninterface ImageItemProps {\n  image: ImageInfo;\n  onClick: (image: ImageInfo) => void;\n  containerWidth: number;\n  containerHeight: number;\n  zoom: number;\n  groupCount?: number;\n  onResize?: (width: number, height: number) => void;\n  width: number;\n  height: number;\n  isCarousel: boolean;\n  groupImages: ImageInfo[];\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColor?: string | null; // Added optional prop for color from worker\n}\n\n// ResponsiveImage component (Refined & Forwarding Ref)\ninterface ResponsiveImageProps {\n  src: string;\n  alt: string;\n  width?: number;\n  isProcessed: boolean;\n  // isLoaded state is managed internally by ResponsiveImage now\n  onLoad: () => void;\n  onError: () => void;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst ResponsiveImage = React.forwardRef<HTMLImageElement, ResponsiveImageProps>(\n  ({ src, alt, width, isProcessed, onLoad, onError, className, style }, ref) => {\n    const [isInternallyLoaded, setIsInternallyLoaded] = useState(false);\n\n    // Reset loaded state if src changes\n    useEffect(() => {\n      setIsInternallyLoaded(false);\n    }, [src]);\n\n    const handleLoad = useCallback(() => {\n      setIsInternallyLoaded(true);\n      onLoad(); // Notify parent\n    }, [onLoad]);\n\n    const handleError = useCallback(() => {\n      setIsInternallyLoaded(false); // Ensure opacity stays 0 on error\n      onError(); // Notify parent\n    }, [onError]);\n\n    const useSrcSet = !isProcessed && width && !src.startsWith('blob:');\n    const srcSet = useSrcSet\n      ? [\n          `${src}&w=${Math.round(width as number)} 1x`,\n          `${src}&w=${Math.round((width as number) * 2)} 2x`,\n          `${src}&w=${Math.round((width as number) * 3)} 3x`,\n        ].join(', ')\n      : undefined;\n    const sizes = useSrcSet ? `${Math.round(width as number)}px` : undefined;\n\n    return (\n      <motion.img\n        ref={ref}\n        key={src}\n        src={src}\n        alt={alt}\n        className={className}\n        loading=\"lazy\"\n        style={{\n          display: 'block',\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n          position: 'absolute', // Position absolutely to overlay placeholder\n          top: 0,\n          left: 0,\n          ...style,\n        }}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: isInternallyLoaded ? 1 : 0 }} // Use internal loaded state\n        transition={{ duration: 0.4, ease: 'easeIn' }}\n        onLoad={handleLoad}\n        onError={handleError} // Use the internal error handler\n        srcSet={srcSet}\n        sizes={sizes}\n      />\n    );\n  }\n);\nResponsiveImage.displayName = 'ResponsiveImage';\n\nconst ImageItem: React.FC<ImageItemProps> = ({\n  image,\n  onClick,\n  containerWidth,\n  containerHeight,\n  zoom = 1,\n  groupCount,\n  onResize,\n  width,\n  height,\n  isCarousel = false,\n  groupImages = [],\n  onImageHover,\n  onImageLoadError,\n  dominantColor,\n}) => {\n  const imageRef = useRef<HTMLImageElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [isHighResLoaded, setIsHighResLoaded] = useState(false);\n  const [processedUrls, setProcessedUrls] = useState<{ low?: string; high?: string }>({});\n  const [hasError, setHasError] = useState(false);\n  const [hasLowResProcessed, setHasLowResProcessed] = useState(false);\n  const [hasHighResProcessed, setHasHighResProcessed] = useState(false);\n  const { subscribeToImageUpdates } = useImageProcessing();\n\n  const placeholderColor = useMemo(() => {\n    return dominantColor || '#333';\n  }, [dominantColor]);\n\n  const targetWidth = containerWidth;\n  const targetHeight = containerHeight;\n\n  const aspectRatio = useMemo(() => {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      return `${image.width} / ${image.height}`;\n    }\n    if (targetWidth > 0 && targetHeight > 0) {\n      return `${targetWidth} / ${targetHeight}`;\n    }\n    return '1 / 1';\n  }, [image.width, image.height, targetWidth, targetHeight]);\n\n  useEffect(() => {\n    if (onResize) {\n      onResize(targetWidth, targetHeight);\n    }\n  }, [targetWidth, targetHeight, onResize]);\n\n  const handleMouseEnter = useCallback(() => {\n    if (containerRef.current) {\n      const rect = containerRef.current.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      const normalizedX = centerX / window.innerWidth;\n      const normalizedY = centerY / window.innerHeight;\n      onImageHover({\n        isHovering: true,\n        position: { x: normalizedX, y: normalizedY },\n        color: dominantColor || null,\n        imageId: image.id,\n      });\n    }\n  }, [onImageHover, image.id, dominantColor]);\n\n  const handleMouseLeave = useCallback(() => {\n    onImageHover({\n      isHovering: false,\n      position: null,\n      color: null,\n      imageId: image.id,\n    });\n  }, [onImageHover, image.id]);\n\n  const handleProcessedImageUpdate = useCallback(\n    (data: ProcessedImageUpdate) => {\n      console.log(`[ImageItem ${image.id}] Received processed data via context: ${data.quality}`);\n      setProcessedUrls(prev => ({\n        ...prev,\n        [data.quality]: data.imageUrl,\n      }));\n      if (data.quality === 'low') {\n        setHasLowResProcessed(true);\n      }\n      if (data.quality === 'high') {\n        setHasHighResProcessed(true);\n      }\n    },\n    [image.id]\n  );\n\n  useEffect(() => {\n    const unsubscribe = subscribeToImageUpdates(image.id, handleProcessedImageUpdate);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [image.id, subscribeToImageUpdates, handleProcessedImageUpdate]);\n\n  useEffect(() => {\n    const currentLowUrl = processedUrls.low;\n    const currentHighUrl = processedUrls.high;\n    if (currentLowUrl) {\n      console.log(`[ImageItem ${image.id}] Revoking low-res blob URL on unmount: ${currentLowUrl}`);\n      URL.revokeObjectURL(currentLowUrl);\n    }\n    if (currentHighUrl) {\n      console.log(\n        `[ImageItem ${image.id}] Revoking high-res blob URL on unmount: ${currentHighUrl}`\n      );\n      URL.revokeObjectURL(currentHighUrl);\n    }\n  }, []);\n\n  const currentSrc = useMemo(() => {\n    if (processedUrls.high) return processedUrls.high;\n    if (processedUrls.low) return processedUrls.low;\n    return image.src;\n  }, [processedUrls.high, processedUrls.low, image.src]);\n\n  const isUsingProcessed = !!(processedUrls.high || processedUrls.low);\n\n  const shouldRenderImage = hasLowResProcessed || hasHighResProcessed || (!hasError && currentSrc);\n\n  const handleImageLoad = useCallback(() => {\n    if (processedUrls.high || (!hasLowResProcessed && !hasHighResProcessed)) {\n      setIsHighResLoaded(true);\n    }\n    setHasError(false);\n  }, [processedUrls.high, hasLowResProcessed, hasHighResProcessed]);\n\n  const handleImageError = useCallback(() => {\n    setHasError(true);\n    onImageLoadError(image.id);\n  }, [image.id, onImageLoadError]);\n\n  const truncatedTitle = useMemo(\n    () => truncateImageTitle(image.alt || image.title || 'Untitled'),\n    [image.alt, image.title]\n  );\n\n  if (hasError) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className={styles.imageItemContainer}\n      onClick={() => !hasError && onClick(image)}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      style={{\n        width: `${targetWidth}px`,\n        height: `${targetHeight}px`,\n        aspectRatio: aspectRatio,\n        position: 'relative',\n        overflow: 'hidden',\n        cursor: hasError ? 'not-allowed' : 'pointer',\n        backgroundColor: placeholderColor,\n      }}\n    >\n      {shouldRenderImage && (\n        <ResponsiveImage\n          ref={imageRef}\n          key={currentSrc}\n          src={currentSrc}\n          alt={image.alt || image.id}\n          width={targetWidth}\n          isProcessed={isUsingProcessed}\n          onLoad={handleImageLoad}\n          onError={handleImageError}\n          className={styles.imageElement}\n        />\n      )}\n\n      {hasError && (\n        <div className={styles.errorOverlay}>\n          <span>Error</span>\n        </div>\n      )}\n\n      <div className={styles.titleOverlay}>{truncateImageTitle(image.alt || image.id)}</div>\n\n      {groupCount && groupCount > 1 && <div className={styles.groupIndicator}>{groupCount}</div>}\n    </div>\n  );\n};\n\nexport default memo(ImageItem);\n","import { motion, useAnimation, Variants } from 'framer-motion';\nimport React, { useRef } from 'react';\nimport styles from '../styles/ImageRow.module.scss';\nimport { ImageInfo } from '../types/index.js';\n// import { createImageProcessor } from '../workers/imageProcessor'; // No longer needed directly\nimport WorkerPool from '../workers/workerPool'; // Import WorkerPool type\nimport ImageItem, { ImageHoverData } from './ImageItem.js';\n\n// Define the props interface for the ImageRow component\ninterface ImageRowProps {\n  images: ImageInfo[];\n  imageWidths: number[];\n  onImageClick: (clickedImage: ImageInfo) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  groupedImages: { key: string; images: ImageInfo[]; isCarousel: boolean }[];\n  workerPool: WorkerPool;\n  gap: number;\n  containerWidth: number;\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColorMap?: Map<string, string>; // Added optional prop for colors\n}\n\n// Define a smoother transition for layout animations using a soft spring\nconst smoothLayoutTransition = {\n  type: 'spring', // Back to spring for a more natural feel\n  stiffness: 120, // Lower stiffness for less aggression\n  damping: 30, // Higher damping to reduce oscillation\n  mass: 1, // Standard mass\n  // Removed tween-specific parameters\n};\n\n// Define variants for item entrance animation\nconst itemVariants: Variants = {\n  hidden: { opacity: 0, scale: 0.95 },\n  visible: (i: number) => ({\n    // Accept custom data (index)\n    opacity: 1,\n    scale: 1,\n    transition: {\n      delay: i * 0.03, // Stagger the animation based on index\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  }),\n};\n\n// Define the ImageRow component\nconst ImageRow: React.FC<ImageRowProps> = ({\n  images,\n  imageWidths,\n  onImageClick,\n  columns,\n  zoom,\n  isLastRow,\n  rowHeight,\n  groupedImages,\n  workerPool,\n  gap,\n  containerWidth,\n  onImageHover,\n  onImageLoadError,\n  dominantColorMap, // Destructure the new prop\n}) => {\n  const rowRef = useRef<HTMLDivElement>(null);\n  const controls = useAnimation();\n\n  if (\n    !images ||\n    images.length === 0 ||\n    !imageWidths ||\n    imageWidths.length !== images.length ||\n    rowHeight <= 0\n  ) {\n    return null;\n  }\n\n  return (\n    <motion.div\n      ref={rowRef}\n      className={styles.imageRow}\n      animate={controls}\n      initial={false}\n      style={{\n        display: 'flex',\n        flexWrap: 'nowrap',\n        overflow: 'hidden',\n        gap: `${gap}px`,\n        height: `${rowHeight}px`,\n        marginBottom: `${gap}px`,\n        position: 'relative',\n        willChange: 'transform',\n        width: '100%',\n        maxWidth: `${containerWidth}px`,\n        justifyContent: 'flex-start',\n        alignItems: 'stretch',\n      }}\n      layout\n      transition={smoothLayoutTransition}\n    >\n      {images.map((image, index) => {\n        const group = groupedImages.find(g => g.images.some(img => img.id === image.id));\n        const width = imageWidths[index];\n\n        if (width === undefined || width <= 0) {\n          console.warn(\n            `Invalid width (${width}) calculated for image ${image.id} at index ${index}`\n          );\n          return null;\n        }\n\n        // Get the dominant color for this specific image from the map\n        const dominantColor = dominantColorMap?.get(image.id);\n\n        return (\n          <motion.div\n            key={image.id}\n            className={styles.imageWrapper}\n            custom={index}\n            initial=\"hidden\"\n            animate=\"visible\"\n            variants={itemVariants}\n            style={{\n              width: `${width}px`,\n              height: `${rowHeight}px`,\n              flexShrink: 0,\n              flexGrow: 0,\n              position: 'relative',\n              overflow: 'hidden',\n            }}\n            layout\n            transition={smoothLayoutTransition}\n          >\n            <ImageItem\n              image={image}\n              onClick={() => onImageClick(image)}\n              containerWidth={width}\n              containerHeight={rowHeight}\n              width={width}\n              height={rowHeight}\n              zoom={zoom}\n              isCarousel={group?.isCarousel || false}\n              groupImages={group?.images || []}\n              onImageHover={onImageHover}\n              onImageLoadError={onImageLoadError}\n              dominantColor={dominantColor} // Pass the specific color down\n            />\n          </motion.div>\n        );\n      })}\n    </motion.div>\n  );\n};\n\n// Export the memoized component\nexport default React.memo(ImageRow);\n","import React from 'react';\nimport styles from '../styles/ImageItem.module.scss';\n\ninterface ImageSkeletonProps {\n  containerWidth: number;\n  containerHeight: number;\n  placeholderColor?: string;\n}\n\nconst ImageSkeleton: React.FC<ImageSkeletonProps> = ({\n  containerWidth,\n  containerHeight,\n  placeholderColor,\n}) => {\n  const backgroundStyle = placeholderColor ? { backgroundColor: placeholderColor } : {};\n\n  return (\n    <div\n      className={`${styles.imageItem} ${styles.imageSkeleton}`}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        maxWidth: '100%',\n        maxHeight: '100%',\n        aspectRatio: `${containerWidth} / ${containerHeight}`,\n        ...backgroundStyle,\n      }}\n    >\n      <div className={styles.skeletonAnimation}></div>\n    </div>\n  );\n};\n\nexport default ImageSkeleton;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport { motion } from 'framer-motion';\n\ninterface BannerViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst BannerView: React.FC<BannerViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  return (\n    <div className=\"banner-view space-y-4\">\n      {images.map((image, index) => (\n        <motion.div\n          key={image.id}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.5, delay: index * 0.1 }}\n          className=\"banner-item relative\"\n        >\n          <div\n            className=\"banner-image-container w-full h-[300px] rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-shadow duration-300\"\n            style={{ height: `${300 * zoom}px` }}\n          >\n            <img src={image.src} alt={image.alt} className=\"w-full h-full object-cover\" />\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n              <p className=\"text-white/80 text-sm\">\n                {image.width}  {image.height}\n              </p>\n            </div>\n          </div>\n        </motion.div>\n      ))}\n    </div>\n  );\n};\n\nexport default BannerView;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport Slider from 'react-slick';\nimport { motion } from 'framer-motion';\nimport { FaChevronLeft, FaChevronRight } from 'react-icons/fa';\n\ninterface CarouselViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst NextArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute right-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronRight />\n    </button>\n  );\n};\n\nconst PrevArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute left-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronLeft />\n    </button>\n  );\n};\n\nconst CarouselView: React.FC<CarouselViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  const settings = {\n    dots: true,\n    infinite: true,\n    speed: 500,\n    slidesToShow: 1,\n    slidesToScroll: 1,\n    nextArrow: <NextArrow />,\n    prevArrow: <PrevArrow />,\n    adaptiveHeight: true,\n    customPaging: (i: number) => (\n      <div className=\"w-3 h-3 mx-1 rounded-full bg-white/50 hover:bg-white/70 transition-colors duration-300\" />\n    ),\n  };\n\n  return (\n    <div className=\"carousel-view\">\n      <Slider {...settings}>\n        {images.map((image, index) => (\n          <motion.div\n            key={image.id}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ duration: 0.5 }}\n            className=\"outline-none\"\n          >\n            <div className=\"relative aspect-video\">\n              <img\n                src={image.src}\n                alt={image.alt}\n                className=\"w-full h-full object-contain\"\n                style={{\n                  maxHeight: `${600 * zoom}px`,\n                }}\n              />\n              <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n                <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n                <p className=\"text-white/80 text-sm\">\n                  {image.width}  {image.height}\n                </p>\n              </div>\n            </div>\n          </motion.div>\n        ))}\n      </Slider>\n    </div>\n  );\n};\n\nexport default CarouselView;\n","import React from 'react';\r\nimport { ImageInfo } from '../../types';\r\nimport Masonry from 'react-masonry-css';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface MasonryViewProps {\r\n  images: ImageInfo[];\r\n  zoom: number;\r\n}\r\n\r\nconst MasonryView: React.FC<MasonryViewProps> = ({ images, zoom }) => {\r\n  const breakpointColumns = {\r\n    default: 4,\r\n    1536: 4,\r\n    1280: 3,\r\n    1024: 3,\r\n    768: 2,\r\n    640: 1,\r\n  };\r\n\r\n  if (!images.length) {\r\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\r\n  }\r\n\r\n  return (\r\n    <Masonry\r\n      breakpointCols={breakpointColumns}\r\n      className=\"flex -ml-4 w-auto\"\r\n      columnClassName=\"pl-4 bg-clip-padding\"\r\n    >\r\n      {images.map((image, index) => (\r\n        <motion.div\r\n          key={image.id}\r\n          initial={{ opacity: 0, scale: 0.9 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          transition={{ duration: 0.5, delay: index * 0.1 }}\r\n          className=\"mb-4\"\r\n        >\r\n          <div className=\"relative group rounded-lg overflow-hidden shadow-md hover:shadow-xl transition-shadow duration-300\">\r\n            <img\r\n              src={image.src}\r\n              alt={image.alt}\r\n              className=\"w-full h-auto\"\r\n              style={{\r\n                maxHeight: `${400 * zoom}px`,\r\n                objectFit: 'cover',\r\n              }}\r\n            />\r\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4 transform translate-y-full group-hover:translate-y-0 transition-transform duration-300\">\r\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\r\n              <p className=\"text-white/80 text-sm\">\r\n                {image.width}  {image.height}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </motion.div>\r\n      ))}\r\n    </Masonry>\r\n  );\r\n};\r\n\r\nexport default MasonryView;\r\n","import { useVirtualizer } from '@tanstack/react-virtual';\nimport { motion } from 'framer-motion';\nimport { default as lodashDebounce } from 'lodash/debounce';\nimport React, {\n  CSSProperties,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport Lightbox from 'yet-another-react-lightbox';\nimport Captions from 'yet-another-react-lightbox/plugins/captions';\nimport 'yet-another-react-lightbox/plugins/captions.css';\nimport Counter from 'yet-another-react-lightbox/plugins/counter';\nimport 'yet-another-react-lightbox/plugins/counter.css';\nimport Thumbnails from 'yet-another-react-lightbox/plugins/thumbnails';\nimport 'yet-another-react-lightbox/plugins/thumbnails.css';\nimport Zoom from 'yet-another-react-lightbox/plugins/zoom';\nimport 'yet-another-react-lightbox/styles.css';\nimport { ColorContext } from '../contexts/ColorContext';\nimport { useImageProcessing } from '../contexts/ImageProcessingContext';\nimport { useFolderImages } from '../hooks/query/useFolderImages';\nimport { usePrefetchManager } from '../hooks/usePrefetchManager.js';\nimport useWindowSize from '../hooks/useWindowSize.js';\nimport { loadScrollState, saveScrollState, ScrollState } from '../lib/cache/feedStateCache';\nimport styles from '../styles/ImageFeed.module.scss';\nimport { ImageInfo, ViewMode } from '../types/index.js';\nimport AnimationSystem from '../utils/AnimationSystem';\nimport {\n  calculateGapSize,\n  calculateLayout,\n  LayoutConfig,\n  MIN_IMAGE_WIDTH,\n  RowConfig,\n} from '../utils/layoutCalculator';\nimport WorkerPool, { WorkerType } from '../workers/workerPool';\nimport AuraBackground from './AuraBackground';\nimport { ImageHoverData } from './ImageItem.js';\nimport ImageRow from './ImageRow.js';\nimport ImageSkeleton from './ImageSkeleton.js';\nimport { BannerView, CarouselView, MasonryView } from './views';\n\n// Simple throttle function\nfunction throttle<F extends (...args: any[]) => any>(func: F, limit: number) {\n  let inThrottle: boolean;\n  let lastResult: ReturnType<F>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const throttled = function (this: ThisParameterType<F>, ...args: Parameters<F>): void {\n    const context = this;\n    if (!inThrottle) {\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n      // Call the function but don't worry about returning its result for listener\n      func.apply(context, args);\n    }\n    // Explicitly return void for listener compatibility\n    // return lastResult; // Removed potentially problematic return\n  };\n\n  return throttled;\n}\n\n// Simple debounce function (with cancel)\nfunction debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = (...args: Parameters<F>) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => func(...args), waitFor);\n  };\n\n  // Add the cancel method\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null; // Clear the ID after cancelling\n    }\n  };\n\n  return debounced as F & { cancel: () => void };\n}\n\n// Define the props interface for ImageFeed component\ninterface ImageFeedProps {\n  folderPath: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: React.RefObject<HTMLElement>;\n}\n\ninterface CustomStyle extends CSSProperties {\n  '--energy-color'?: string;\n  '--ripple-x'?: string;\n  '--ripple-y'?: string;\n  '--ripple-strength'?: string;\n}\n\n// Interface for messages from ColorExtractorWorker\ninterface ColorResultData {\n  id: string;\n  color: string | null;\n}\n\n// Interface for messages from GroupingWorker\ninterface ImageGroup {\n  key: string;\n  images: ImageInfo[];\n  isCarousel: boolean;\n}\ninterface GroupingResultData {\n  groupedImages: ImageGroup[];\n}\n\n// Define payload TYPESCRIPT INTERFACES for worker requests if needed for clarity,\n// but use component's internal types for results where appropriate.\ninterface GroupingRequestPayload {\n  images: ImageInfo[];\n  isGrouped: boolean;\n}\ninterface LayoutRequestPayload {\n  images: ImageInfo[];\n  containerWidth: number;\n  zoom: number;\n  targetRowHeight: number;\n}\ninterface ColorRequestPayload {\n  id: string;\n  src: string;\n}\n// Define the TYPE for the expected successful PAYLOAD from the color worker\n// Align this with what the color worker actually sends back in its payload\ninterface ColorWorkerSuccessPayload {\n  id: string;\n  color: string | null;\n}\n\n// Define the ImageFeed component\nconst ImageFeed: React.FC<ImageFeedProps> = ({\n  folderPath,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  const {\n    data: originalImages,\n    isLoading: isLoadingImages,\n    isError,\n    error,\n    isPlaceholderData,\n  } = useFolderImages(folderPath);\n\n  const windowSize = useWindowSize();\n  const feedRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [columns, setColumns] = useState(4);\n  const [lightboxIndex, setLightboxIndex] = useState<number>(-1);\n  const [lightboxImages, setLightboxImages] = useState<ImageInfo[]>([]);\n  const animationSystem = useMemo(() => AnimationSystem.getInstance(), []);\n  const { setDominantColors, setHoverState } = useContext(ColorContext);\n  const [dominantColorMap, setDominantColorMap] = useState<Map<string, string>>(new Map());\n  const requestedColorIds = useRef<Set<string>>(new Set());\n  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const [restoredState, setRestoredState] = useState<ScrollState | null>(null);\n  const previousFolderPathRef = useRef<string | null>(null);\n  const rowHeightsRef = useRef<number[]>([]);\n  const isRestoringScrollRef = useRef(false);\n  const velocityEMARef = useRef(0);\n  const OVERSCAN_BASE = 3;\n  const OVERSCAN_MAX = 15;\n  const EMA_ALPHA = 0.2;\n  const OVERSCAN_FACTOR = 10;\n  const [dynamicOverscan, setDynamicOverscan] = useState(OVERSCAN_BASE);\n  const [failedImageIds, setFailedImageIds] = useState<Set<string>>(new Set());\n  const { publishImageUpdate } = useImageProcessing();\n\n  // --- Define getImageUrl earlier --- >\n  const getImageUrl = useCallback((imagePath: string) => {\n    let path = imagePath.replace(/\\\\/g, '/');\n    if (path.startsWith('/api/image/') || path.startsWith('/')) {\n      return path;\n    }\n    return `/api/image/${path}`;\n  }, []); // Empty dependency array, safe to define early\n\n  // --- Memoized Images & Failed Image Handling --- >\n  const images = useMemo(() => {\n    if (!originalImages) return [];\n    return originalImages.filter(img => img && !failedImageIds.has(img.id)); // Added check for img existence\n  }, [originalImages, failedImageIds]);\n\n  const handleImageLoadError = useCallback((imageId: string) => {\n    setFailedImageIds(prev => {\n      if (prev.has(imageId)) return prev;\n      console.log(`ImageFeed: Registering error for image ${imageId}`);\n      const newSet = new Set(prev);\n      newSet.add(imageId);\n      return newSet;\n    });\n  }, []);\n\n  // --- Worker Pool --- >\n  const workerPool = useMemo(() => WorkerPool.getInstance(), []);\n\n  // --- State for Worker Operations --- >\n  const [calculatedRows, setCalculatedRows] = useState<RowConfig[]>([]);\n  const [isLayoutCalculating, setIsLayoutCalculating] = useState(false);\n  const [processedGroupedImages, setProcessedGroupedImages] = useState<ImageGroup[]>([]);\n  const [isGrouping, setIsGrouping] = useState(false);\n  // Flag to track if an async operation is currently active for a worker type\n  const activeRequestRef = useRef<{ [key in WorkerType]?: boolean }>({});\n\n  // --- Layout Data Map --- >\n  const layoutDataMap = useMemo(() => {\n    const map = new Map<string, { top: number; left: number; width: number; height: number }>();\n    let currentTop = 0;\n    const gap = calculateGapSize(zoom);\n    calculatedRows.forEach(row => {\n      let currentLeft = 0;\n      row.images.forEach((img, index) => {\n        if (!row.imageWidths || row.imageWidths.length <= index) {\n          console.warn(`[ImageFeed] Missing imageWidths for image ${img.id} in row.`);\n          return; // Skip this image if width data is missing\n        }\n        const width = row.imageWidths[index];\n        map.set(img.id, {\n          top: currentTop,\n          left: currentLeft,\n          width: width,\n          height: row.height,\n        });\n        currentLeft += width + gap;\n      });\n      currentTop += row.height + gap;\n    });\n    return map;\n  }, [calculatedRows, zoom]);\n\n  // --- Initialize Prefetch Manager --- >\n  // Only initialize if we have images and the necessary layout data\n  usePrefetchManager({\n    scrollContainerRef,\n    imageList: images, // Use the filtered images\n    layoutData: layoutDataMap,\n    // We can add configuration options here later (lookaheadDistance, concurrency)\n  });\n\n  // --- Debouncing Logic for isGrouped ---\n  const [debouncedIsGrouped, setDebouncedIsGrouped] = useState(isGrouped);\n  const updateDebouncedGrouped = useCallback(\n    lodashDebounce((newValue: boolean) => {\n      setDebouncedIsGrouped(newValue);\n      console.log('[ImageFeed] Applying debounced isGrouped:', newValue);\n    }, 300),\n    []\n  );\n  useEffect(() => {\n    updateDebouncedGrouped(isGrouped);\n    return () => updateDebouncedGrouped.cancel();\n  }, [isGrouped, updateDebouncedGrouped]);\n\n  // --- Scroll Persistence Logic ---\n\n  // Debounced function to save scroll state during active scroll\n  const debouncedSaveScroll = useCallback(\n    debounce((path: string, scroll: number /*, heights: number[], width: number */) => {\n      if (path && !isRestoringScrollRef.current) {\n        saveScrollState(path, scroll);\n      }\n    }, 500),\n    []\n  );\n\n  // Load state on mount/folder change & Save state on unmount/folder change\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadAndSetState = async () => {\n      const loadedState = await loadScrollState(folderPath);\n      if (isMounted) {\n        if (loadedState) {\n          setRestoredState(loadedState);\n          isRestoringScrollRef.current = true;\n        } else {\n          setRestoredState(null);\n          if (scrollContainerRef.current) {\n            scrollContainerRef.current.scrollTop = 0;\n          }\n          isRestoringScrollRef.current = false;\n        }\n      }\n    };\n\n    loadAndSetState();\n\n    const currentPathForCleanup = folderPath;\n    previousFolderPathRef.current = currentPathForCleanup;\n\n    return () => {\n      isMounted = false;\n      const scrollElement = scrollContainerRef.current;\n      const folderToSave = previousFolderPathRef.current;\n\n      if (scrollElement && folderToSave && rowHeightsRef.current.length > 0) {\n        saveScrollState(folderToSave, scrollElement.scrollTop);\n      }\n\n      debouncedSaveScroll.cancel?.();\n      // --- Cancel All Pending Worker Tasks on Unmount --- >\n      console.log('ImageFeed: Unmounting, cancelling all pending worker tasks.');\n      workerPool.cancelAllPendingTasks();\n      // No need to remove listeners here as they are not used for request/response\n    };\n  }, [\n    folderPath,\n    scrollContainerRef,\n    debouncedSaveScroll,\n    workerPool, // Add workerPool as dependency for cleanup\n  ]);\n  // --- End Scroll Persistence Logic ---\n\n  // Calculate average aspect ratio for fallback estimation\n  const avgAspectRatio = useMemo(() => {\n    if (!originalImages || originalImages.length === 0) return 1; // Default aspect ratio\n    const validImages = originalImages.filter(img => img && img.width > 0 && img.height > 0);\n    if (validImages.length === 0) return 1;\n    const totalRatio = validImages.reduce((sum, img) => sum + img.width / img.height, 0);\n    return totalRatio / validImages.length;\n  }, [originalImages]);\n\n  // Calculate layout metrics\n  const layoutMetrics = useMemo(() => {\n    const gapSize = calculateGapSize(zoom);\n    let estimatedRowHeightFallback = 200; // Default\n    if (containerWidth > 0 && columns > 0 && avgAspectRatio > 0) {\n      const totalGapWidth = Math.max(0, columns - 1) * gapSize;\n      const availableWidthForImages = Math.max(0, containerWidth - totalGapWidth);\n      if (availableWidthForImages > 0) {\n        const estimatedAvgImageWidth = availableWidthForImages / columns;\n        estimatedRowHeightFallback = Math.max(\n          50,\n          Math.round(estimatedAvgImageWidth / avgAspectRatio)\n        );\n      }\n    }\n    return {\n      gapSize,\n      estimatedRowHeightFallback,\n    };\n  }, [containerWidth, columns, zoom, avgAspectRatio]);\n\n  // Reset states and CANCEL PENDING TASKS when folder/view mode/grouping/zoom changes\n  useEffect(() => {\n    setLightboxIndex(-1);\n    setLightboxImages([]);\n    setDominantColorMap(new Map());\n    requestedColorIds.current.clear();\n    setFailedImageIds(new Set());\n    setCalculatedRows([]);\n    setIsLayoutCalculating(false); // Reset loading state\n    setProcessedGroupedImages([]);\n    setIsGrouping(false); // Reset loading state\n\n    console.log(\n      `ImageFeed: Deps changed (${folderPath}/${viewMode}/${isGrouped}/${zoom}), cancelling pending worker tasks.`\n    );\n    // Cancel tasks related to the previous state\n    workerPool.cancelAllPendingTasks();\n    activeRequestRef.current = {}; // Reset active request flags\n  }, [folderPath, viewMode, isGrouped, zoom, workerPool]); // isGrouped and zoom trigger cancellation now\n\n  // --- Container Width Management ---\n  const updateContainerWidth = useCallback(() => {\n    if (!feedRef.current) return;\n    const rect = feedRef.current.getBoundingClientRect();\n    const newWidth = Math.max(MIN_IMAGE_WIDTH, rect.width);\n    setContainerWidth(prevWidth => {\n      if (newWidth !== prevWidth) {\n        const config: LayoutConfig = {\n          containerWidth: newWidth,\n          zoom,\n          viewMode,\n          isGrouped: debouncedIsGrouped, // Use debounced value here\n        };\n        const layout = calculateLayout(config);\n        setColumns(layout.columns);\n        return newWidth;\n      }\n      return prevWidth;\n    });\n  }, [zoom, viewMode, debouncedIsGrouped]);\n\n  useLayoutEffect(() => {\n    updateContainerWidth();\n  }, [updateContainerWidth]);\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(updateContainerWidth);\n    if (feedRef.current) {\n      resizeObserver.observe(feedRef.current);\n    }\n    window.addEventListener('resize', updateContainerWidth);\n    return () => {\n      resizeObserver.disconnect();\n      window.removeEventListener('resize', updateContainerWidth);\n    };\n  }, [updateContainerWidth]);\n  // --- End Container Width Management ---\n\n  // --- Effect for Pre-fetching Placeholder Colors (Now safe to use getImageUrl) --- >\n  useEffect(() => {\n    if (images && images.length > 0 && !isLoadingImages) {\n      const initialImageCount = Math.min(images.length, 30);\n      console.log(`[ImageFeed] Pre-fetching colors for initial ${initialImageCount} images...`);\n\n      for (let i = 0; i < initialImageCount; i++) {\n        const imageInfo = images[i];\n        if (\n          imageInfo &&\n          imageInfo.id &&\n          imageInfo.src &&\n          !dominantColorMap.has(imageInfo.id) &&\n          !requestedColorIds.current.has(imageInfo.id)\n        ) {\n          const imageUrl = getImageUrl(imageInfo.src); // Now defined\n          requestedColorIds.current.add(imageInfo.id);\n          // ... (rest of the postRequest logic)\n          workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              { id: imageInfo.id, src: imageUrl },\n              { priority: 2 }\n            )\n            .then(result => {\n              // ... (update map)\n            })\n            .catch(error => {\n              // ... (log error)\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(imageInfo.id);\n            });\n        }\n      }\n    }\n  }, [images, isLoadingImages, workerPool, getImageUrl]); // Keep getImageUrl in deps\n\n  // --- Grouping Worker Integration (Add Priority) --- >\n  useEffect(() => {\n    // Don't run if images haven't loaded, already grouping, or another request is active\n    if (!images || images.length === 0 || activeRequestRef.current.grouping) {\n      setProcessedGroupedImages([]);\n      setIsGrouping(false);\n      return;\n    }\n\n    // Define async function to call worker\n    const calculateGrouping = async () => {\n      console.log('[ImageFeed] Requesting grouping calculation...');\n      setIsGrouping(true);\n      activeRequestRef.current.grouping = true;\n\n      try {\n        const result = await workerPool.postRequest<\n          GroupingRequestPayload,\n          { groupedImages: ImageGroup[] }\n        >(\n          'grouping',\n          'groupImages',\n          { images: images, isGrouped: debouncedIsGrouped },\n          { priority: 9 } // High priority\n        );\n        if (activeRequestRef.current.grouping) {\n          console.log(\n            '[ImageFeed] Received grouping result:',\n            result.groupedImages.length,\n            'groups'\n          );\n          setProcessedGroupedImages(result.groupedImages);\n        }\n      } catch (error) {\n        console.error('[ImageFeed] Grouping worker request failed:', error);\n        setProcessedGroupedImages([]); // Clear results on error\n        // Optionally set an error state here for the UI\n      } finally {\n        // Check if the request flag is still set before clearing\n        if (activeRequestRef.current.grouping) {\n          setIsGrouping(false);\n          activeRequestRef.current.grouping = false;\n        }\n      }\n    };\n\n    // Call the async function\n    calculateGrouping();\n\n    // Cleanup function is implicitly handled by the dependency change effect\n    // which calls workerPool.cancelAllPendingTasks()\n  }, [images, debouncedIsGrouped, workerPool]); // Dependencies trigger the effect\n\n  // --- Layout Worker Integration (Add Priority) --- >\n  useEffect(() => {\n    // Depends on processedGroupedImages now\n    if (\n      viewMode !== ViewMode.GRID ||\n      processedGroupedImages.length === 0 ||\n      containerWidth <= 0 ||\n      activeRequestRef.current.layout // Prevent concurrent requests\n    ) {\n      setCalculatedRows([]);\n      setIsLayoutCalculating(false);\n      return;\n    }\n\n    // Send first image of each *processed* group\n    const firstImages = processedGroupedImages\n      .map(group => group.images[0])\n      .filter(image => image && image.width > 0 && image.height > 0);\n\n    if (firstImages.length === 0) {\n      setCalculatedRows([]);\n      setIsLayoutCalculating(false);\n      return; // No valid images to calculate layout for\n    }\n\n    // Define async function to call worker\n    const calculateGridLayout = async () => {\n      console.log('[ImageFeed] Requesting layout calculation...');\n      setIsLayoutCalculating(true);\n      activeRequestRef.current.layout = true;\n\n      try {\n        const result = await workerPool.postRequest<LayoutRequestPayload, RowConfig[]>(\n          'layout',\n          'calculateLayout',\n          {\n            images: firstImages,\n            containerWidth,\n            zoom,\n            targetRowHeight: layoutMetrics.estimatedRowHeightFallback,\n          },\n          { priority: 10 } // Highest priority\n        );\n        if (activeRequestRef.current.layout) {\n          console.log('[ImageFeed] Received layout result:', result.length, 'rows');\n          setCalculatedRows(result);\n        }\n      } catch (error) {\n        console.error('[ImageFeed] Layout worker request failed:', error);\n        setCalculatedRows([]); // Clear rows on error\n      } finally {\n        // Check if still active\n        if (activeRequestRef.current.layout) {\n          setIsLayoutCalculating(false);\n          activeRequestRef.current.layout = false;\n        }\n      }\n    };\n\n    calculateGridLayout();\n\n    // Cleanup handled by dependency change effect\n  }, [\n    processedGroupedImages,\n    containerWidth,\n    zoom,\n    viewMode,\n    layoutMetrics.estimatedRowHeightFallback,\n    workerPool,\n  ]);\n\n  // Define the useEffect that updates rowHeightsRef HERE, AFTER calculatedRows state\n  useEffect(() => {\n    if (viewMode === ViewMode.GRID && calculatedRows && calculatedRows.length > 0) {\n      rowHeightsRef.current = calculatedRows.map(row => row.height);\n    } else {\n      rowHeightsRef.current = [];\n    }\n  }, [calculatedRows, viewMode, folderPath]);\n\n  // Handle image overflow (wrapped in useCallback)\n  const handleImageOverflow = useCallback((image: ImageInfo) => {\n    console.warn('Image overflow detected:', image.id);\n  }, []);\n\n  // Update handleImageClick to work with grouped images and set lightbox plugins (wrapped in useCallback)\n  const handleImageClick = useCallback(\n    (clickedImage: ImageInfo) => {\n      const groupIndex = processedGroupedImages.findIndex(group =>\n        group.images.some(img => img.id === clickedImage.id)\n      );\n      if (groupIndex !== -1) {\n        const group = processedGroupedImages[groupIndex];\n        const imageIndexInGroup = group.images.findIndex(img => img.id === clickedImage.id);\n        if (imageIndexInGroup !== -1) {\n          setLightboxImages(group.images);\n          setLightboxIndex(imageIndexInGroup);\n        }\n      }\n    },\n    [processedGroupedImages]\n  );\n\n  // --- Scroll Velocity and Dynamic Overscan --- >\n  const lastScrollTopRef = useRef(0);\n  const lastScrollTimeRef = useRef(performance.now());\n\n  const handleScroll = useCallback(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (!scrollElement) return;\n\n    const now = performance.now();\n    const scrollTop = scrollElement.scrollTop;\n    const timeDelta = now - lastScrollTimeRef.current;\n    const scrollDelta = scrollTop - lastScrollTopRef.current;\n\n    if (timeDelta > 10) {\n      const velocity = Math.abs(scrollDelta) / timeDelta;\n      velocityEMARef.current = EMA_ALPHA * velocity + (1 - EMA_ALPHA) * velocityEMARef.current;\n      const calculatedOverscan =\n        OVERSCAN_BASE +\n        Math.min(velocityEMARef.current * OVERSCAN_FACTOR, OVERSCAN_MAX - OVERSCAN_BASE);\n      setDynamicOverscan(Math.round(calculatedOverscan));\n      lastScrollTopRef.current = scrollTop;\n      lastScrollTimeRef.current = now;\n      debouncedSaveScroll(folderPath, scrollTop);\n    }\n  }, [scrollContainerRef, folderPath, debouncedSaveScroll]);\n\n  // Attach scroll listener\n  useEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (scrollElement) {\n      // Use throttle for the scroll handler to limit frequency\n      const throttledScrollHandler = throttle(handleScroll, 100); // Throttle to ~10fps\n      scrollElement.addEventListener('scroll', throttledScrollHandler);\n      return () => scrollElement.removeEventListener('scroll', throttledScrollHandler);\n    }\n  }, [scrollContainerRef, handleScroll]);\n  // --- End Scroll Velocity Logic --- >\n\n  // --- Virtualization Setup ---\n  const rowVirtualizer = useVirtualizer({\n    count: calculatedRows.length,\n    getScrollElement: () => scrollContainerRef.current,\n    estimateSize: useCallback(\n      (index: number) => {\n        const rowHeight = calculatedRows[index]?.height ?? layoutMetrics.estimatedRowHeightFallback;\n        return rowHeight + layoutMetrics.gapSize;\n      },\n      [calculatedRows, layoutMetrics.estimatedRowHeightFallback, layoutMetrics.gapSize]\n    ),\n    overscan: dynamicOverscan,\n  });\n\n  // Remeasure rows whenever zoom, containerWidth, row count, row height fallback, gap size, view mode, or grouping changes\n  useLayoutEffect(() => {\n    rowVirtualizer.measure?.();\n  }, [\n    zoom,\n    containerWidth,\n    calculatedRows.length,\n    layoutMetrics.estimatedRowHeightFallback,\n    layoutMetrics.gapSize,\n    viewMode,\n    debouncedIsGrouped,\n    folderPath,\n    rowVirtualizer,\n  ]);\n\n  // Get the virtual items to render\n  const virtualItems = rowVirtualizer.getVirtualItems();\n\n  // --- End Virtualization Setup ---\n\n  // --- Add Scroll Restoration Effect ---\n  useLayoutEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    // Try to restore scroll only after layout is stable\n    if (isRestoringScrollRef.current && restoredState && rowHeightsRef.current.length > 0) {\n      if (scrollElement) {\n        console.log(`Restoring scroll to: ${restoredState.scrollTop}`);\n        // Wrap scroll restoration in requestAnimationFrame for smoothness\n        requestAnimationFrame(() => {\n          scrollElement.scrollTop = restoredState.scrollTop;\n          // Reset the flag *after* applying the scroll\n          isRestoringScrollRef.current = false;\n        });\n      } else {\n        isRestoringScrollRef.current = false; // Reset if element not found\n      }\n    }\n  }, [restoredState, scrollContainerRef, virtualItems, folderPath]); // Depend on restored state, ref, virtual items, and folderPath\n  // --- End Scroll Restoration Effect ---\n\n  // Callback function for image hover - with delay logic\n  const handleImageHover = useCallback(\n    (data: ImageHoverData) => {\n      // Clear any existing timeout\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n        hoverTimeoutRef.current = null;\n      }\n\n      if (data.isHovering) {\n        // Set a timeout to activate hover state after a delay\n        hoverTimeoutRef.current = setTimeout(() => {\n          // Get color from the state map if available\n          const color = dominantColorMap.get(data.imageId) || null;\n          setHoverState({ isHovering: true, position: data.position, color: color });\n        }, 150); // 150ms delay\n      } else {\n        // If mouse leaves, immediately deactivate hover state\n        setHoverState({ isHovering: false, position: null, color: null });\n      }\n    },\n    [setHoverState, dominantColorMap] // Dependency remains setHoverState\n  );\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    // Clear timeout if component unmounts\n    return () => {\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, []); // Empty dependency array ensures this runs only on mount and unmount\n\n  // --- Color Extraction Worker Integration (Add Priority for visible items) --- >\n  useEffect(() => {\n    // Only run if we have virtual items and rows calculated\n    if (virtualItems.length === 0 || calculatedRows.length === 0 || images.length === 0) {\n      return;\n    }\n\n    const visibleImageIds = new Set<string>();\n    virtualItems.forEach(virtualItem => {\n      const row = calculatedRows[virtualItem.index];\n      row?.images.forEach(img => visibleImageIds.add(img.id));\n    });\n\n    // Track promises for colors requested in this pass\n    const colorPromises: Promise<void>[] = [];\n\n    visibleImageIds.forEach(id => {\n      if (!dominantColorMap.has(id) && !requestedColorIds.current.has(id)) {\n        const imageInfo = images.find(img => img.id === id);\n        if (imageInfo?.src) {\n          const imageUrl = getImageUrl(imageInfo.src);\n          requestedColorIds.current.add(id);\n\n          const promise = workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              {\n                id: imageInfo.id,\n                src: imageUrl,\n              },\n              { priority: 1 }\n            )\n            .then(result => {\n              // Check result and specifically if color is a non-null string\n              if (result && typeof result.color === 'string') {\n                // Assign to a new variable to help TS with type narrowing inside the setter\n                const colorValue: string = result.color;\n                setDominantColorMap(prevMap => {\n                  const newMap = new Map(prevMap);\n                  // Use the explicitly typed colorValue\n                  newMap.set(result.id, colorValue);\n                  return newMap;\n                });\n              } else {\n                // console.log(`[ImageFeed] Color extraction failed or null for ${result?.id}`);\n              }\n            })\n            .catch(error => {\n              console.error(`[ImageFeed] Color worker request failed for image ID ${id}:`, error);\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(id);\n            });\n\n          colorPromises.push(promise);\n        }\n      }\n    });\n\n    // After processing all visible items in this pass, update the context\n    // Use Promise.allSettled to wait for all requests in this batch to finish\n    // before updating context, preventing rapid flickering.\n    if (colorPromises.length > 0) {\n      Promise.allSettled(colorPromises).then(() => {\n        // Re-calculate visible colors *after* potential map updates\n        const currentVisibleColors: string[] = [];\n        virtualItems.forEach(virtualItem => {\n          const row = calculatedRows[virtualItem.index];\n          row?.images.forEach(img => {\n            // Read from the potentially updated dominantColorMap state\n            const itemColor = dominantColorMap.get(img.id);\n            if (itemColor) {\n              currentVisibleColors.push(itemColor);\n            }\n          });\n        });\n        // Update context with the first 1 or 2 valid visible colors\n        if (currentVisibleColors.length > 0) {\n          // console.log('[ImageFeed] Updating context dominantColors after batch:', currentVisibleColors.slice(0, 2));\n          setDominantColors(currentVisibleColors.slice(0, 2));\n        } else {\n          // console.log('[ImageFeed] No dominant colors found after batch, resetting context.');\n          setDominantColors([]); // Reset if no colors found\n        }\n      });\n    } else {\n      // If no new colors were requested, still update context based on current visible colors\n      // This handles scrolling without new requests\n      const currentVisibleColors: string[] = [];\n      virtualItems.forEach(virtualItem => {\n        const row = calculatedRows[virtualItem.index];\n        row?.images.forEach(img => {\n          const itemColor = dominantColorMap.get(img.id);\n          if (itemColor) {\n            currentVisibleColors.push(itemColor);\n          }\n        });\n      });\n      if (currentVisibleColors.length > 0) {\n        // console.log('[ImageFeed] Updating context dominantColors (no new requests):', currentVisibleColors.slice(0, 2));\n        setDominantColors(currentVisibleColors.slice(0, 2));\n      } else {\n        // console.log('[ImageFeed] No dominant colors found (no new requests), resetting context.');\n        setDominantColors([]); // Reset if no colors found\n      }\n    }\n\n    // Cleanup: No specific listener removal needed here.\n    // Cancellation is handled by the main dependency change effect.\n  }, [\n    workerPool,\n    virtualItems, // Re-run when visible items change\n    calculatedRows, // Re-run if row layout changes\n    images, // Re-run if images change\n    getImageUrl,\n    dominantColorMap, // Re-run if the map updates (to potentially update context)\n    setDominantColors, // Context setter\n  ]);\n  // --- End Color Extraction Worker Integration ---\n\n  // --- Effect to set the publisher on the ImageProcessor --- >\n  useEffect(() => {\n    const processor = workerPool.getImageProcessor();\n    // Check if the processor has the setPublisher method (for safety)\n    if (processor && typeof (processor as any).setPublisher === 'function') {\n      (processor as any).setPublisher(publishImageUpdate);\n    } else {\n      console.warn('[ImageFeed] ImageProcessor instance not found or setPublisher method missing.');\n    }\n    // No cleanup needed for this specifically, publisher is set once\n    // Dependencies ensure it runs if publisher or processor instance changes\n  }, [workerPool, publishImageUpdate]);\n\n  // --- Render Logic --- >\n  const renderContent = () => {\n    const { gapSize } = layoutMetrics;\n    if (!containerWidth) return null;\n\n    const showLoadingState =\n      isLoadingImages || isGrouping || (viewMode === ViewMode.GRID && isLayoutCalculating);\n\n    // --- Render Dynamic Skeletons during Loading --- >\n    if (showLoadingState && viewMode === ViewMode.GRID) {\n      return (\n        <div\n          className={styles.gridContainer} // Use a container for skeleton layout\n          style={{\n            gap: `${gapSize}px`,\n            // Basic grid layout for skeletons based on current column count\n            // Note: This won't perfectly match the final layout worker result,\n            // but provides a reasonable placeholder structure.\n            display: 'grid',\n            gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,\n            padding: gapSize / 2, // Optional padding similar to final layout\n          }}\n        >\n          {(images ?? []).map(image => {\n            if (!image || image.width <= 0 || image.height <= 0) return null; // Skip invalid images\n            const color = dominantColorMap.get(image.id);\n            return (\n              <ImageSkeleton\n                key={`skeleton-${image.id}`}\n                containerWidth={image.width} // Use actual image dimensions\n                containerHeight={image.height}\n                placeholderColor={color} // Pass fetched color\n              />\n            );\n          })}\n        </div>\n      );\n    }\n\n    // Handle non-GRID view modes (pass raw images)\n    if (viewMode !== ViewMode.GRID) {\n      let ViewComponent;\n      switch (viewMode) {\n        case ViewMode.MASONRY:\n          ViewComponent = MasonryView;\n          break;\n        case ViewMode.BANNER:\n          ViewComponent = BannerView;\n          break;\n        case ViewMode.CAROUSEL:\n          ViewComponent = CarouselView;\n          break;\n        default:\n          return null;\n      }\n      // Ensure non-grid views also receive potentially filtered images\n      return <ViewComponent images={images} zoom={zoom} />;\n    }\n\n    // --- Render Final Virtualized GRID View --- >\n    // Only render if *not* in loading state and rows are calculated\n    if (!showLoadingState && calculatedRows.length > 0) {\n      return (\n        <div // Outer container: Sets the total scrollable height\n          style={{\n            height: `${rowVirtualizer.getTotalSize()}px`,\n            width: '100%',\n            position: 'relative',\n          }}\n        >\n          <div // Inner container: Absolutely positioned items are placed here\n            style={{\n              width: '100%',\n              position: 'relative',\n            }}\n          >\n            {virtualItems.map(virtualItem => {\n              const row = calculatedRows[virtualItem.index];\n              if (!row) return null;\n              return (\n                <motion.div // Wrapper with animation\n                  key={virtualItem.key}\n                  layout\n                  transition={{ type: 'spring', stiffness: 260, damping: 30 }}\n                  data-index={virtualItem.index}\n                  ref={rowVirtualizer.measureElement}\n                  style={{\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: virtualItem.size,\n                    y: virtualItem.start,\n                  }}\n                >\n                  <ImageRow\n                    // Pass necessary props down\n                    images={row.images}\n                    imageWidths={row.imageWidths ?? []}\n                    onImageClick={handleImageClick}\n                    columns={columns}\n                    zoom={zoom}\n                    isLastRow={virtualItem.index === calculatedRows.length - 1}\n                    rowHeight={row.height}\n                    // Pass processedGroupedImages down for context (e.g., carousel indicator)\n                    groupedImages={processedGroupedImages}\n                    workerPool={workerPool}\n                    gap={gapSize}\n                    containerWidth={containerWidth}\n                    onImageHover={handleImageHover}\n                    onImageLoadError={handleImageLoadError}\n                    // Pass the color map down to ImageRow/ImageItem if needed\n                    dominantColorMap={dominantColorMap}\n                  />\n                </motion.div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    // Fallback if still loading but not caught above, or rows aren't ready\n    // Can render a simpler spinner or nothing\n    return null; // Or a loading indicator\n  };\n\n  // Lightbox configuration\n  const lightboxPlugins = useMemo(() => [Captions, Counter, Thumbnails, Zoom], []);\n\n  // Prepare the lightbox slide objects\n  const slides = useMemo(() => {\n    if (!lightboxImages.length) return [];\n    return lightboxImages.map(image => ({\n      src: getImageUrl(image.src),\n      alt: image.alt,\n      title: image.title,\n      width: image.width,\n      height: image.height,\n    }));\n  }, [lightboxImages, getImageUrl]);\n\n  // --- Render Logic --- > Restored Error/Empty/Main return\n  if (isError) {\n    return (\n      <div ref={feedRef} className={`${styles.container} ${styles.error}`}>\n        Error loading images: {error?.message || 'Unknown error'}\n      </div>\n    );\n  }\n\n  const hasNoImages = !isLoadingImages && (!images || images.length === 0);\n  if (hasNoImages && !isGrouping && !isLayoutCalculating) {\n    return (\n      <div ref={feedRef} className={styles.container}>\n        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className={styles.noImages}>\n          No images found for this folder.\n        </motion.div>\n      </div>\n    );\n  }\n\n  // Main component return\n  return (\n    <div\n      ref={feedRef}\n      className={styles.container}\n      style={{\n        position: 'relative',\n      }}\n    >\n      <AuraBackground />\n      <div className={styles.feed}>{renderContent()}</div>\n\n      <Lightbox\n        open={lightboxIndex !== -1}\n        close={() => setLightboxIndex(-1)}\n        index={lightboxIndex}\n        slides={slides}\n        plugins={lightboxPlugins}\n      />\n    </div>\n  );\n}; // Correct closing brace for the component function\n\nexport default React.memo(ImageFeed);\n","import { useCallback, useEffect, useState } from 'react';\n\n// Define the structure for the window size object\ninterface WindowSize {\n  width: number | undefined;\n  height: number | undefined;\n}\n\n// Debounce timeout in milliseconds\nconst DEBOUNCE_TIMEOUT = 150;\n\n// Custom hook to track and return the current window size\nfunction useWindowSize() {\n  // State to store the current window size\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Memoized resize handler\n  const handleResize = useCallback(() => {\n    const newWidth = window.innerWidth;\n    const newHeight = window.innerHeight;\n\n    // Only update if dimensions actually changed\n    if (newWidth !== windowSize.width || newHeight !== windowSize.height) {\n      // Use RAF for smooth updates\n      requestAnimationFrame(() => {\n        setWindowSize({\n          width: newWidth,\n          height: newHeight,\n        });\n      });\n    }\n  }, [windowSize.width, windowSize.height]);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // Debounced resize handler\n    function debouncedResize() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(handleResize, DEBOUNCE_TIMEOUT);\n    }\n\n    // Initial size calculation\n    handleResize();\n\n    // Add event listener with debouncing\n    window.addEventListener('resize', debouncedResize);\n\n    // Cleanup\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      window.removeEventListener('resize', debouncedResize);\n    };\n  }, [handleResize]);\n\n  return windowSize;\n}\n\nexport default useWindowSize;\n","import throttle from 'lodash/throttle';\r\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { ImageInfo } from '../types';\r\nimport WorkerPool from '../workers/workerPool';\r\n\r\ninterface PrefetchManagerOptions {\r\n  scrollContainerRef: React.RefObject<HTMLElement>;\r\n  imageList: ImageInfo[];\r\n  layoutData: Map<string, { top: number; left: number; width: number; height: number }>; // Assuming layout data is available\r\n  lookaheadDistance?: number; // Pixels or items? Let's start with pixels\r\n  priorityThreshold?: number; // Minimum priority score to consider prefetching\r\n  concurrency?: number; // How many items to prefetch concurrently\r\n  throttleDelay?: number; // ms delay for scroll/resize events\r\n}\r\n\r\ninterface PrefetchCandidate extends ImageInfo {\r\n  priority: number;\r\n  layout: { top: number; left: number; width: number; height: number };\r\n}\r\n\r\nconst DEFAULT_LOOKAHEAD = 600; // Look ahead 600px beyond viewport\r\nconst DEFAULT_CONCURRENCY = 3; // Prefetch up to 3 items at once\r\nconst DEFAULT_THROTTLE_DELAY = 100; // Throttle event handling to 100ms\r\n\r\nexport function usePrefetchManager({\r\n  scrollContainerRef,\r\n  imageList,\r\n  layoutData,\r\n  lookaheadDistance = DEFAULT_LOOKAHEAD,\r\n  concurrency = DEFAULT_CONCURRENCY,\r\n  throttleDelay = DEFAULT_THROTTLE_DELAY,\r\n}: PrefetchManagerOptions) {\r\n  const workerPool = WorkerPool.getInstance();\r\n  const imageProcessor = workerPool.getImageProcessor();\r\n  const [viewport, setViewport] = useState({ top: 0, bottom: 0, height: 0 });\r\n  const processingRef = useRef<Set<string>>(new Set());\r\n\r\n  // Ref to store the latest version of the logic function for the throttled call\r\n  const runPrefetchLogicRef = useRef<() => Promise<void>>();\r\n\r\n  const updateViewport = useCallback(() => {\r\n    const container = scrollContainerRef.current;\r\n    if (!container) return;\r\n    const { scrollTop, clientHeight } = container;\r\n    const currentTop = scrollTop;\r\n    const currentBottom = scrollTop + clientHeight;\r\n    // Use functional update to potentially avoid depending on viewport in useCallback\r\n    setViewport(prev => ({ top: currentTop, bottom: currentBottom, height: clientHeight }));\r\n  }, [scrollContainerRef]);\r\n\r\n  const calculatePriority = useCallback(\r\n    (\r\n      image: ImageInfo,\r\n      imageLayout: { top: number; left: number; width: number; height: number }\r\n    ): number => {\r\n      const imageCenterY = imageLayout.top + imageLayout.height / 2;\r\n      // Read viewport directly from state here\r\n      const viewportCenterY = viewport.top + viewport.height / 2;\r\n      const distance = Math.abs(imageCenterY - viewportCenterY);\r\n      return distance;\r\n    },\r\n    [viewport] // Dependency on viewport state is correct here\r\n  );\r\n\r\n  // Define the core logic function - this will be updated in the ref\r\n  const runPrefetchLogicAsyncInternal = useCallback(async () => {\r\n    // Read viewport state *inside* the function instead of relying on useCallback capture\r\n    const currentViewport = viewport;\r\n    if (!scrollContainerRef.current || imageList.length === 0 || layoutData.size === 0) {\r\n      return;\r\n    }\r\n\r\n    const candidates: PrefetchCandidate[] = [];\r\n    const prefetchTop = Math.max(0, currentViewport.top - lookaheadDistance);\r\n    const prefetchBottom = currentViewport.bottom + lookaheadDistance;\r\n\r\n    for (const image of imageList) {\r\n      const imageLayout = layoutData.get(image.id);\r\n      if (!imageLayout) continue;\r\n      const imageTop = imageLayout.top;\r\n      const imageBottom = imageLayout.top + imageLayout.height;\r\n      if (imageBottom >= prefetchTop && imageTop <= prefetchBottom) {\r\n        // Use the calculatePriority function (which depends on current viewport state)\r\n        const priority = calculatePriority(image, imageLayout);\r\n        candidates.push({ ...image, priority, layout: imageLayout });\r\n      }\r\n    }\r\n\r\n    candidates.sort((a, b) => a.priority - b.priority);\r\n\r\n    let processedCount = 0;\r\n    for (const candidate of candidates) {\r\n      if (processedCount >= concurrency) break;\r\n      if (processingRef.current.has(candidate.id)) continue;\r\n\r\n      console.log(\r\n        `[PrefetchManager] Requesting process for ${candidate.id}, Priority: ${candidate.priority.toFixed(0)}`\r\n      );\r\n      processingRef.current.add(candidate.id);\r\n      processedCount++;\r\n\r\n      imageProcessor\r\n        .processImage(candidate)\r\n        .catch(err => {\r\n          console.error(`[PrefetchManager] Error processing ${candidate.id}:`, err);\r\n        })\r\n        .finally(() => {\r\n          processingRef.current.delete(candidate.id);\r\n        });\r\n    }\r\n  }, [\r\n    // Dependencies that define the logic: Stable references or core data\r\n    imageList,\r\n    layoutData,\r\n    lookaheadDistance,\r\n    concurrency,\r\n    imageProcessor, // Assumed stable instance from WorkerPool\r\n    calculatePriority, // This function still changes when viewport changes, but runPrefetchLogicAsyncInternal doesn't directly depend on viewport state anymore\r\n    scrollContainerRef,\r\n    // REMOVED viewport dependency\r\n  ]);\r\n\r\n  // Update the ref whenever the internal logic function changes\r\n  useEffect(() => {\r\n    runPrefetchLogicRef.current = runPrefetchLogicAsyncInternal;\r\n  }, [runPrefetchLogicAsyncInternal]);\r\n\r\n  // Create the throttled function once, calling the function from the ref\r\n  const throttledRunPrefetch = useMemo(\r\n    () =>\r\n      throttle(() => {\r\n        // Added check: only run if the ref is current and component is mounted\r\n        if (runPrefetchLogicRef.current) {\r\n          runPrefetchLogicRef.current();\r\n        }\r\n      }, throttleDelay),\r\n    [throttleDelay]\r\n  );\r\n\r\n  // --- Effects ---\r\n\r\n  // Effect 1: Setup listeners and initial viewport\r\n  useEffect(() => {\r\n    // Initial viewport update on mount\r\n    updateViewport();\r\n\r\n    const container = scrollContainerRef.current;\r\n    if (container) {\r\n      // Attach the stable throttled listener\r\n      container.addEventListener('scroll', throttledRunPrefetch, { passive: true });\r\n      // Optional: Add resize listener if needed\r\n      // const handleResize = () => { updateViewport(); throttledRunPrefetch(); };\r\n      // window.addEventListener('resize', handleResize);\r\n    }\r\n\r\n    return () => {\r\n      throttledRunPrefetch.cancel();\r\n      if (container) {\r\n        container.removeEventListener('scroll', throttledRunPrefetch);\r\n        // window.removeEventListener('resize', handleResize);\r\n      }\r\n    };\r\n    // Dependencies: only need things required for setup/cleanup\r\n  }, [scrollContainerRef, updateViewport, throttledRunPrefetch]);\r\n\r\n  // Effect 2: Run prefetch logic when core data changes (images, layout)\r\n  useEffect(() => {\r\n    // Only run if we have images and layout data\r\n    // This prevents running unnecessarily when transitioning to empty state\r\n    if (imageList.length > 0 && layoutData.size > 0) {\r\n      console.log('[PrefetchManager] Running logic due to imageList/layoutData change.');\r\n      // Directly call the latest logic function from the ref\r\n      runPrefetchLogicRef.current?.();\r\n    }\r\n    // This effect should ONLY run when the core data list/layout changes.\r\n    // It intentionally does *not* depend on viewport or functions derived from it.\r\n  }, [imageList, layoutData]); // Removed runPrefetchLogicAsyncInternal dependency\r\n\r\n  // No return value needed, the hook manages prefetching internally\r\n}\r\n","import React, { RefObject } from 'react';\nimport styles from '../styles/ImageViewer.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport ImageFeed from './ImageFeed.js';\n\n// Define the props interface for the ImageViewer component\ninterface ImageViewerProps {\n  selectedFolder: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: RefObject<HTMLElement>;\n}\n\n// Define the ImageViewer component\nconst ImageViewer: React.FC<ImageViewerProps> = ({\n  selectedFolder,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  return (\n    // Main container with flex layout\n    <div className={`${styles.imageViewer} flex flex-col h-full bg-transparent`}>\n      {/* Content container with scrolling */}\n      <div className={`${styles.contentContainer} flex-1`}>\n        {/* Render ImageFeed directly, passing the folderPath and ref */}\n        {/* ImageFeed now handles its own loading, error, and empty states */}\n        <ImageFeed\n          folderPath={selectedFolder}\n          isGrouped={isGrouped}\n          zoom={zoom}\n          viewMode={viewMode}\n          scrollContainerRef={scrollContainerRef}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Export the ImageViewer component\nexport default ImageViewer;\n","import React from 'react';\r\nimport { ViewMode } from '../types/index.js';\r\nimport ImageViewer from './ImageViewer.js';\r\n\r\n// Define the props interface for the MainContent component\r\ninterface MainContentProps {\r\n  // images: ImageInfo[]; // Removed\r\n  selectedFolder: string;\r\n  searchQuery: string; // Kept for now, but its usage needs re-evaluation\r\n  // isLoading: boolean; // Removed\r\n  // error: string | null; // Removed\r\n  zoom: number;\r\n  isGrouped: boolean;\r\n  viewMode: ViewMode;\r\n  scrollContainerRef: React.RefObject<HTMLElement>;\r\n}\r\n\r\n// MainContent component that renders the primary content area of the application\r\nconst MainContent: React.FC<MainContentProps> = ({\r\n  // images, // Removed\r\n  selectedFolder,\r\n  searchQuery, // Kept for now\r\n  // isLoading, // Removed\r\n  // error, // Removed\r\n  zoom,\r\n  isGrouped,\r\n  viewMode,\r\n  scrollContainerRef,\r\n}) => {\r\n  // Removed the filtering logic for now. Search needs to be handled differently.\r\n  // const filteredImages = useMemo(() => {\r\n  //   if (!searchQuery) return images;\r\n  //   return images.filter(image => image.alt.toLowerCase().includes(searchQuery.toLowerCase()));\r\n  // }, [images, searchQuery]);\r\n\r\n  // Render the main content\r\n  return (\r\n    <>\r\n      {/* Render the ImageViewer component */}\r\n      <ImageViewer\r\n        // images={filteredImages} // Removed\r\n        // isLoading={isLoading} // Removed\r\n        // error={error} // Removed\r\n        selectedFolder={selectedFolder}\r\n        zoom={zoom}\r\n        isGrouped={isGrouped}\r\n        viewMode={viewMode}\r\n        scrollContainerRef={scrollContainerRef}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\n// Export the MainContent component\r\nexport default MainContent;\r\n","import { IconFolder } from '@tabler/icons-react';\r\nimport { motion } from 'framer-motion';\r\nimport React from 'react';\r\nimport { useCurrentDirectory } from '../hooks/query/useCurrentDirectory';\r\n\r\n/** Props for the CurrentDirectoryButton component. */\r\ninterface CurrentDirectoryButtonProps {\r\n  // currentDirectory: string; // Removed\r\n}\r\n\r\n/** CurrentDirectoryButton component that displays the current directory.*/\r\nconst CurrentDirectoryButton: React.FC<CurrentDirectoryButtonProps> = () => {\r\n  // Fetch the current directory using the hook\r\n  const { data: currentDirectory, isLoading, isError } = useCurrentDirectory();\r\n\r\n  // Determine button content based on loading/error state\r\n  let buttonContent = '...'; // Loading state\r\n  let buttonClass = 'bg-gray-600 text-gray-400 cursor-not-allowed';\r\n  let iconColor = 'text-gray-500';\r\n\r\n  if (isError) {\r\n    buttonContent = 'Error';\r\n    buttonClass = 'bg-red-800 text-red-200 cursor-not-allowed';\r\n    iconColor = 'text-red-400';\r\n  } else if (!isLoading && currentDirectory) {\r\n    buttonContent = currentDirectory;\r\n    buttonClass = 'bg-gray-700 text-peach hover:bg-gray-600'; // Original classes\r\n    iconColor = 'text-yellow-500'; // Original color\r\n  }\r\n\r\n  return (\r\n    <motion.button\r\n      className={`flex items-center px-3 py-1 rounded-md text-sm transition-all duration-300 ease-in-out ${buttonClass}`}\r\n      whileHover={!isLoading && !isError ? { scale: 1.05 } : {}}\r\n      whileTap={!isLoading && !isError ? { scale: 0.95 } : {}}\r\n      disabled={isLoading || isError}\r\n    >\r\n      {/* Folder icon */}\r\n      <IconFolder size={16} className={`mr-2 ${iconColor}`} />\r\n\r\n      {/* Current directory path or status */}\r\n      <motion.div\r\n        className=\"truncate max-w-xs\"\r\n        initial={{ opacity: 0 }}\r\n        animate={{ opacity: 1 }}\r\n        transition={{ duration: 0.3 }}\r\n      >\r\n        <span>{buttonContent}</span>\r\n      </motion.div>\r\n    </motion.button>\r\n  );\r\n};\r\n\r\nexport default CurrentDirectoryButton;\r\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentDirectory } from '../../lib/api';\r\n\r\n/**\r\n * Custom hook to fetch the current base directory from the server.\r\n *\r\n * @returns The result object from useQuery, containing the directory path string, loading state, error state, etc.\r\n */\r\nexport function useCurrentDirectory() {\r\n  return useQuery<string, Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    queryKey: ['currentDirectory'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getCurrentDirectory,\r\n    // Optional: Consider a longer staleTime as this might not change often\r\n    staleTime: 1000 * 60 * 30, // e.g., stays fresh for 30 minutes\r\n    refetchOnWindowFocus: false, // Likely doesn't need to refetch on focus\r\n  });\r\n}\r\n","import { motion, useAnimation } from 'framer-motion';\nimport { useState } from 'react';\nimport styles from '../styles/SearchBar.module.scss';\n\n// Define the props interface for the SearchBar component\ninterface SearchBarProps {\n  onSearch: (query: string) => void;\n}\n\n// Define the SearchBar component\nconst SearchBar: React.FC<SearchBarProps> = ({ onSearch }) => {\n  // State to manage the search query\n  const [query, setQuery] = useState('');\n  const controls = useAnimation();\n\n  // Handler for form submission\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSearch(query);\n  };\n\n  // Render the SearchBar component\n  return (\n    <motion.form\n      onSubmit={handleSubmit}\n      className={styles.searchBarContainer}\n      initial={{ width: '200px' }}\n      animate={{ width: query ? '300px' : '200px' }}\n      transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n    >\n      <motion.div\n        className={styles.searchBackground}\n        animate={{\n          background: query\n            ? 'linear-gradient(90deg, #4a00e0 0%, #8e2de2 100%)'\n            : 'rgba(255, 255, 255, 0.1)',\n        }}\n      />\n      <motion.input\n        type=\"text\"\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        className={styles.searchInput}\n        placeholder=\"Search the future...\"\n        whileFocus={{ scale: 1.05 }}\n        transition={{ type: 'spring', stiffness: 400, damping: 30 }}\n      />\n    </motion.form>\n  );\n};\n\n// Export the SearchBar component\nexport default SearchBar;\n","import { motion, useAnimation } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\n\n// Define the props interface for the ZoomSlider component\ninterface ZoomSliderProps {\n  zoom: number;\n  onZoomChange: (zoom: number) => void;\n}\n\n// ZoomSlider component for adjusting image zoom level\nconst ZoomSlider: React.FC<ZoomSliderProps> = ({ zoom, onZoomChange }) => {\n  const [isDragging, setIsDragging] = useState(false);\n  const controls = useAnimation();\n\n  // compute animated values manually for Framer Motion\n  const sliderWidth = `${((zoom - 0.5) / 1.5) * 100}%`;\n  const glowOpacity = isDragging ? 1 : 0.6;\n  const glowScale = isDragging ? 1.1 : 1;\n\n  useEffect(() => {\n    controls.start({\n      scale: isDragging ? 1.05 : 1,\n      transition: {\n        type: 'spring',\n        stiffness: 300,\n        damping: 20,\n      },\n    });\n  }, [isDragging, controls]);\n\n  return (\n    <motion.div\n      className=\"relative flex items-center bg-gray-800/80 backdrop-blur-md rounded-full p-3 overflow-hidden\"\n      style={{\n        boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n        width: '200px',\n      }}\n      animate={controls}\n    >\n      {/* Zoom out icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.max(0.5, zoom - 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 mr-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: -90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M11 8V14M8 11H14M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n\n      {/* Slider track */}\n      <div className=\"relative flex-1 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <motion.div\n          className=\"absolute top-0 left-0 h-full bg-blue-500 rounded-full\"\n          style={{ boxShadow: '0 0 10px rgba(59,130,246,0.5)' }}\n          animate={{ width: sliderWidth }}\n          transition={{ type: 'spring', stiffness: 300, damping: 10, precision: 0.01 }}\n        />\n        <input\n          type=\"range\"\n          min=\"0.5\"\n          max=\"2\"\n          step=\"0.1\"\n          value={zoom}\n          onChange={e => onZoomChange(parseFloat(e.target.value))}\n          onMouseDown={() => setIsDragging(true)}\n          onMouseUp={() => setIsDragging(false)}\n          onTouchStart={() => setIsDragging(true)}\n          onTouchEnd={() => setIsDragging(false)}\n          className=\"absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer\"\n        />\n      </div>\n\n      {/* Zoom in icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.min(2, zoom + 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 ml-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: 90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n    </motion.div>\n  );\n};\n\n// Export the ZoomSlider component\nexport default ZoomSlider;\n","import { motion } from 'framer-motion';\nimport React, { useEffect, useRef } from 'react';\nimport styles from '../styles/Navbar.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport CurrentDirectoryButton from './CurrentDirectoryButton';\nimport SearchBar from './SearchBar';\nimport ZoomSlider from './ZoomSlider';\n\n// Update the props interface for the Navbar component\ninterface NavbarProps {\n  // currentDirectory: string; // Removed: Fetched by CurrentDirectoryButton\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n}\n\n// Define the Navbar component\nconst Navbar: React.FC<NavbarProps> = ({\n  // currentDirectory, // Removed\n  onSearch,\n  zoom,\n  onZoomChange,\n  isGrouped,\n  onGroupToggle,\n  viewMode,\n  onViewModeChange,\n}) => {\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  useEffect(() => {\n    const svg = svgRef.current;\n    if (svg) {\n      const animate = () => {\n        const path = svg.querySelector('path');\n        if (path) {\n          const length = path.getTotalLength();\n          path.style.strokeDasharray = `${length} ${length}`;\n          path.style.strokeDashoffset = `${length}`;\n          path.getBoundingClientRect();\n          path.style.transition = 'stroke-dashoffset 2s ease-in-out';\n          path.style.strokeDashoffset = '0';\n        }\n      };\n      animate();\n    }\n  }, []);\n\n  // Render the Navbar component\n  return (\n    <motion.div\n      className={styles.navbar}\n      initial={{ opacity: 0, y: -50 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.5 }}\n    >\n      <svg ref={svgRef} className={styles.navbarBackground}>\n        <path d=\"M0,0 Q50,20 100,10 T200,30 T300,5 T400,25 V100 Q350,80 300,90 T200,70 T100,95 T0,75 Z\" />\n      </svg>\n      {/* Left section of the navbar */}\n      <div className={styles.leftSection}>\n        {/* Display the current directory */}\n        <CurrentDirectoryButton /> {/* No prop needed */}\n        {/* Search functionality */}\n        <SearchBar onSearch={onSearch} />\n      </div>\n      {/* Right section of the navbar */}\n      <div className={styles.rightSection}>\n        {/* View mode toggle buttons */}\n        <div className={styles.viewModeButtons}>\n          {Object.values(ViewMode).map(mode => (\n            <motion.button\n              key={mode}\n              onClick={() => onViewModeChange(mode)}\n              className={`${styles.viewModeButton} ${viewMode === mode ? styles.active : ''}`}\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n            >\n              {mode.charAt(0).toUpperCase() + mode.slice(1)}\n            </motion.button>\n          ))}\n        </div>\n        <motion.button\n          onClick={onGroupToggle}\n          className={styles.viewToggleButton}\n          whileHover={{ scale: 1.05 }}\n          whileTap={{ scale: 0.95 }}\n        >\n          {isGrouped ? 'Ungroup' : 'Group'}\n        </motion.button>\n        {/* Zoom control slider */}\n        <ZoomSlider zoom={zoom} onZoomChange={onZoomChange} />\n      </div>\n    </motion.div>\n  );\n};\n\n// Export the Navbar component\nexport default Navbar;\n","const HOME_DIRECTORY_KEY = 'loraFinderHomeDirectory';\r\n\r\n/**\r\n * Retrieves the stored home directory path from localStorage.\r\n * @returns The stored path string, or null if not set.\r\n */\r\nexport const getHomeDirectory = (): string | null => {\r\n  try {\r\n    return localStorage.getItem(HOME_DIRECTORY_KEY);\r\n  } catch (error) {\r\n    console.error('Error reading home directory from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores the given directory path as the home directory in localStorage.\r\n * @param folderPath - The path to store.\r\n */\r\nexport const setHomeDirectory = (folderPath: string): void => {\r\n  try {\r\n    localStorage.setItem(HOME_DIRECTORY_KEY, folderPath);\r\n  } catch (error) {\r\n    console.error('Error setting home directory in localStorage:', error);\r\n  }\r\n};\r\n","import { motion } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\nimport { FaHome } from 'react-icons/fa';\nimport { useFolders } from '../hooks/query/useFolders';\nimport styles from '../styles/Sidebar.module.scss';\nimport { getHomeDirectory, setHomeDirectory } from '../utils/settings';\n\n// Define the props interface for the Sidebar component\ninterface SidebarProps {\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n}\n\n// Define the Sidebar component\nconst Sidebar: React.FC<SidebarProps> = ({ selectedFolder, onFolderChange }) => {\n  // Call the hook to fetch folders\n  const { data: folders, isLoading, isError, error } = useFolders();\n  // State to track the current home directory for styling\n  const [currentHomeDir, setCurrentHomeDir] = useState<string | null>(null);\n\n  // Effect to load the home directory on mount\n  useEffect(() => {\n    setCurrentHomeDir(getHomeDirectory());\n  }, []);\n\n  // Handler to set a new home directory\n  const handleSetHome = (folderPath: string, event: React.MouseEvent) => {\n    event.stopPropagation(); // Prevent folder selection when clicking set home\n    setHomeDirectory(folderPath);\n    setCurrentHomeDir(folderPath);\n    console.log('Set home directory:', folderPath);\n  };\n\n  // Render loading state\n  if (isLoading) {\n    return (\n      <motion.div\n        initial={{ x: -300 }}\n        animate={{ x: 0 }}\n        transition={{ type: 'spring', stiffness: 120 }}\n        className={`${styles.sidebar} ${styles.loading}`}\n      >\n        Loading folders...\n      </motion.div>\n    );\n  }\n\n  // Render error state\n  if (isError) {\n    return (\n      <motion.div\n        initial={{ x: -300 }}\n        animate={{ x: 0 }}\n        transition={{ type: 'spring', stiffness: 120 }}\n        className={`${styles.sidebar} ${styles.error}`}\n      >\n        Error: {error?.message || 'Failed to load folders'}\n      </motion.div>\n    );\n  }\n\n  // Render the main sidebar\n  return (\n    // Main sidebar container\n    <motion.div\n      initial={{ x: -300 }}\n      animate={{ x: 0 }}\n      transition={{ type: 'spring', stiffness: 120 }}\n      className={styles.sidebar}\n    >\n      <div className={`${styles.sidebar} flex flex-col h-full`}>\n        {/* Logo section */}\n        <div className={styles.logo}>Lora Finder</div>\n        {/* Folder list */}\n        <ul className={`${styles.folderList} flex-grow overflow-y-auto`}>\n          {/* Map through folders (from hook) and create buttons for each */}\n          {(folders ?? []).map(folder => (\n            <li key={folder.name} className={`${styles.folderItem} group`}>\n              <button\n                onClick={() => {\n                  onFolderChange(folder.name);\n                }}\n                className={`${styles.folderButton} ${\n                  selectedFolder === folder.name ? styles.selectedFolder : ''\n                }`}\n              >\n                <span className={styles.folderName}>{folder.name}</span>\n                <button\n                  onClick={e => handleSetHome(folder.name, e)}\n                  className={`${styles.setHomeButton} ${folder.name === currentHomeDir ? styles.isHome : 'opacity-0 group-hover:opacity-100'}`}\n                  title={`Set ${folder.name} as home directory`}\n                >\n                  <FaHome />\n                </button>\n              </button>\n            </li>\n          ))}\n        </ul>\n        {/* Upload button */}\n        <div className=\"p-8 mt-auto\">\n          <button className={`${styles.uploadButton} w-full`}>Upload</button>\n        </div>\n      </div>\n    </motion.div>\n  );\n};\n\n// Export the Sidebar component\nexport default Sidebar;\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getFolders } from '../../lib/api';\r\nimport { FolderInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch the list of available folders using React Query.\r\n *\r\n * @returns The result object from useQuery, containing folder data, loading state, error state, etc.\r\n */\r\nexport function useFolders() {\r\n  return useQuery<FolderInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Stays constant as we expect the same folder list unless invalidated.\r\n    queryKey: ['folders'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getFolders,\r\n    // Optional: Configure staleTime and gcTime if different from defaults\r\n    // staleTime: 1000 * 60 * 10, // e.g., folders stay fresh for 10 mins\r\n  });\r\n}\r\n","// Cache Time-To-Live: Duration in milliseconds for which cached data remains valid\nexport const CACHE_TTL = 600000;\n\n// Maximum upload size: Limit for file uploads in bytes (default is ~1.5GB)\nexport const MAX_UPLOAD_SIZE = 1610612736;\n\n// Supported image formats: List of file extensions for allowed image uploads\nexport const SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif'];\n\n// API base URL: Root URL for API endpoints\nexport const API_BASE_URL = 'http://localhost:3000/api';\n\n// Server port: Port number on which the server will listen\nexport const PORT = 3000;\n\n// Host: Hostname or IP address on which the server will run\nexport const HOST = 'localhost';\n\n// Custom properties for dynamic styling\nexport const CUSTOM_PROPERTIES = {\n  SCROLL_Y: '--scroll-y',\n  MOUSE_X: '--mouse-x',\n  MOUSE_Y: '--mouse-y',\n};\n\n// Default values for custom properties\nexport const DEFAULT_CUSTOM_PROPERTY_VALUES = {\n  [CUSTOM_PROPERTIES.SCROLL_Y]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_X]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_Y]: '0px',\n};\n","import React, { useState } from 'react';\nimport { ViewMode } from '../types/index.js';\nimport MainContent from './MainContent.js';\nimport Navbar from './Navbar.js';\nimport Sidebar from './Sidebar.js';\n// import { getImages } from '../lib/api.js'; // Removed: Data fetching moved to hooks/ImageFeed\nimport gsap from 'gsap';\nimport { ScrollToPlugin } from 'gsap/ScrollToPlugin';\nimport { ColorProvider } from '../contexts/ColorContext';\nimport { useCustomProperties } from '../hooks/useCustomProperties';\n// Import the new AuraBackground\nimport AuraBackground from './AuraBackground.js';\n// Remove ParticleBackground import\n// import ParticleBackground from './ParticleBackground.js';\n\ngsap.registerPlugin(ScrollToPlugin);\n\n// Define the props interface for the Layout component\ninterface LayoutProps {\n  children: React.ReactNode;\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n  mainRef: React.RefObject<HTMLElement>;\n}\n\n// Define the Layout component\nconst Layout: React.FC<LayoutProps> = ({\n  children,\n  selectedFolder,\n  onFolderChange,\n  onSearch,\n  zoom,\n  onZoomChange,\n  isGrouped,\n  onGroupToggle,\n  viewMode,\n  onViewModeChange,\n  mainRef,\n}) => {\n  useCustomProperties();\n\n  // State variables for managing images, loading state, error, and search query\n  // const [images, setImages] = useState<ImageInfo[]>([]); // Removed: Managed by react-query in ImageFeed\n  // const [isLoading, setIsLoading] = useState(false); // Removed\n  // const [error, setError] = useState<string | null>(null); // Removed\n  const [searchQuery, setSearchQuery] = useState(''); // Kept for now, search logic needs update\n\n  // Effect hook to fetch images when the selected folder changes\n  // useEffect(() => {\n  //   const fetchImages = async () => {\n  //     setIsLoading(true);\n  //     setError(null);\n  //     try {\n  //       const fetchedImages = await getImages(selectedFolder);\n  //       setImages(fetchedImages || []); // Ensure we always set an array\n  //     } catch (err: any) {\n  //       const errorMessage = err.message || 'Failed to fetch images';\n  //       setError(errorMessage);\n  //       setImages([]); // Set empty array on error\n  //       console.error('Error fetching images:', err);\n  //     } finally {\n  //       setIsLoading(false);\n  //     }\n  //   };\n\n  //   if (selectedFolder) {\n  //     fetchImages();\n  //   } else {\n  //     setImages([]);\n  //     setError('No folder selected');\n  //   }\n  // }, [selectedFolder]); // Removed: Data fetching moved to hooks/ImageFeed\n\n  // Handler for search functionality\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    onSearch(query); // Propagate search up if needed\n  };\n\n  // Handler for when image upload is complete\n  // const handleUploadComplete = () => {\n  //   // Refetch images after upload\n  //   // This logic needs to be replaced with query invalidation\n  //   // e.g., using queryClient.invalidateQueries(['images', selectedFolder]);\n  //   const fetchImages = async () => {\n  //     setIsLoading(true);\n  //     setError(null);\n  //     try {\n  //       const fetchedImages = await getImages(selectedFolder);\n  //       setImages(fetchedImages);\n  //     } catch (err) {\n  //       setError('Failed to fetch images');\n  //       console.error(err);\n  //     } finally {\n  //       setIsLoading(false);\n  //     }\n  //   };\n\n  //   fetchImages();\n  // }; // Removed: Needs replacement with react-query invalidation\n\n  // Render the layout structure\n  return (\n    <div className=\"flex flex-col h-screen relative bg-transparent\">\n      <ColorProvider>\n        <div className=\"gradient-overlay\"></div>\n        {/* Use AuraBackground instead of ParticleBackground */}\n        <AuraBackground />\n        {/* <ParticleBackground /> */}\n        <Navbar\n          onSearch={handleSearch}\n          zoom={zoom}\n          onZoomChange={onZoomChange}\n          isGrouped={isGrouped}\n          onGroupToggle={onGroupToggle}\n          viewMode={viewMode}\n          onViewModeChange={onViewModeChange}\n        />\n        <div className=\"flex flex-1 overflow-hidden\">\n          <Sidebar selectedFolder={selectedFolder} onFolderChange={onFolderChange} />\n          <main ref={mainRef} className=\"flex-1 overflow-auto p-4 relative bg-transparent\">\n            <div className=\"relative z-10\">\n              <MainContent\n                // images={images} // Removed\n                selectedFolder={selectedFolder}\n                searchQuery={searchQuery}\n                // isLoading={isLoading} // Removed\n                // error={error} // Removed\n                zoom={zoom}\n                isGrouped={isGrouped}\n                viewMode={viewMode}\n                scrollContainerRef={mainRef}\n              />\n            </div>\n          </main>\n        </div>\n      </ColorProvider>\n    </div>\n  );\n};\n\nexport default Layout;\n","import { useEffect } from 'react';\nimport { CUSTOM_PROPERTIES, DEFAULT_CUSTOM_PROPERTY_VALUES } from '../utils/constants';\n\nexport function useCustomProperties() {\n  useEffect(() => {\n    function updateCustomProperties(e: MouseEvent) {\n      const mouseX = e.clientX;\n      const mouseY = e.clientY;\n\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_X, `${mouseX}px`);\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_Y, `${mouseY}px`);\n    }\n\n    function updateScrollProperty() {\n      const scrollY = window.scrollY;\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.SCROLL_Y, `${scrollY}px`);\n    }\n\n    // Set default values\n    Object.entries(DEFAULT_CUSTOM_PROPERTY_VALUES).forEach(([property, value]) => {\n      document.documentElement.style.setProperty(property, value);\n    });\n\n    window.addEventListener('scroll', updateScrollProperty);\n    document.addEventListener('mousemove', updateCustomProperties);\n    document.addEventListener('click', updateCustomProperties);\n\n    return () => {\n      window.removeEventListener('scroll', updateScrollProperty);\n      document.removeEventListener('mousemove', updateCustomProperties);\n      document.removeEventListener('click', updateCustomProperties);\n    };\n  }, []);\n}\n","import React, { useRef, useState } from 'react';\nimport Layout from '../components/Layout.js';\nimport MainContent from '../components/MainContent.js';\n// import { getFolders, getImages } from '../lib/api.js'; // getFolders no longer needed here\nimport { ViewMode } from '../types/index.js';\n// Import the settings utilities\nimport { getHomeDirectory } from '../utils/settings.js';\n\n/**\n * Home component - the main page of the application.\n * It manages the overall state and layout of the app.\n *\n * @component\n * @returns {JSX.Element} The main application page.\n */\nconst Home: React.FC = () => {\n  // State declarations for managing application data and UI\n  // const [folders, setFolders] = useState<FolderInfo[]>([]); // Removed: Managed by useFolders in Sidebar\n  const [selectedFolder, setSelectedFolder] = useState<string>(() => {\n    return getHomeDirectory() || '';\n  });\n  // const [images, setImages] = useState<ImageInfo[]>([]); // Removed\n  const [zoom, setZoom] = useState<number>(1);\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  // const [currentDirectory, setCurrentDirectory] = useState<string>(''); // Removed: Managed by useCurrentDirectory\n  // const [isLoading, setIsLoading] = useState<boolean>(false); // Removed\n  // const [error, setError] = useState<string | null>(null); // Removed\n  const [isGrouped, setIsGrouped] = useState<boolean>(true);\n  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.GRID);\n\n  // Create ref for the main scrollable element\n  const mainScrollRef = useRef<HTMLElement>(null);\n\n  /**\n   * Effect hook to fetch the list of folders when the component mounts.\n   * Sets the first folder as selected if available.\n   * Removed: This is now handled by Sidebar component via useFolders hook.\n   */\n  // useEffect(() => {\n  //   const fetchFolders = async () => {\n  //     try {\n  //       const folderList = await getFolders();\n  //       setFolders(folderList);\n  //       if (folderList.length > 0 && !selectedFolder) { // Only set initial folder if none selected\n  //         setSelectedFolder(folderList[0].name);\n  //       }\n  //     } catch (error) {\n  //       console.error('Error fetching folders:', error);\n  //       // setError('Failed to fetch folders'); // setError removed\n  //     }\n  //   };\n\n  //   fetchFolders();\n  // }, [selectedFolder]);\n\n  /**\n   * Effect hook to fetch images when the selected folder changes.\n   * Updates loading state and handles errors.\n   * Removed: This is now handled by ImageFeed component via useFolderImages hook.\n   */\n  // ... (Removed image fetching useEffect)\n\n  /**\n   * Handler for folder selection change.\n   * Updates the selected folder state.\n   * @param {string} folder - The newly selected folder.\n   */\n  const handleFolderChange = (folder: string) => {\n    setSelectedFolder(folder);\n    // No need to fetch images here manually anymore\n  };\n\n  /**\n   * Handler for zoom level change.\n   * Updates the zoom state.\n   * @param {number} newZoom - The new zoom level.\n   */\n  const handleZoomChange = (newZoom: number) => {\n    setZoom(newZoom);\n  };\n\n  /**\n   * Handler for search query change.\n   * Updates the search query state.\n   * @param {string} query - The new search query.\n   */\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    // Search result display needs to be handled\n  };\n\n  /**\n   * Handler for file upload completion.\n   * Refreshes the images in the current folder.\n   * TODO: Replace with query invalidation using queryClient\n   */\n  const handleUploadComplete = () => {\n    // Example: queryClient.invalidateQueries(['images', selectedFolder]);\n    console.log('TODO: Invalidate query for folder:', selectedFolder);\n  };\n\n  /**\n   * Handler for grouping toggle.\n   * Toggles the grouping state.\n   */\n  const handleGroupToggle = () => {\n    setIsGrouped(prevState => !prevState);\n  };\n\n  const handleViewModeChange = (newMode: ViewMode) => {\n    setViewMode(newMode);\n  };\n\n  // Render the main layout with all necessary props\n  // Note: 'folders' & 'currentDirectory' props are removed from Layout\n  return (\n    <Layout\n      // folders={folders} // Removed\n      selectedFolder={selectedFolder}\n      onFolderChange={handleFolderChange}\n      // currentDirectory={selectedFolder} // Removed\n      onSearch={handleSearch}\n      zoom={zoom}\n      onZoomChange={handleZoomChange}\n      isGrouped={isGrouped}\n      onGroupToggle={handleGroupToggle}\n      viewMode={viewMode}\n      onViewModeChange={handleViewModeChange}\n      mainRef={mainScrollRef}\n    >\n      {/* Pass relevant state down to MainContent */}\n      {/* MainContent no longer needs images, isLoading, error */}\n      <MainContent\n        // images={images} // Removed\n        zoom={zoom}\n        searchQuery={searchQuery}\n        // isLoading={isLoading} // Removed\n        // error={error} // Removed\n        selectedFolder={selectedFolder}\n        isGrouped={isGrouped}\n        viewMode={viewMode}\n        scrollContainerRef={mainScrollRef}\n      />\n    </Layout>\n  );\n};\n\nexport default Home;\n","import Home from './pages/Home.js';\nimport './styles/views.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Home />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App.js';\n\nexport function render() {\n  const html = ReactDOMServer.renderToString(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n  return { html };\n}\n"],"names":["initialDefaultColor","initialHoverState","isHovering","position","color","ColorContext","createContext","dominantColors","setDominantColors","hoverState","setHoverState","ColorProvider","children","setDominantColorsState","useState","setHoverStateInternal","useCallback","newState","prevState","contextValue","useMemo","Provider","value","ImageProcessingContext","useImageProcessing","context","useContext","Error","api","axios","create","baseURL","async","getFolders","get","data","map","folder","name","path","error","console","getCurrentDirectory","currentDirectory","useFolderImages","useQuery","queryKey","queryFn","response","encodeURIComponent","Array","isArray","message","_a","statusText","request","getImages","enabled","placeholderData","previousData","STORE_NAME","dbPromise","getDb","dbPromise$1","openDB","upgrade","db","objectStoreNames","contains","createObjectStore","keyPath","ImageProcessor","constructor","options","__publicField","this","Map","onError","concurrency","Math","max","navigator","hardwareConcurrency","queue","PQueue","log","worker","Worker","URL","url","type","proxy","wrap","onerror","call","initializeCacheCheck","checkCacheForStaleBlobs","setPublisher","publisher","getCacheEntry","id","setCacheEntry","entry","put","deleteCacheEntry","delete","allEntries","getAll","staleCount","shouldDelete","lowResUrl","startsWith","fetch","catch","ok","warn","highResUrl","e","processImage","image","src","width","height","cachedEntry","lowResMatches","lowResWidth","round","lowResHeight","highResMatches","_b","quality","imageUrl","_c","cacheError","activeRequests","has","controller","AbortController","set","add","size","createdBitmap","signal","aborted","DOMException","reason","blob","createImageBitmap","fetchError","_d","result","Comlink","transfer","imageBitmap","revokeObjectURL","finalEntry","timestamp","Date","now","_e","_f","_g","close","processBatch","images","batchId","random","toString","slice","imagesToProcess","transferList","preCheckPromises","createdBitmaps","batchError","length","push","localBitmap","index","indexOf","splice","Promise","all","batchResults","forEach","r","cacheUpdatePromises","resultId","originalItem","find","item","originalWidth","originalHeight","existingEntry","bitmap","includes","cancel","abort","clear","cancelAll","terminate","releaseProxy","then","_WorkerPool","layoutQueue","groupingQueue","colorQueue","getInstance","instance","initializeWorker","workerType","WorkerConstructor","setupListenersFn","resolve","reject","getImageProcessor","imageProcessor","isImageProcessorInitialized","cancelPendingImageTasks","getLayoutWorker","layoutWorkerPromise","LayoutWorker","layoutWorker","setupWorkerMessageHandler","pendingLayoutRequests","layoutWorkerListeners","err","getColorExtractorWorker","colorExtractorWorkerPromise","ColorExtractorWorker","colorExtractorWorker","pendingColorRequests","colorExtractorListeners","getGroupingWorker","groupingWorkerPromise","GroupingWorker","groupingWorker","pendingGroupingRequests","groupingWorkerListeners","pendingRequests","generalListeners","onmessage","event","requestId","clearTimeout","timer","payload","listener","postRequest","messageType","getWorkerPromise","bind","resolveTask","rejectTask","uuidv4","initError","responsePromise","resolveResponse","rejectResponse","timeoutMs","setTimeout","workerMessage","postMessage","postError","priority","addLayoutWorkerListener","removeLayoutWorkerListener","addColorExtractorListener","removeColorExtractorListener","addGroupingWorkerListener","removeGroupingWorkerListener","cancelPendingLayoutTasks","cancelTasks","cancelPendingColorTasks","cancelPendingGroupingTasks","cleanup","cancelAllPendingTasks","terminateWorker","WorkerPool","SCROLL_STATE_STORE_NAME","openScrollStateDB","saveScrollState","folderPath","scrollTop","tx","transaction","store","objectStore","stateToSave","done","ViewMode","gsap","registerPlugin","ScrollTrigger","_ScrollTriggerManager","timeline","paused","smoothChildTiming","mainTrigger","trigger","document","body","start","end","onUpdate","self","progress","markers","addAnimation","element","animationProps","animation","to","targets","removeAnimation","target","remove","kill","ScrollTriggerManager","CustomEase","_AnimationSystem","initializeCustomEases","scrollTriggerManager","getAnimationProperties","itemId","duration","ease","transformOrigin","scale","rotation","createHoverAnimation","force3D","createMorphAnimation","borderRadius","boxShadow","createScrollAnimation","AnimationSystem","calculateGapSize","zoom","baseGap","min","roundedGap","calculateLayout","config","containerWidth","viewMode","isGrouped","columns","effectiveWidth","baseColumns","floor","calculateColumns","gap","minImageWidth","maxImageWidth","hexToVec3","hex","g","b","parseInt","lerpArray","t","val","i","lerp","AuraBackground$1","React","memo","canvasRef","useRef","glRef","programRef","bufferRef","attribLocationsRef","uniformLocationsRef","animationFrameRef","animatedColor1","animatedColor2","animatedMixFactor","animatedHoverPos","x","y","animatedIsHovering","createShader","gl","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","VERTEX_SHADER","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","renderLoop","time","current","requestAnimationFrame","timeSeconds","lerpSpeed","targetColor1","targetColor2","targetMix","targetIsHovering","targetPos","viewport","canvas","useProgram","bindBuffer","ARRAY_BUFFER","posLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","uniform2f","resolution","uniform1f","uniform3fv","colorTarget1","colorTarget2","colorMixFactor","uniform2fv","hoverPos","drawArrays","TRIANGLES","useEffect","canvasElement","getContext","alpha","antialias","FRAGMENT_SHADER","detachShader","positions","Float32Array","createBuffer","bufferData","STATIC_DRAW","getAttribLocation","getUniformLocation","hoverColor","resizeObserver","ResizeObserver","entries","contentRect","observe","cancelAnimationFrame","disconnect","currentGl","deleteBuffer","jsx","ref","className","styles","style","top","left","overflow","pointerEvents","zIndex","truncateImageTitle","title","formattedTitle","replace","split","word","match","charAt","toUpperCase","toLowerCase","join","trim","substring","ResponsiveImage","forwardRef","alt","isProcessed","onLoad","isInternallyLoaded","setIsInternallyLoaded","handleLoad","handleError","useSrcSet","srcSet","sizes","motion","img","loading","display","objectFit","initial","opacity","animate","transition","displayName","ImageItem$1","onClick","containerHeight","groupCount","onResize","isCarousel","groupImages","onImageHover","onImageLoadError","dominantColor","imageRef","containerRef","isHighResLoaded","setIsHighResLoaded","processedUrls","setProcessedUrls","hasError","setHasError","hasLowResProcessed","setHasLowResProcessed","hasHighResProcessed","setHasHighResProcessed","subscribeToImageUpdates","placeholderColor","targetWidth","targetHeight","aspectRatio","handleMouseEnter","rect","getBoundingClientRect","centerX","centerY","normalizedX","window","innerWidth","normalizedY","innerHeight","imageId","handleMouseLeave","handleProcessedImageUpdate","prev","unsubscribe","currentLowUrl","low","currentHighUrl","high","currentSrc","isUsingProcessed","shouldRenderImage","handleImageLoad","handleImageError","jsxs","imageItemContainer","onMouseEnter","onMouseLeave","cursor","backgroundColor","imageElement","errorOverlay","titleOverlay","groupIndicator","smoothLayoutTransition","stiffness","damping","mass","itemVariants","hidden","visible","delay","ImageRow$1","imageWidths","onImageClick","isLastRow","rowHeight","groupedImages","workerPool","dominantColorMap","rowRef","controls","useAnimation","div","flexWrap","marginBottom","willChange","maxWidth","justifyContent","alignItems","layout","group","some","custom","variants","flexShrink","flexGrow","ImageItem","ImageSkeleton","imageItem","imageSkeleton","maxHeight","skeletonAnimation","BannerView","NextArrow","props","FaChevronRight","PrevArrow","FaChevronLeft","CarouselView","Slider","dots","infinite","speed","slidesToShow","slidesToScroll","nextArrow","prevArrow","adaptiveHeight","customPaging","MasonryView","Masonry","breakpointCols","default","columnClassName","ImageFeed$1","scrollContainerRef","originalImages","isLoading","isLoadingImages","isError","isPlaceholderData","windowSize","setWindowSize","handleResize","newWidth","newHeight","timeoutId","debouncedResize","addEventListener","removeEventListener","useWindowSize","feedRef","setContainerWidth","setColumns","lightboxIndex","setLightboxIndex","lightboxImages","setLightboxImages","setDominantColorMap","requestedColorIds","Set","hoverTimeoutRef","restoredState","setRestoredState","previousFolderPathRef","rowHeightsRef","isRestoringScrollRef","velocityEMARef","dynamicOverscan","setDynamicOverscan","failedImageIds","setFailedImageIds","publishImageUpdate","getImageUrl","imagePath","filter","handleImageLoadError","newSet","calculatedRows","setCalculatedRows","isLayoutCalculating","setIsLayoutCalculating","processedGroupedImages","setProcessedGroupedImages","isGrouping","setIsGrouping","activeRequestRef","layoutDataMap","currentTop","row","currentLeft","imageList","layoutData","lookaheadDistance","throttleDelay","setViewport","bottom","processingRef","runPrefetchLogicRef","updateViewport","container","clientHeight","currentBottom","calculatePriority","imageLayout","imageCenterY","viewportCenterY","abs","runPrefetchLogicAsyncInternal","currentViewport","candidates","prefetchTop","prefetchBottom","imageTop","sort","a","processedCount","candidate","toFixed","finally","throttledRunPrefetch","throttle","passive","usePrefetchManager","debouncedIsGrouped","setDebouncedIsGrouped","updateDebouncedGrouped","lodashDebounce","newValue","debouncedSaveScroll","func","waitFor","debounced","args","debounce","scroll","isMounted","loadedState","state","loadScrollState","loadAndSetState","currentPathForCleanup","scrollElement","folderToSave","avgAspectRatio","validImages","reduce","sum","layoutMetrics","gapSize","estimatedRowHeightFallback","totalGapWidth","availableWidthForImages","estimatedAvgImageWidth","updateContainerWidth","prevWidth","useLayoutEffect","initialImageCount","imageInfo","grouping","calculateGrouping","GRID","firstImages","targetRowHeight","calculateGridLayout","handleImageClick","clickedImage","groupIndex","findIndex","imageIndexInGroup","lastScrollTopRef","lastScrollTimeRef","performance","handleScroll","timeDelta","scrollDelta","velocity","calculatedOverscan","OVERSCAN_MAX","throttledScrollHandler","limit","inThrottle","apply","rowVirtualizer","useVirtualizer","count","getScrollElement","estimateSize","overscan","measure","virtualItems","getVirtualItems","handleImageHover","visibleImageIds","virtualItem","colorPromises","promise","colorValue","prevMap","newMap","allSettled","currentVisibleColors","itemColor","processor","lightboxPlugins","Captions","Counter","Thumbnails","Zoom","slides","AuraBackground","feed","showLoadingState","gridContainer","gridTemplateColumns","padding","ViewComponent","MASONRY","BANNER","CAROUSEL","getTotalSize","measureElement","ImageRow","key","Lightbox","open","plugins","noImages","ImageViewer","selectedFolder","ImageFeed","MainContent","searchQuery","Fragment","CurrentDirectoryButton","staleTime","refetchOnWindowFocus","buttonContent","buttonClass","iconColor","button","whileHover","whileTap","disabled","IconFolder","SearchBar","onSearch","query","setQuery","form","onSubmit","preventDefault","background","input","onChange","placeholder","whileFocus","ZoomSlider","onZoomChange","isDragging","setIsDragging","sliderWidth","glowOpacity","glowScale","svg","viewBox","fill","xmlns","rotate","d","stroke","strokeWidth","strokeLinecap","strokeLinejoin","transform","precision","step","parseFloat","onMouseDown","onMouseUp","onTouchStart","onTouchEnd","Navbar","onGroupToggle","onViewModeChange","svgRef","querySelector","getTotalLength","strokeDasharray","strokeDashoffset","values","mode","HOME_DIRECTORY_KEY","getHomeDirectory","localStorage","getItem","Sidebar","onFolderChange","folders","currentHomeDir","setCurrentHomeDir","handleSetHome","stopPropagation","setItem","setHomeDirectory","sidebar","logo","folderList","folderItem","folderButton","folderName","setHomeButton","isHome","FaHome","uploadButton","CUSTOM_PROPERTIES","DEFAULT_CUSTOM_PROPERTY_VALUES","CUSTOM_PROPERTIES_SCROLL_Y","CUSTOM_PROPERTIES_MOUSE_X","CUSTOM_PROPERTIES_MOUSE_Y","ScrollToPlugin","Layout","mainRef","updateCustomProperties","mouseX","clientX","mouseY","clientY","documentElement","setProperty","updateScrollProperty","scrollY","Object","property","setSearchQuery","Home","setSelectedFolder","setZoom","setIsGrouped","setViewMode","mainScrollRef","newZoom","newMode","App","render","html","ReactDOMServer","renderToString","StrictMode"],"mappings":"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"}