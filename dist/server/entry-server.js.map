{"version":3,"file":"entry-server.js","sources":["../../src/contexts/AnimationControllerContext.tsx","../../src/contexts/ColorContext.tsx","../../src/contexts/ImageProcessingContext.tsx","../../src/types/index.ts","../../src/lib/api.ts","../../src/components/CurrentDirectoryButton.tsx","../../src/hooks/query/useCurrentDirectory.ts","../../src/components/SearchBar.tsx","../../src/components/ZoomSlider.tsx","../../src/components/Navbar.tsx","../../src/utils/settings.ts","../../src/components/Sidebar.tsx","../../src/hooks/query/useFolders.ts","../../src/utils/constants.ts","../../src/components/AuraBackground.tsx","../../src/components/Layout.tsx","../../src/hooks/useCustomProperties.ts","../../src/hooks/query/useFolderImages.ts","../../src/workers/imageProcessor.ts","../../src/workers/workerPool.ts","../../src/lib/cache/feedStateCache.ts","../../src/utils/ScrollTriggerManager.ts","../../src/utils/AnimationSystem.ts","../../src/utils/layoutCalculator.ts","../../src/animations/motionPresets.ts","../../src/animations/MotionPreset.tsx","../../src/components/ImageItem.tsx","../../src/utils/stringUtils.ts","../../src/components/ImageRow.tsx","../../src/components/ImageSkeleton.tsx","../../src/components/views/BannerView.tsx","../../src/components/views/CarouselView.tsx","../../src/components/views/MasonryView.tsx","../../src/components/ImageFeed.tsx","../../src/hooks/useWindowSize.ts","../../src/hooks/usePrefetchManager.ts","../../src/components/ImageViewer.tsx","../../src/components/MainContent.tsx","../../src/animations/AnimationPipeline.ts","../../src/pages/Home.tsx","../../src/hooks/useAnimationPipeline.ts","../../src/App.tsx","../../src/entry-server.tsx"],"sourcesContent":["import React, { createContext, useCallback, useContext, useMemo, useRef } from 'react';\r\nimport { AnimationPipeline } from '../animations/AnimationPipeline';\r\n\r\n// Define the structure for a registered pipeline\r\ninterface RegisteredPipeline {\r\n  id: string;\r\n  pipeline: AnimationPipeline;\r\n  triggerEvents: string[]; // Events that should trigger this pipeline\r\n  playOnTrigger?: boolean; // If true, plays; if false (or undefined), restarts\r\n}\r\n\r\n// Define the shape of the context value\r\ninterface AnimationControllerContextValue {\r\n  /**\r\n   * Triggers a specific event, potentially starting registered pipelines.\r\n   * @param eventName The name of the event to trigger (e.g., 'routeEnter', 'dataLoaded').\r\n   */\r\n  trigger: (eventName: string) => void;\r\n\r\n  /**\r\n   * Registers an AnimationPipeline instance to be triggered by specific events.\r\n   * Returns a function to unregister the pipeline.\r\n   *\r\n   * @param id A unique identifier for the pipeline.\r\n   * @param pipeline The AnimationPipeline instance.\r\n   * @param triggerEvents An array of event names that should trigger this pipeline.\r\n   * @param playOnTrigger If true, calls play(); otherwise calls restart(). Defaults to false (restart).\r\n   * @returns A function to call for unregistering the pipeline.\r\n   */\r\n  registerPipeline: (\r\n    id: string,\r\n    pipeline: AnimationPipeline,\r\n    triggerEvents: string[],\r\n    playOnTrigger?: boolean\r\n  ) => () => void; // Returns unregister function\r\n}\r\n\r\n// Create the context with a default value (or null)\r\nconst AnimationControllerContext = createContext<AnimationControllerContextValue | null>(null);\r\n\r\n// Define props for the provider\r\ninterface AnimationControllerProviderProps {\r\n  children: React.ReactNode;\r\n}\r\n\r\n// Implement the Provider component\r\nexport const AnimationControllerProvider: React.FC<AnimationControllerProviderProps> = ({\r\n  children,\r\n}) => {\r\n  // Use useRef to store pipelines to avoid re-renders on registration/unregistration\r\n  const pipelinesRef = useRef<Map<string, RegisteredPipeline>>(new Map());\r\n  // Optional: State to track the last triggered event if needed elsewhere\r\n  // const [lastEvent, setLastEvent] = useState<string | null>(null);\r\n\r\n  // --- Trigger Function --- >\r\n  const trigger = useCallback((eventName: string) => {\r\n    console.log(`[AnimationController] Triggering event: \"${eventName}\"`);\r\n    // setLastEvent(eventName); // Update last event state if needed\r\n\r\n    pipelinesRef.current.forEach(registered => {\r\n      if (registered.triggerEvents.includes(eventName)) {\r\n        console.log(\r\n          `[AnimationController] Running pipeline \"${registered.id}\" for event \"${eventName}\"`\r\n        );\r\n        if (registered.playOnTrigger) {\r\n          registered.pipeline.play().catch(err => {\r\n            console.error(`Error playing pipeline ${registered.id}:`, err);\r\n          });\r\n        } else {\r\n          registered.pipeline.restart().catch(err => {\r\n            console.error(`Error restarting pipeline ${registered.id}:`, err);\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  // --- Register Function --- >\r\n  const registerPipeline = useCallback(\r\n    (\r\n      id: string,\r\n      pipeline: AnimationPipeline,\r\n      triggerEvents: string[],\r\n      playOnTrigger: boolean = false // Default to restart\r\n    ): (() => void) => {\r\n      if (pipelinesRef.current.has(id)) {\r\n        console.warn(\r\n          `[AnimationController] Pipeline with ID \"${id}\" already registered. Overwriting.`\r\n        );\r\n      }\r\n      console.log(`[AnimationController] Registering pipeline \"${id}\" for events:`, triggerEvents);\r\n      pipelinesRef.current.set(id, { id, pipeline, triggerEvents, playOnTrigger });\r\n\r\n      // Return the unregister function\r\n      return () => {\r\n        console.log(`[AnimationController] Unregistering pipeline \"${id}\"`);\r\n        pipelinesRef.current.delete(id);\r\n        // Note: The pipeline itself should be killed by the component that created it\r\n        // using the useAnimationPipeline hook's cleanup.\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  // --- Context Value --- >\r\n  const contextValue: AnimationControllerContextValue = useMemo(\r\n    () => ({ trigger, registerPipeline }),\r\n    [trigger, registerPipeline]\r\n  );\r\n\r\n  return (\r\n    <AnimationControllerContext.Provider value={contextValue}>\r\n      {children}\r\n    </AnimationControllerContext.Provider>\r\n  );\r\n};\r\n\r\n// --- Consumer Hook --- >\r\nexport const useAnimationController = (): AnimationControllerContextValue => {\r\n  const context = useContext(AnimationControllerContext);\r\n  if (!context) {\r\n    throw new Error('useAnimationController must be used within an AnimationControllerProvider');\r\n  }\r\n  return context;\r\n};\r\n","import React, { createContext, ReactNode, useCallback, useMemo, useState } from 'react';\n\n// Define hover state structure\ninterface HoverState {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates [0, 1] relative to background\n  color: string | null; // Optional: Dominant color of hovered item\n}\n\n// Define the shape of the context data\ninterface ColorContextProps {\n  // Store maybe 1 or 2 dominant colors. Using string[] for flexibility.\n  dominantColors: string[];\n  setDominantColors: (colors: string[]) => void;\n  // Add hover state\n  hoverState: HoverState;\n  setHoverState: (newState: Partial<HoverState>) => void; // Allow partial updates\n}\n\n// Default initial background color (dark blueish)\nconst initialDefaultColor = '#041024';\n\n// Initial hover state\nconst initialHoverState: HoverState = {\n  isHovering: false,\n  position: null,\n  color: null,\n};\n\n// Create the context with a default value\nexport const ColorContext = createContext<ColorContextProps>({\n  dominantColors: [initialDefaultColor],\n  setDominantColors: () => {}, // No-op function as default\n  hoverState: initialHoverState,\n  setHoverState: () => {}, // No-op\n});\n\n// Create the provider component\ninterface ColorProviderProps {\n  children: ReactNode;\n}\n\nexport const ColorProvider: React.FC<ColorProviderProps> = ({ children }) => {\n  const [dominantColors, setDominantColorsState] = useState<string[]>([initialDefaultColor]);\n  const [hoverState, setHoverStateInternal] = useState<HoverState>(initialHoverState);\n\n  // Create a stable setter function that allows partial updates\n  const setHoverState = useCallback((newState: Partial<HoverState>) => {\n    setHoverStateInternal(prevState => ({ ...prevState, ...newState }));\n  }, []);\n\n  // Avoid re-creating the context value object on every render\n  const contextValue = useMemo(\n    () => ({\n      dominantColors,\n      setDominantColors: setDominantColorsState,\n      hoverState,\n      setHoverState, // Provide the stable setter\n    }),\n    [dominantColors, hoverState, setHoverState] // Add dependencies\n  );\n\n  return <ColorContext.Provider value={contextValue}>{children}</ColorContext.Provider>;\n};\n","import React, { createContext, ReactNode, useCallback, useContext, useMemo } from 'react';\r\n\r\n// Type for the data sent when an image is processed\r\nexport interface ProcessedImageUpdate {\r\n  id: string;\r\n  quality: 'low' | 'high';\r\n  imageUrl: string;\r\n  // Include dimensions if available and needed by ImageItem\r\n  width?: number;\r\n  height?: number;\r\n}\r\n\r\n// Type for the callback function used by subscribers\r\ntype ImageUpdateCallback = (data: ProcessedImageUpdate) => void;\r\n\r\n// Type for the context value\r\ninterface ImageProcessingContextType {\r\n  subscribeToImageUpdates: (imageId: string, callback: ImageUpdateCallback) => () => void; // Returns unsubscribe function\r\n  publishImageUpdate: (data: ProcessedImageUpdate) => void;\r\n}\r\n\r\n// Create the context with a default value (can be null or a dummy implementation)\r\nconst ImageProcessingContext = createContext<ImageProcessingContextType | null>(null);\r\n\r\n// Provider component props\r\ninterface ImageProcessingProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n// Keep track of subscriptions outside the component state if preferred\r\n// This avoids re-rendering the provider on every subscription change\r\nconst subscriptions = new Map<string, Set<ImageUpdateCallback>>();\r\n\r\n// Provider component implementation\r\nexport const ImageProcessingProvider: React.FC<ImageProcessingProviderProps> = ({ children }) => {\r\n  const subscribeToImageUpdates = useCallback(\r\n    (imageId: string, callback: ImageUpdateCallback): (() => void) => {\r\n      if (!subscriptions.has(imageId)) {\r\n        subscriptions.set(imageId, new Set());\r\n      }\r\n      const imageSubscriptions = subscriptions.get(imageId)!;\r\n      imageSubscriptions.add(callback);\r\n\r\n      // Return unsubscribe function\r\n      return () => {\r\n        if (subscriptions.has(imageId)) {\r\n          subscriptions.get(imageId)!.delete(callback);\r\n          // Optional: Clean up Set/Map entry if no subscribers left\r\n          if (subscriptions.get(imageId)!.size === 0) {\r\n            subscriptions.delete(imageId);\r\n          }\r\n        }\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  const publishImageUpdate = useCallback((data: ProcessedImageUpdate) => {\r\n    if (subscriptions.has(data.id)) {\r\n      const imageSubscriptions = subscriptions.get(data.id)!;\r\n      // Notify all subscribers for this image ID\r\n      imageSubscriptions.forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`Error in image update callback for ID ${data.id}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  // Memoize the context value\r\n  const contextValue = useMemo(\r\n    () => ({\r\n      subscribeToImageUpdates,\r\n      publishImageUpdate,\r\n    }),\r\n    [subscribeToImageUpdates, publishImageUpdate]\r\n  );\r\n\r\n  return (\r\n    <ImageProcessingContext.Provider value={contextValue}>\r\n      {children}\r\n    </ImageProcessingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook for easy context consumption\r\nexport const useImageProcessing = (): ImageProcessingContextType => {\r\n  const context = useContext(ImageProcessingContext);\r\n  if (!context) {\r\n    throw new Error('useImageProcessing must be used within an ImageProcessingProvider');\r\n  }\r\n  return context;\r\n};\r\n","import { createImageProcessor } from '../workers/imageProcessor.js';\n\nexport interface ImageInfo {\n  id: string;\n  src: string;\n  alt: string;\n  title: string;\n  width: number;\n  height: number;\n  group?: {\n    key: string;\n    images: ImageInfo[];\n    isCarousel: boolean;\n  };\n}\n\nexport interface FolderInfo {\n  name: string;\n  path: string;\n}\n\nexport interface UploadProps {\n  selectedFolder: string;\n  onUploadComplete: () => void;\n}\n\nexport interface SearchProps {\n  onSearch: (query: string) => void;\n}\n\nexport interface ImageFeedProps {\n  images: ImageInfo[];\n  isLoading: boolean;\n}\n\nexport interface ImageRowProps {\n  images: ImageInfo[];\n  onImageClick: (image: ImageInfo, groupImages: ImageInfo[]) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  imageProcessor: ReturnType<typeof createImageProcessor>;\n}\n\nexport interface LayoutProps {\n  children: React.ReactNode;\n  folders: FolderInfo[];\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface NavbarProps {\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface GroupedImageInfo {\n  id: string;\n  title: string;\n  images: ImageInfo[];\n}\n\nexport enum ViewMode {\n  GRID = 'grid',\n  BANNER = 'banner',\n  MASONRY = 'masonry',\n  CAROUSEL = 'carousel',\n}\n\n// Interface for the data stored in IndexedDB for cached images\nexport interface ProcessedImageCacheEntry {\n  id: string;\n  lowResUrl?: string; // Blob URL for low-res\n  lowResWidth?: number;\n  lowResHeight?: number;\n  highResUrl?: string; // Blob URL for high-res\n  width?: number; // Original requested width\n  height?: number; // Original requested height\n  timestamp?: number; // When it was cached\n}\n\n// Interface for the Comlink-exposed worker API\nexport interface ImageProcessorWorkerAPI {\n  processImage(data: {\n    id: string;\n    // Accept ImageBitmap directly\n    imageBitmap: ImageBitmap;\n    width: number;\n    height: number;\n    signal?: AbortSignal;\n  }): Promise<{ lowResUrl?: string; highResUrl?: string }>; // Return URLs\n\n  processBatch(data: {\n    // Batch expects bitmaps now\n    images: Array<{ id: string; imageBitmap: ImageBitmap; width: number; height: number }>;\n    signal?: AbortSignal;\n    // Add callback for progress? Comlink supports callbacks\n    // onProgress?: (processed: { id: string; lowResUrl?: string; highResUrl?: string }) => void;\n  }): Promise<Array<{ id: string; lowResUrl?: string; highResUrl?: string }>>; // Return array of results\n}\n","import axios from 'axios';\nimport { FolderInfo, ImageInfo } from '../types/index.js';\n\nconst api = axios.create({\n  baseURL: '/api', // Assuming your API routes are under /api\n});\n\n/**\n * Fetches the list of folders from the server.\n *\n * @returns {Promise<FolderInfo[]>} A promise that resolves to an array of folder information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getFolders(): Promise<FolderInfo[]> {\n  try {\n    const response = await api.get('/folders');\n    return response.data.map((folder: { name: string; path: string }) => ({\n      name: folder.name,\n      path: folder.path,\n    }));\n  } catch (error) {\n    console.error('Error in getFolders:', error);\n    throw new Error('Failed to fetch folders');\n  }\n}\n\n/**\n * Fetches the list of images for a specific folder from the server.\n *\n * @param {string} folder - The name of the folder to fetch images from.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getImages(folder: string): Promise<ImageInfo[]> {\n  if (!folder) {\n    throw new Error('Folder parameter is required');\n  }\n\n  try {\n    const response = await api.get(`/images?folder=${encodeURIComponent(folder)}`);\n\n    if (!Array.isArray(response.data)) {\n      console.error('Invalid response data:', response.data);\n      throw new Error('Invalid response format from server');\n    }\n\n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      const message = error.response.data?.error || error.response.statusText;\n      throw new Error(`Server error: ${message}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      throw new Error('No response from server');\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.error('Error in getImages:', error);\n      throw new Error(error.message || 'Failed to fetch images');\n    }\n  }\n}\n/**\n * Uploads files to a specified folder on the server.\n *\n * @param {string} folder - The name of the folder to upload files to.\n * @param {File[]} files - An array of File objects to be uploaded.\n * @param {function} onProgress - A callback function to report upload progress.\n * @returns {Promise<void>} A promise that resolves when the upload is complete.\n * @throws Will throw an error if the API request fails.\n */\nexport async function uploadFiles(\n  folder: string,\n  files: File[],\n  onProgress: (progress: number) => void\n): Promise<void> {\n  const formData = new FormData();\n  formData.append('folder', folder);\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    await api.post('/upload', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data',\n      },\n      onUploadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(percentCompleted);\n        }\n      },\n    });\n  } catch (error) {\n    console.error('Error in uploadFiles:', error);\n    throw new Error('Failed to upload files');\n  }\n}\n/**\n * Searches for images across all folders based on a query string.\n *\n * @param {string} query - The search query string.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information matching the search query.\n * @throws Will throw an error if the API request fails.\n */\nexport async function searchImages(query: string): Promise<ImageInfo[]> {\n  try {\n    const response = await api.get(`/search?q=${encodeURIComponent(query)}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error in searchImages:', error);\n    throw new Error('Failed to search images');\n  }\n}\n\n/**\n * Fetches the current main directory from the server.\n *\n * @returns {Promise<string>} A promise that resolves to the current main directory path.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getCurrentDirectory(): Promise<string> {\n  try {\n    const response = await api.get('/getCurrentDirectory');\n    return response.data.currentDirectory;\n  } catch (error) {\n    console.error('Error in getCurrentDirectory:', error);\n    throw new Error('Failed to get current directory');\n  }\n}\n","import { IconFolder } from '@tabler/icons-react';\r\nimport { motion } from 'framer-motion';\r\nimport React from 'react';\r\nimport { useCurrentDirectory } from '../hooks/query/useCurrentDirectory';\r\n\r\n/** Props for the CurrentDirectoryButton component. */\r\ninterface CurrentDirectoryButtonProps {\r\n  // currentDirectory: string; // Removed\r\n}\r\n\r\n/** CurrentDirectoryButton component that displays the current directory.*/\r\nconst CurrentDirectoryButton: React.FC<CurrentDirectoryButtonProps> = () => {\r\n  // Fetch the current directory using the hook\r\n  const { data: currentDirectory, isLoading, isError } = useCurrentDirectory();\r\n\r\n  // Determine button content based on loading/error state\r\n  let buttonContent = '...'; // Loading state\r\n  let buttonClass = 'bg-gray-600 text-gray-400 cursor-not-allowed';\r\n  let iconColor = 'text-gray-500';\r\n\r\n  if (isError) {\r\n    buttonContent = 'Error';\r\n    buttonClass = 'bg-red-800 text-red-200 cursor-not-allowed';\r\n    iconColor = 'text-red-400';\r\n  } else if (!isLoading && currentDirectory) {\r\n    buttonContent = currentDirectory;\r\n    buttonClass = 'bg-gray-700 text-peach hover:bg-gray-600'; // Original classes\r\n    iconColor = 'text-yellow-500'; // Original color\r\n  }\r\n\r\n  return (\r\n    <motion.button\r\n      className={`flex items-center px-3 py-1 rounded-md text-sm transition-all duration-300 ease-in-out ${buttonClass}`}\r\n      whileHover={!isLoading && !isError ? { scale: 1.05 } : {}}\r\n      whileTap={!isLoading && !isError ? { scale: 0.95 } : {}}\r\n      disabled={isLoading || isError}\r\n    >\r\n      {/* Folder icon */}\r\n      <IconFolder size={16} className={`mr-2 ${iconColor}`} />\r\n\r\n      {/* Current directory path or status */}\r\n      <motion.div\r\n        className=\"truncate max-w-xs\"\r\n        initial={{ opacity: 0 }}\r\n        animate={{ opacity: 1 }}\r\n        transition={{ duration: 0.3 }}\r\n      >\r\n        <span>{buttonContent}</span>\r\n      </motion.div>\r\n    </motion.button>\r\n  );\r\n};\r\n\r\nexport default CurrentDirectoryButton;\r\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentDirectory } from '../../lib/api';\r\n\r\n/**\r\n * Custom hook to fetch the current base directory from the server.\r\n *\r\n * @returns The result object from useQuery, containing the directory path string, loading state, error state, etc.\r\n */\r\nexport function useCurrentDirectory() {\r\n  return useQuery<string, Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    queryKey: ['currentDirectory'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getCurrentDirectory,\r\n    // Optional: Consider a longer staleTime as this might not change often\r\n    staleTime: 1000 * 60 * 30, // e.g., stays fresh for 30 minutes\r\n    refetchOnWindowFocus: false, // Likely doesn't need to refetch on focus\r\n  });\r\n}\r\n","import { motion, useAnimation } from 'framer-motion';\nimport { useState } from 'react';\nimport styles from '../styles/SearchBar.module.scss';\n\n// Define the props interface for the SearchBar component\ninterface SearchBarProps {\n  onSearch: (query: string) => void;\n}\n\n// Define the SearchBar component\nconst SearchBar: React.FC<SearchBarProps> = ({ onSearch }) => {\n  // State to manage the search query\n  const [query, setQuery] = useState('');\n  const controls = useAnimation();\n\n  // Handler for form submission\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSearch(query);\n  };\n\n  // Render the SearchBar component\n  return (\n    <motion.form\n      onSubmit={handleSubmit}\n      className={styles.searchBarContainer}\n      initial={{ width: '200px' }}\n      animate={{ width: query ? '300px' : '200px' }}\n      transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n    >\n      <motion.div\n        className={styles.searchBackground}\n        animate={{\n          background: query\n            ? 'linear-gradient(90deg, #4a00e0 0%, #8e2de2 100%)'\n            : 'rgba(255, 255, 255, 0.1)',\n        }}\n      />\n      <motion.input\n        type=\"text\"\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        className={styles.searchInput}\n        placeholder=\"Search the future...\"\n        whileFocus={{ scale: 1.05 }}\n        transition={{ type: 'spring', stiffness: 400, damping: 30 }}\n      />\n    </motion.form>\n  );\n};\n\n// Export the SearchBar component\nexport default SearchBar;\n","import { motion, useAnimation } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\n\n// Define the props interface for the ZoomSlider component\ninterface ZoomSliderProps {\n  zoom: number;\n  onZoomChange: (zoom: number) => void;\n}\n\n// ZoomSlider component for adjusting image zoom level\nconst ZoomSlider: React.FC<ZoomSliderProps> = ({ zoom, onZoomChange }) => {\n  const [isDragging, setIsDragging] = useState(false);\n  const controls = useAnimation();\n\n  // compute animated values manually for Framer Motion\n  const sliderWidth = `${((zoom - 0.5) / 1.5) * 100}%`;\n  const glowOpacity = isDragging ? 1 : 0.6;\n  const glowScale = isDragging ? 1.1 : 1;\n\n  useEffect(() => {\n    controls.start({\n      scale: isDragging ? 1.05 : 1,\n      transition: {\n        type: 'spring',\n        stiffness: 300,\n        damping: 20,\n      },\n    });\n  }, [isDragging, controls]);\n\n  return (\n    <motion.div\n      className=\"relative flex items-center bg-gray-800/80 backdrop-blur-md rounded-full p-3 overflow-hidden\"\n      style={{\n        boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n        width: '200px',\n      }}\n      animate={controls}\n    >\n      {/* Zoom out icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.max(0.5, zoom - 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 mr-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: -90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M11 8V14M8 11H14M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n\n      {/* Slider track */}\n      <div className=\"relative flex-1 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <motion.div\n          className=\"absolute top-0 left-0 h-full bg-blue-500 rounded-full\"\n          style={{ boxShadow: '0 0 10px rgba(59,130,246,0.5)' }}\n          animate={{ width: sliderWidth }}\n          transition={{ type: 'spring', stiffness: 300, damping: 10, precision: 0.01 }}\n        />\n        <input\n          type=\"range\"\n          min=\"0.5\"\n          max=\"2\"\n          step=\"0.1\"\n          value={zoom}\n          onChange={e => onZoomChange(parseFloat(e.target.value))}\n          onMouseDown={() => setIsDragging(true)}\n          onMouseUp={() => setIsDragging(false)}\n          onTouchStart={() => setIsDragging(true)}\n          onTouchEnd={() => setIsDragging(false)}\n          className=\"absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer\"\n        />\n      </div>\n\n      {/* Zoom in icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.min(2, zoom + 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 ml-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: 90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n    </motion.div>\n  );\n};\n\n// Export the ZoomSlider component\nexport default ZoomSlider;\n","import { motion } from 'framer-motion';\nimport { forwardRef, useEffect, useRef } from 'react';\nimport styles from '../styles/Navbar.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport CurrentDirectoryButton from './CurrentDirectoryButton';\nimport SearchBar from './SearchBar';\nimport ZoomSlider from './ZoomSlider';\n\n// Update the props interface for the Navbar component\ninterface NavbarProps {\n  // currentDirectory: string; // Removed: Fetched by CurrentDirectoryButton\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n}\n\n// Use forwardRef to allow passing ref to the underlying motion.div\nconst Navbar = forwardRef<HTMLDivElement, NavbarProps>(\n  (\n    {\n      // currentDirectory, // Removed\n      onSearch,\n      zoom,\n      onZoomChange,\n      isGrouped,\n      onGroupToggle,\n      viewMode,\n      onViewModeChange,\n    },\n    ref\n  ) => {\n    const svgRef = useRef<SVGSVGElement>(null);\n\n    useEffect(() => {\n      const svg = svgRef.current;\n      if (svg) {\n        const animate = () => {\n          const path = svg.querySelector('path');\n          if (path) {\n            const length = path.getTotalLength();\n            path.style.strokeDasharray = `${length} ${length}`;\n            path.style.strokeDashoffset = `${length}`;\n            path.getBoundingClientRect();\n            path.style.transition = 'stroke-dashoffset 2s ease-in-out';\n            path.style.strokeDashoffset = '0';\n          }\n        };\n        animate();\n      }\n    }, []);\n\n    // Render the Navbar component\n    return (\n      <motion.div ref={ref} className={styles.navbar}>\n        <svg ref={svgRef} className={styles.navbarBackground}>\n          <path d=\"M0,0 Q50,20 100,10 T200,30 T300,5 T400,25 V100 Q350,80 300,90 T200,70 T100,95 T0,75 Z\" />\n        </svg>\n        {/* Left section of the navbar */}\n        <div className={styles.leftSection}>\n          {/* Display the current directory */}\n          <CurrentDirectoryButton /> {/* No prop needed */}\n          {/* Search functionality */}\n          <SearchBar onSearch={onSearch} />\n        </div>\n        {/* Right section of the navbar */}\n        <div className={styles.rightSection}>\n          {/* View mode toggle buttons */}\n          <div className={styles.viewModeButtons}>\n            {Object.values(ViewMode).map(mode => (\n              <motion.button\n                key={mode}\n                onClick={() => onViewModeChange(mode)}\n                className={`${styles.viewModeButton} ${viewMode === mode ? styles.active : ''}`}\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n              >\n                {mode.charAt(0).toUpperCase() + mode.slice(1)}\n              </motion.button>\n            ))}\n          </div>\n          <motion.button\n            onClick={onGroupToggle}\n            className={styles.viewToggleButton}\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n          >\n            {isGrouped ? 'Ungroup' : 'Group'}\n          </motion.button>\n          {/* Zoom control slider */}\n          <ZoomSlider zoom={zoom} onZoomChange={onZoomChange} />\n        </div>\n      </motion.div>\n    );\n  }\n);\n\nNavbar.displayName = 'Navbar'; // Add display name for DevTools\n\n// Export the Navbar component\nexport default Navbar;\n","const HOME_DIRECTORY_KEY = 'loraFinderHomeDirectory';\r\n\r\n/**\r\n * Retrieves the stored home directory path from localStorage.\r\n * @returns The stored path string, or null if not set.\r\n */\r\nexport const getHomeDirectory = (): string | null => {\r\n  try {\r\n    return localStorage.getItem(HOME_DIRECTORY_KEY);\r\n  } catch (error) {\r\n    console.error('Error reading home directory from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores the given directory path as the home directory in localStorage.\r\n * @param folderPath - The path to store.\r\n */\r\nexport const setHomeDirectory = (folderPath: string): void => {\r\n  try {\r\n    localStorage.setItem(HOME_DIRECTORY_KEY, folderPath);\r\n  } catch (error) {\r\n    console.error('Error setting home directory in localStorage:', error);\r\n  }\r\n};\r\n","import { motion } from 'framer-motion';\nimport React, { forwardRef, useEffect, useState } from 'react';\nimport { FaHome } from 'react-icons/fa';\nimport { useFolders } from '../hooks/query/useFolders';\nimport styles from '../styles/Sidebar.module.scss';\nimport { getHomeDirectory, setHomeDirectory } from '../utils/settings';\n\n// Define the props interface for the Sidebar component\ninterface SidebarProps {\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n}\n\n// Use forwardRef to allow passing ref to the underlying motion.div\nconst Sidebar = forwardRef<HTMLDivElement, SidebarProps>(\n  (\n    { selectedFolder, onFolderChange },\n    ref // Receive the ref\n  ) => {\n    // Call the hook to fetch folders\n    const { data: folders, isLoading, isError, error } = useFolders();\n    // State to track the current home directory for styling\n    const [currentHomeDir, setCurrentHomeDir] = useState<string | null>(null);\n\n    // Effect to load the home directory on mount\n    useEffect(() => {\n      setCurrentHomeDir(getHomeDirectory());\n    }, []);\n\n    // Handler to set a new home directory\n    const handleSetHome = (folderPath: string, event: React.MouseEvent) => {\n      event.stopPropagation(); // Prevent folder selection when clicking set home\n      setHomeDirectory(folderPath);\n      setCurrentHomeDir(folderPath);\n      console.log('Set home directory:', folderPath);\n    };\n\n    // Render loading state\n    if (isLoading) {\n      return (\n        <motion.div\n          ref={ref}\n          className={`${styles.sidebar} ${styles.loading}`}\n          style={{ opacity: 0 }}\n        >\n          Loading folders...\n        </motion.div>\n      );\n    }\n\n    // Render error state\n    if (isError) {\n      return (\n        <motion.div\n          ref={ref}\n          className={`${styles.sidebar} ${styles.error}`}\n          style={{ opacity: 0 }}\n        >\n          Error: {error?.message || 'Failed to load folders'}\n        </motion.div>\n      );\n    }\n\n    // Render the main sidebar\n    return (\n      // Main sidebar container\n      <motion.div ref={ref} className={styles.sidebar}>\n        <div className={`${styles.sidebarInner} flex flex-col h-full`}>\n          {/* Logo section */}\n          <div className={styles.logo}>Lora Finder</div>\n          {/* Folder list */}\n          <ul className={`${styles.folderList} flex-grow overflow-y-auto`}>\n            {/* Map through folders (from hook) and create buttons for each */}\n            {(folders ?? []).map(folder => (\n              <li\n                key={folder.name}\n                className={`${styles.folderItem} group ${selectedFolder === folder.name ? styles.selectedFolder : ''}`}\n                // Handle folder selection on the list item itself for better structure\n                onClick={() => onFolderChange(folder.name)}\n                role=\"button\" // Add role for accessibility\n                tabIndex={0} // Make it focusable\n                onKeyDown={e => {\n                  if (e.key === 'Enter' || e.key === ' ') onFolderChange(folder.name);\n                }} // Keyboard accessibility\n              >\n                <span className={styles.folderName}>{folder.name}</span>\n                {/* Set Home button is now a sibling, not a child */}\n                <button\n                  onClick={e => handleSetHome(folder.name, e)}\n                  className={`${styles.setHomeButton} ${\n                    folder.name === currentHomeDir\n                      ? styles.isHome\n                      : 'opacity-0 group-hover:opacity-100 focus-within:opacity-100' // Ensure visibility on focus too\n                  }`}\n                  title={`Set ${folder.name} as home directory`}\n                  aria-label={`Set ${folder.name} as home directory`} // Better accessibility\n                  tabIndex={0} // Make sure it's focusable independently\n                >\n                  <FaHome />\n                </button>\n              </li>\n            ))}\n          </ul>\n          {/* Upload button */}\n          <div className=\"p-8 mt-auto\">\n            <button className={`${styles.uploadButton} w-full`}>Upload</button>\n          </div>\n        </div>\n      </motion.div>\n    );\n  }\n);\n\nSidebar.displayName = 'Sidebar'; // Add display name for DevTools\n\n// Export the Sidebar component\nexport default Sidebar;\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getFolders } from '../../lib/api';\r\nimport { FolderInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch the list of available folders using React Query.\r\n *\r\n * @returns The result object from useQuery, containing folder data, loading state, error state, etc.\r\n */\r\nexport function useFolders() {\r\n  return useQuery<FolderInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Stays constant as we expect the same folder list unless invalidated.\r\n    queryKey: ['folders'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getFolders,\r\n    // Optional: Configure staleTime and gcTime if different from defaults\r\n    // staleTime: 1000 * 60 * 10, // e.g., folders stay fresh for 10 mins\r\n  });\r\n}\r\n","// Cache Time-To-Live: Duration in milliseconds for which cached data remains valid\nexport const CACHE_TTL = 600000;\n\n// Maximum upload size: Limit for file uploads in bytes (default is ~1.5GB)\nexport const MAX_UPLOAD_SIZE = 1610612736;\n\n// Supported image formats: List of file extensions for allowed image uploads\nexport const SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif'];\n\n// API base URL: Root URL for API endpoints\nexport const API_BASE_URL = 'http://localhost:3000/api';\n\n// Server port: Port number on which the server will listen\nexport const PORT = 3000;\n\n// Host: Hostname or IP address on which the server will run\nexport const HOST = 'localhost';\n\n// Custom properties for dynamic styling\nexport const CUSTOM_PROPERTIES = {\n  SCROLL_Y: '--scroll-y',\n  MOUSE_X: '--mouse-x',\n  MOUSE_Y: '--mouse-y',\n};\n\n// Default values for custom properties\nexport const DEFAULT_CUSTOM_PROPERTY_VALUES = {\n  [CUSTOM_PROPERTIES.SCROLL_Y]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_X]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_Y]: '0px',\n};\n","import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { ColorContext } from '../contexts/ColorContext'; // Import ColorContext\nimport styles from '../styles/ParticleBackground.module.scss'; // Reuse or create new styles\n\n// Convert hex color string to vec3 [r, g, b] (normalized 0-1)\nconst hexToVec3 = (hex: string): [number, number, number] => {\n  let r = 0,\n    g = 0,\n    b = 0;\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(hex[1] + hex[1], 16);\n    g = parseInt(hex[2] + hex[2], 16);\n    b = parseInt(hex[3] + hex[3], 16);\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(hex[1] + hex[2], 16);\n    g = parseInt(hex[3] + hex[4], 16);\n    b = parseInt(hex[5] + hex[6], 16);\n  }\n  return [r / 255, g / 255, b / 255];\n};\n\n// Linear interpolation function for arrays (like colors)\nconst lerpArray = (start: number[], end: number[], t: number): number[] => {\n  return start.map((val, i) => val + (end[i] - val) * t);\n};\n\n// Linear interpolation for single values\nconst lerp = (start: number, end: number, t: number): number => {\n  return start + (end - start) * t;\n};\n\n// --- WebGL Shaders (Refined for Aura Effect) ---\n\n// Vertex Shader (Remains the same - simple quad pass-through)\nconst vertexShaderSource = `\n  precision mediump float;\n  attribute vec2 a_position; // Vertex position (-1 to 1)\n  varying vec2 v_uv;         // Pass UV coordinates (0 to 1) to fragment shader\n\n  void main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_uv = (a_position + 1.0) * 0.5; // Convert clip space to UV space\n    v_uv.y = 1.0 - v_uv.y; // Flip Y for texture/canvas coordinate system\n  }\n`;\n\n// Fragment Shader: Updated with noise functions for a more organic background\nconst fragmentShaderSource = `\n  precision mediump float;\n  varying vec2 v_uv; // UV coordinates from vertex shader\n\n  uniform vec2 u_resolution;    // Canvas resolution\n  uniform float u_time;        // Time for animations\n  uniform vec3 u_colorTarget1;  // Base color 1\n  uniform vec3 u_colorTarget2;  // Base color 2\n  uniform float u_colorMixFactor; // Mix factor for base colors\n\n  // Hover state uniforms\n  uniform bool u_isHovering;\n  uniform vec2 u_hoverPos;      // Normalized hover position (0-1)\n  uniform vec3 u_hoverColor;    // Optional: Color associated with hover\n\n  // --- Noise Functions ---\n  // Simple pseudo-random number generator\n  float random (vec2 st) {\n      // Adjusted seed based on example, can be tweaked\n      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n  }\n\n  // Basic Value Noise function\n  float noise (vec2 st) {\n      vec2 i = floor(st); // Integer part\n      vec2 f = fract(st); // Fractional part\n\n      // Get random values for the 4 corners surrounding the point\n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n\n      // Smoothly interpolate between the corner values (smoothstep)\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      // Interpolate horizontally, then vertically\n      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n  }\n\n  // Fractional Brownian Motion (fBm) - layering noise\n  #define OCTAVES 4 // Number of noise layers (adjust for detail/performance)\n  float fbm (vec2 st) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 0.0;\n      // Loop through octaves, adding noise at different frequencies/amplitudes\n      for (int i = 0; i < OCTAVES; i++) {\n          value += amplitude * noise(st);\n          st *= 2.0; // Double frequency for next octave\n          amplitude *= 0.5; // Halve amplitude for next octave\n      }\n      return value;\n  }\n  // --- End Noise Functions ---\n\n  // Function to calculate distance from hover point (same as before)\n  float getHoverDist(vec2 pos) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    vec2 diff = pos - u_hoverPos;\n    diff.x *= aspectRatio;\n    return distance(vec2(0.0), diff);\n  }\n\n  void main() {\n    // --- Calculate Base Aura Color using Noise ---\n    // Scale UV and add time for animation. Adjust scale (e.g., * 3.0) for noise detail.\n    vec2 noisyCoord = v_uv * 2.5 + vec2(u_time * 0.02, u_time * 0.03); // Slow movement\n    float noisePattern = fbm(noisyCoord);\n\n    // Base color blend - mix between target colors\n    vec3 baseColor = mix(u_colorTarget1, u_colorTarget2, u_colorMixFactor);\n\n    // Modulate the base color blend using the noise pattern\n    // Mix based on noise value AND vertical position for variety\n    vec3 auraColor = mix(baseColor, mix(u_colorTarget1, u_colorTarget2, v_uv.y * 0.8 + 0.1), noisePattern * 0.6);\n    // Add subtle contrast/brightness variation based on noise\n    auraColor *= (0.9 + noisePattern * 0.2);\n\n    // --- Hover Effect (Applied on top of aura) ---\n    vec3 finalColor = auraColor;\n    if (u_isHovering) {\n      float dist = getHoverDist(v_uv);\n      // Ripple/glow effect - use smoothstep for soft edges\n      float hoverIntensity = smoothstep(0.20, 0.0, dist); // Increased radius slightly\n\n      // Make the glow slightly colored (e.g., whitish or based on u_hoverColor if available)\n      vec3 glowColor = vec3(0.8, 0.8, 0.9); // Whitish glow\n      // Optionally use u_hoverColor: mix(glowColor, u_hoverColor, 0.5)\n\n      // Additive blend for glow, stronger near center\n      finalColor += glowColor * hoverIntensity * 0.6; // Adjust intensity multiplier\n\n      // Optional: Slight displacement/warp effect (more complex)\n      // vec2 displacement = normalize(v_uv - u_hoverPos) * hoverIntensity * 0.01;\n      // Recalculate noise/color at v_uv - displacement ? (performance cost)\n    }\n\n    // Ensure color values stay within valid range\n    gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n  }\n`;\n\n// --- Component ---\nconst AuraBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const bufferRef = useRef<WebGLBuffer | null>(null); // Single buffer for a quad\n  const attribLocationsRef = useRef<{ [key: string]: number }>({});\n  const uniformLocationsRef = useRef<{ [key: string]: WebGLUniformLocation | null }>({});\n  const animationFrameRef = useRef<number>();\n  const { dominantColors, hoverState } = useContext(ColorContext);\n\n  // Refs for animated uniform values (colors and hover state)\n  const animatedColor1 = useRef(hexToVec3(dominantColors[0] || '#041024'));\n  const animatedColor2 = useRef(hexToVec3(dominantColors[1] || dominantColors[0] || '#041024'));\n  const animatedMixFactor = useRef(dominantColors.length > 1 ? 1.0 : 0.0);\n  const animatedHoverPos = useRef<[number, number] | null>(\n    hoverState.position ? [hoverState.position.x, hoverState.position.y] : null\n  );\n  const animatedIsHovering = useRef(hoverState.isHovering ? 1.0 : 0.0); // Use float for smooth transition\n\n  // --- WebGL Helper Functions ---\n  const createShader = useCallback(\n    (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\n          `Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`,\n          gl.getShaderInfoLog(shader)\n        );\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    },\n    []\n  );\n\n  const createProgram = useCallback(\n    (\n      gl: WebGLRenderingContext,\n      vertexShader: WebGLShader,\n      fragmentShader: WebGLShader\n    ): WebGLProgram | null => {\n      const program = gl.createProgram();\n      if (!program) return null;\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program link error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return null;\n      }\n      return program;\n    },\n    []\n  );\n\n  // --- Animation Loop ---\n  const renderLoop = useCallback(\n    (time: number) => {\n      const gl = glRef.current;\n      const program = programRef.current;\n      if (!gl || !program) {\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\n        return;\n      }\n      const timeSeconds = time / 1000.0;\n\n      // --- Smooth Animation Logic (Lerping) ---\n      const lerpSpeed = 0.08; // Adjust for desired transition speed\n\n      // Animate Colors\n      const targetColor1 = hexToVec3(dominantColors[0] || '#041024');\n      const targetColor2 = hexToVec3(dominantColors[1] || dominantColors[0] || '#041024');\n      const targetMix = dominantColors.length > 1 ? 1.0 : 0.0;\n      animatedColor1.current = lerpArray(animatedColor1.current, targetColor1, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedColor2.current = lerpArray(animatedColor2.current, targetColor2, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedMixFactor.current = lerp(animatedMixFactor.current, targetMix, lerpSpeed);\n\n      // Animate Hover State\n      const targetIsHovering = hoverState.isHovering ? 1.0 : 0.0;\n      animatedIsHovering.current = lerp(\n        animatedIsHovering.current,\n        targetIsHovering,\n        lerpSpeed * 2\n      ); // Faster hover transition\n\n      if (hoverState.isHovering && hoverState.position) {\n        const targetPos: [number, number] = [hoverState.position.x, hoverState.position.y];\n        if (!animatedHoverPos.current) {\n          animatedHoverPos.current = targetPos; // Snap if starting from null\n        } else {\n          animatedHoverPos.current = lerpArray(\n            animatedHoverPos.current,\n            targetPos,\n            lerpSpeed * 2\n          ) as [number, number];\n        }\n      } else {\n        // Optionally, let the hover position fade out or just keep the last known position\n        // For now, we'll just use the latest position when hovering is true\n      }\n\n      // --- WebGL Rendering ---\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      // No need to clear if drawing a full-screen quad that covers everything\n      // gl.clearColor(0, 0, 0, 0);\n      // gl.clear(gl.COLOR_BUFFER_BIT);\n\n      // Log context state and calculated animation values\n      // console.log('[AuraBackground Loop] Context HoverState:', hoverState);\n      // console.log('[AuraBackground Loop] Animated Hover:', { isHovering: animatedIsHovering.current, pos: animatedHoverPos.current });\n\n      gl.useProgram(program);\n\n      // Bind the quad buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n      const posLocation = attribLocationsRef.current.position;\n      if (posLocation !== -1) {\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(posLocation);\n      }\n\n      // Set Uniforms\n      gl.uniform2f(uniformLocationsRef.current.resolution, gl.canvas.width, gl.canvas.height);\n      gl.uniform1f(uniformLocationsRef.current.time, timeSeconds);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget1, animatedColor1.current);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget2, animatedColor2.current);\n      gl.uniform1f(uniformLocationsRef.current.colorMixFactor, animatedMixFactor.current);\n\n      // Hover Uniforms\n      gl.uniform1f(\n        uniformLocationsRef.current.isHovering,\n        animatedIsHovering.current > 0.01 ? 1.0 : 0.0\n      ); // Use threshold for bool\n      if (animatedHoverPos.current) {\n        gl.uniform2fv(uniformLocationsRef.current.hoverPos, animatedHoverPos.current);\n      }\n      // gl.uniform3fv(uniformLocationsRef.current.hoverColor, hoverState.color ? hexToVec3(hoverState.color) : [0,0,0]); // TODO: Add hover color logic\n\n      // Draw the quad (2 triangles)\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      animationFrameRef.current = requestAnimationFrame(renderLoop);\n    },\n    [dominantColors, hoverState]\n  ); // Dependencies for lerp targets\n\n  // --- Initialization Effect ---\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    if (!canvasElement) return;\n\n    const gl = canvasElement.getContext('webgl', { alpha: false, antialias: true }); // alpha: false maybe faster? antialias: true for smoother gradients\n    if (!gl) {\n      console.error('WebGL not supported or context creation failed.');\n      return;\n    }\n    glRef.current = gl;\n\n    // Compile shaders\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!vertexShader || !fragmentShader) return;\n\n    // Link program\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    if (!program) return;\n    programRef.current = program;\n\n    // Detach and delete shaders after linking\n    gl.detachShader(program, vertexShader);\n    gl.detachShader(program, fragmentShader);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    // --- Create Buffer for Fullscreen Quad ---\n    // Vertices for two triangles covering the screen (-1 to 1)\n    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n    bufferRef.current = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    // --- Look up locations ---\n    attribLocationsRef.current.position = gl.getAttribLocation(program, 'a_position');\n    uniformLocationsRef.current.resolution = gl.getUniformLocation(program, 'u_resolution');\n    uniformLocationsRef.current.time = gl.getUniformLocation(program, 'u_time');\n    uniformLocationsRef.current.colorTarget1 = gl.getUniformLocation(program, 'u_colorTarget1');\n    uniformLocationsRef.current.colorTarget2 = gl.getUniformLocation(program, 'u_colorTarget2');\n    uniformLocationsRef.current.colorMixFactor = gl.getUniformLocation(program, 'u_colorMixFactor');\n    uniformLocationsRef.current.isHovering = gl.getUniformLocation(program, 'u_isHovering');\n    uniformLocationsRef.current.hoverPos = gl.getUniformLocation(program, 'u_hoverPos');\n    uniformLocationsRef.current.hoverColor = gl.getUniformLocation(program, 'u_hoverColor');\n\n    // --- Resize Handling ---\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!entries || entries.length === 0) return;\n      const { width, height } = entries[0].contentRect;\n      if (glRef.current) {\n        glRef.current.canvas.width = width;\n        glRef.current.canvas.height = height;\n      }\n    });\n    resizeObserver.observe(canvasElement);\n\n    // Start render loop\n    animationFrameRef.current = requestAnimationFrame(renderLoop);\n\n    // --- Cleanup ---\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      resizeObserver.disconnect();\n\n      const currentGl = glRef.current;\n      if (currentGl) {\n        if (bufferRef.current) currentGl.deleteBuffer(bufferRef.current);\n        if (programRef.current) currentGl.deleteProgram(programRef.current);\n      }\n      glRef.current = null;\n      programRef.current = null;\n      bufferRef.current = null;\n    };\n    // Add renderLoop to dependencies if its definition relies on changing props/state from outside\n  }, [createShader, createProgram, renderLoop]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={styles.particleBackground} // Reuse style or create AuraBackground.module.scss\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        pointerEvents: 'none',\n        zIndex: -1, // Keep behind content\n        // backgroundColor: '#041024', // Optional fallback bg\n      }}\n    />\n  );\n};\n\nexport default React.memo(AuraBackground);\n","import React, { forwardRef } from 'react';\nimport { ViewMode } from '../types/index.js';\nimport Navbar from './Navbar.js';\nimport Sidebar from './Sidebar.js';\n// import { getImages } from '../lib/api.js'; // Removed: Data fetching moved to hooks/ImageFeed\nimport gsap from 'gsap';\nimport { ScrollToPlugin } from 'gsap/ScrollToPlugin';\nimport { ColorProvider } from '../contexts/ColorContext';\nimport { useCustomProperties } from '../hooks/useCustomProperties';\n// Import the new AuraBackground\nimport AuraBackground from './AuraBackground.js';\n// Remove ParticleBackground import\n// import ParticleBackground from './ParticleBackground.js';\n\ngsap.registerPlugin(ScrollToPlugin);\n\n// Define the props interface for the Layout component\ninterface LayoutProps {\n  children: React.ReactNode;\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n  mainRef: React.RefObject<HTMLElement>;\n  navbarRef?: React.Ref<HTMLDivElement>;\n  sidebarRef?: React.Ref<HTMLDivElement>;\n  contentAreaRef?: React.Ref<HTMLDivElement>;\n}\n\n// Define the Layout component\nconst Layout = forwardRef<HTMLDivElement, LayoutProps>(\n  (\n    {\n      children,\n      selectedFolder,\n      onFolderChange,\n      onSearch,\n      zoom,\n      onZoomChange,\n      isGrouped,\n      onGroupToggle,\n      viewMode,\n      onViewModeChange,\n      mainRef,\n      navbarRef,\n      sidebarRef,\n      contentAreaRef,\n    },\n    ref\n  ) => {\n    useCustomProperties();\n\n    // State variables for managing images, loading state, error, and search query\n    // const [images, setImages] = useState<ImageInfo[]>([]); // Removed: Managed by react-query in ImageFeed\n    // const [isLoading, setIsLoading] = useState(false); // Removed\n    // const [error, setError] = useState<string | null>(null); // Removed\n    // const [searchQuery, setSearchQuery] = useState(''); // Kept for now, search logic needs update\n\n    // Effect hook to fetch images when the selected folder changes\n    // useEffect(() => {\n    //   const fetchImages = async () => {\n    //     setIsLoading(true);\n    //     setError(null);\n    //     try {\n    //       const fetchedImages = await getImages(selectedFolder);\n    //       setImages(fetchedImages || []); // Ensure we always set an array\n    //     } catch (err: any) {\n    //       const errorMessage = err.message || 'Failed to fetch images';\n    //       setError(errorMessage);\n    //       setImages([]); // Set empty array on error\n    //       console.error('Error fetching images:', err);\n    //     } finally {\n    //       setIsLoading(false);\n    //     }\n    //   };\n\n    //   if (selectedFolder) {\n    //     fetchImages();\n    //   } else {\n    //     setImages([]);\n    //     setError('No folder selected');\n    //   }\n    // }, [selectedFolder]); // Removed: Data fetching moved to hooks/ImageFeed\n\n    // Handler for search functionality\n    const handleSearch = (query: string) => {\n      // setSearchQuery(query);\n      onSearch(query); // Propagate search up if needed\n    };\n\n    // Handler for when image upload is complete\n    // const handleUploadComplete = () => {\n    //   // Refetch images after upload\n    //   // This logic needs to be replaced with query invalidation\n    //   // e.g., using queryClient.invalidateQueries(['images', selectedFolder]);\n    //   const fetchImages = async () => {\n    //     setIsLoading(true);\n    //     setError(null);\n    //     try {\n    //       const fetchedImages = await getImages(selectedFolder);\n    //       setImages(fetchedImages);\n    //     } catch (err) {\n    //       setError('Failed to fetch images');\n    //       console.error(err);\n    //     } finally {\n    //       setIsLoading(false);\n    //     }\n    //   };\n\n    //   fetchImages();\n    // }; // Removed: Needs replacement with react-query invalidation\n\n    // Render the layout structure\n    return (\n      <div ref={ref} className=\"flex flex-col h-screen relative bg-transparent\">\n        <ColorProvider>\n          <div className=\"gradient-overlay\"></div>\n          {/* Use AuraBackground instead of ParticleBackground */}\n          <AuraBackground />\n          {/* <ParticleBackground /> */}\n          <Navbar\n            ref={navbarRef}\n            onSearch={handleSearch}\n            zoom={zoom}\n            onZoomChange={onZoomChange}\n            isGrouped={isGrouped}\n            onGroupToggle={onGroupToggle}\n            viewMode={viewMode}\n            onViewModeChange={onViewModeChange}\n          />\n          <div className=\"flex flex-1 overflow-hidden\">\n            <Sidebar\n              ref={sidebarRef}\n              selectedFolder={selectedFolder}\n              onFolderChange={onFolderChange}\n            />\n            <main ref={mainRef} className=\"flex-1 overflow-auto p-4 relative bg-transparent\">\n              {contentAreaRef ? (\n                <div ref={contentAreaRef} className=\"relative z-10\">\n                  {children}\n                </div>\n              ) : (\n                <div className=\"relative z-10\">{children}</div>\n              )}\n            </main>\n          </div>\n        </ColorProvider>\n      </div>\n    );\n  }\n);\n\nLayout.displayName = 'Layout';\n\nexport default Layout;\n","import { useEffect } from 'react';\nimport { CUSTOM_PROPERTIES, DEFAULT_CUSTOM_PROPERTY_VALUES } from '../utils/constants';\n\nexport function useCustomProperties() {\n  useEffect(() => {\n    function updateCustomProperties(e: MouseEvent) {\n      const mouseX = e.clientX;\n      const mouseY = e.clientY;\n\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_X, `${mouseX}px`);\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_Y, `${mouseY}px`);\n    }\n\n    function updateScrollProperty() {\n      const scrollY = window.scrollY;\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.SCROLL_Y, `${scrollY}px`);\n    }\n\n    // Set default values\n    Object.entries(DEFAULT_CUSTOM_PROPERTY_VALUES).forEach(([property, value]) => {\n      document.documentElement.style.setProperty(property, value);\n    });\n\n    window.addEventListener('scroll', updateScrollProperty);\n    document.addEventListener('mousemove', updateCustomProperties);\n    document.addEventListener('click', updateCustomProperties);\n\n    return () => {\n      window.removeEventListener('scroll', updateScrollProperty);\n      document.removeEventListener('mousemove', updateCustomProperties);\n      document.removeEventListener('click', updateCustomProperties);\n    };\n  }, []);\n}\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getImages } from '../../lib/api';\r\nimport { ImageInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch images for a specific folder using React Query.\r\n *\r\n * @param {string} folder - The name of the folder to fetch images from.\r\n * @returns The result object from useQuery, containing image data, loading state, error state, etc.\r\n */\r\nexport function useFolderImages(folder: string) {\r\n  return useQuery<ImageInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Includes the folder name so data is cached per folder.\r\n    queryKey: ['images', folder],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: () => getImages(folder),\r\n    // Enabled option: prevents the query from running if the folder is falsy (e.g., empty string, null, undefined).\r\n    enabled: !!folder,\r\n    // Use placeholderData to keep displaying the previous data while the new data is loading.\r\n    placeholderData: previousData => previousData,\r\n  });\r\n}\r\n","import * as Comlink from 'comlink'; // Import Comlink namespace for releaseProxy\nimport { Remote, wrap } from 'comlink'; // Import wrap, Remote, and releaseProxy\nimport { IDBPDatabase, openDB } from 'idb';\nimport PQueue from 'p-queue'; // Import p-queue\nimport { ImageInfo, ImageProcessorWorkerAPI, ProcessedImageCacheEntry } from '../types/index.js'; // Import the API type\n// Import the context update type\nimport { ProcessedImageUpdate } from '../contexts/ImageProcessingContext';\n\n// Remove the message interface - no longer needed\n// interface ImageProcessorMessage { ... }\n\nconst DB_NAME = 'image-processor-cache';\nconst STORE_NAME = 'processed-images';\nconst DB_VERSION = 1;\n\ninterface ImageProcessorOptions {\n  onImageProcessed?: (\n    id: string,\n    quality: 'low' | 'high',\n    imageUrl: string,\n    width: number,\n    height: number\n  ) => void;\n  onError?: (id: string, error: string) => void;\n  concurrency?: number; // Allow overriding concurrency\n}\n\n// --- Cache Management ---\nlet dbPromise: Promise<IDBPDatabase> | null = null;\n\nconst getDb = (): Promise<IDBPDatabase> => {\n  if (!dbPromise) {\n    dbPromise = openDB(DB_NAME, DB_VERSION, {\n      upgrade(db) {\n        if (!db.objectStoreNames.contains(STORE_NAME)) {\n          db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n        }\n      },\n    });\n  }\n  return dbPromise;\n};\n\nclass ImageProcessor {\n  private worker: Worker;\n  private proxy: Remote<ImageProcessorWorkerAPI>; // Store the Comlink proxy\n  private queue: PQueue; // Add queue instance\n  private onError?: (id: string, error: string) => void;\n  // Store AbortControllers for active requests\n  private activeRequests = new Map<string, AbortController>();\n  // Add property to hold the publisher function\n  private publisher: ((data: ProcessedImageUpdate) => void) | null = null;\n\n  constructor(options?: ImageProcessorOptions) {\n    this.onError = options?.onError;\n\n    // Initialize the queue\n    const concurrency =\n      options?.concurrency ?? Math.max(1, (navigator.hardwareConcurrency || 4) - 1);\n    this.queue = new PQueue({ concurrency });\n    console.log(`ImageProcessor: Initialized queue with concurrency ${concurrency}`);\n\n    // Initialize the worker and wrap it with Comlink\n    this.worker = new Worker(new URL('./imageProcessorWorker.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n    this.proxy = wrap<ImageProcessorWorkerAPI>(this.worker);\n\n    // Remove the onmessage handler - results come via promise\n    // this.worker.onmessage = (event: MessageEvent<ImageProcessorMessage>) => {\n    //   this.handleWorkerMessage(event);\n    // };\n\n    this.worker.onerror = error => {\n      console.error('Unhandled error in ImageProcessorWorker:', error);\n      // This usually indicates a setup or non-recoverable worker error\n      // Consider notifying the UI about a general failure\n      this.onError?.('WORKER_FATAL', error.message || 'Worker failed');\n    };\n\n    this.initializeCacheCheck();\n  }\n\n  private async initializeCacheCheck() {\n    try {\n      await this.checkCacheForStaleBlobs();\n    } catch (error) {\n      console.error('Failed initial cache check:', error);\n    }\n  }\n\n  // Method to set the publisher function after initialization\n  public setPublisher(publisher: (data: ProcessedImageUpdate) => void) {\n    console.log('[ImageProcessor] Publisher function set.');\n    this.publisher = publisher;\n  }\n\n  // --- Cache Management Methods ---\n  private async getCacheEntry(id: string): Promise<ProcessedImageCacheEntry | undefined> {\n    const db = await getDb();\n    return db.get(STORE_NAME, id);\n  }\n\n  private async setCacheEntry(entry: ProcessedImageCacheEntry): Promise<void> {\n    const db = await getDb();\n    await db.put(STORE_NAME, entry);\n  }\n\n  private async deleteCacheEntry(id: string): Promise<void> {\n    const db = await getDb();\n    await db.delete(STORE_NAME, id);\n  }\n\n  private async checkCacheForStaleBlobs() {\n    console.log('ImageProcessor: Checking cache for stale blob URLs...');\n    const db = await getDb();\n    const allEntries = await db.getAll(STORE_NAME);\n    let staleCount = 0;\n\n    for (const entry of allEntries) {\n      let shouldDelete = false;\n      try {\n        // Check low-res blob\n        if (entry.lowResUrl && entry.lowResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.lowResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale low-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true; // Mark for deletion if blob is invalid\n          }\n        }\n        // Check high-res blob\n        if (entry.highResUrl && entry.highResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.highResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale high-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true;\n          }\n        }\n      } catch (e) {\n        console.warn(`Error checking blob URL for ${entry.id}. Assuming stale.`, e);\n        shouldDelete = true;\n      }\n\n      if (shouldDelete) {\n        await this.deleteCacheEntry(entry.id);\n        staleCount++;\n        // console.log(`ImageProcessor: Deleted stale cache entry for ${entry.id}`);\n      }\n    }\n\n    if (staleCount > 0) {\n      console.log(`ImageProcessor: Removed ${staleCount} stale cache entries.`);\n    } else {\n      console.log('ImageProcessor: No stale blob URLs found in cache.');\n    }\n  }\n\n  // --- Public Processing Methods (using Comlink) ---\n\n  async processImage(image: ImageInfo): Promise<void> {\n    const { id, src, width, height } = image;\n\n    if (!id || !src || !width || !height) {\n      console.error('Invalid image data provided to processImage:', image);\n      this.onError?.(id || 'unknown', 'Invalid image data');\n      return;\n    }\n\n    // Check cache immediately before queueing\n    try {\n      const cachedEntry = await this.getCacheEntry(id);\n      const lowResMatches =\n        cachedEntry?.lowResWidth === Math.round(width / 4) &&\n        cachedEntry?.lowResHeight === Math.round(height / 4);\n      const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n      if (cachedEntry?.lowResUrl && cachedEntry?.highResUrl && lowResMatches && highResMatches) {\n        console.log(`ImageProcessor: Cache hit for ${id} (pre-queue). Skipping queue.`);\n        // Publish low-res from cache\n        this.publisher?.({\n          id,\n          quality: 'low',\n          imageUrl: cachedEntry.lowResUrl,\n          width: cachedEntry.lowResWidth!,\n          height: cachedEntry.lowResHeight!,\n        });\n        // Publish high-res from cache\n        this.publisher?.({\n          id,\n          quality: 'high',\n          imageUrl: cachedEntry.highResUrl,\n          width: cachedEntry.width!,\n          height: cachedEntry.height!,\n        });\n        return; // Already cached, no need to queue\n      }\n    } catch (cacheError) {\n      console.error(`ImageProcessor: Error checking cache pre-queue for ${id}:`, cacheError);\n      // Proceed to queue anyway?\n    }\n\n    // Check if already actively being processed or queued\n    if (this.activeRequests.has(id)) {\n      console.log(`ImageProcessor: Request for ${id} is already active/queued. Skipping.`);\n      return;\n    }\n\n    // Create controller and add to active requests *before* queueing\n    const controller = new AbortController();\n    this.activeRequests.set(id, controller);\n\n    // Add the processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued task for ${id}. Queue size: ${this.queue.size}`\n        );\n        let createdBitmap: ImageBitmap | null = null;\n        try {\n          // Re-check cache inside queue in case it was populated while waiting\n          const cachedEntry = await this.getCacheEntry(id);\n          const lowResMatches =\n            cachedEntry?.lowResWidth === Math.round(width / 4) &&\n            cachedEntry?.lowResHeight === Math.round(height / 4);\n          const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n          if (\n            cachedEntry?.lowResUrl &&\n            cachedEntry?.highResUrl &&\n            lowResMatches &&\n            highResMatches\n          ) {\n            console.log(`ImageProcessor: Cache hit for ${id} (in-queue). Skipping processing.`);\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n            // Publish high-res from cache\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: cachedEntry.highResUrl,\n              width: cachedEntry.width!,\n              height: cachedEntry.height!,\n            });\n            return; // Exit queued task\n          }\n\n          // Check signal before potentially long operations\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before processing', 'AbortError');\n\n          // --- Prepare / Fetch Bitmap (same logic as before) ---\n          let reason = 'No cache entry';\n          let needsProcessing = true;\n\n          if (cachedEntry && (!lowResMatches || !highResMatches)) {\n            reason = `Cache found for ${id} but dimensions mismatch. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          } else if (cachedEntry?.lowResUrl && lowResMatches) {\n            reason = `Low-res cache hit for ${id}, processing for high-res.`;\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n          } else if (cachedEntry) {\n            reason = `Inconsistent cache state for ${id}. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          }\n\n          console.log(`ImageProcessor: Fetching image ${id} to create ImageBitmap (queued).`);\n          try {\n            const response = await fetch(src, { signal: controller.signal });\n            if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);\n            const blob = await response.blob();\n            if (controller.signal.aborted) throw new DOMException('Aborted', 'AbortError');\n            createdBitmap = await createImageBitmap(blob);\n          } catch (fetchError: any) {\n            if (fetchError.name !== 'AbortError') {\n              console.error(\n                `ImageProcessor: Error fetching/creating bitmap for ${id} (queued):`,\n                fetchError\n              );\n              this.onError?.(id, fetchError.message || 'Failed to load image data');\n            }\n            // Rethrow to be caught by outer try/catch\n            throw fetchError;\n          }\n\n          // --- Call Worker ---\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before worker call', 'AbortError');\n          console.log(\n            `ImageProcessor: Sending image ${id} to worker via Comlink (queued). Reason: ${reason}`\n          );\n          const result = await this.proxy.processImage(\n            Comlink.transfer(\n              { id, imageBitmap: createdBitmap, width, height /* signal: controller.signal */ },\n              [createdBitmap]\n            )\n          );\n          createdBitmap = null; // Nullify after transfer\n\n          // --- Process Result ---\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Processing for ${id} aborted after worker call (queued).`);\n            if (result.lowResUrl) URL.revokeObjectURL(result.lowResUrl);\n            if (result.highResUrl) URL.revokeObjectURL(result.highResUrl);\n            return;\n          }\n\n          console.log(`ImageProcessor: Received results for ${id} from worker (queued).`);\n          const finalEntry: ProcessedImageCacheEntry = {\n            ...((await this.getCacheEntry(id)) || { id }),\n            id,\n            lowResUrl: result.lowResUrl ?? cachedEntry?.lowResUrl,\n            lowResWidth: result.lowResUrl ? Math.round(width / 4) : cachedEntry?.lowResWidth,\n            lowResHeight: result.lowResUrl ? Math.round(height / 4) : cachedEntry?.lowResHeight,\n            highResUrl: result.highResUrl,\n            width: result.highResUrl ? width : cachedEntry?.width,\n            height: result.highResUrl ? height : cachedEntry?.height,\n            timestamp: Date.now(),\n          };\n\n          await this.setCacheEntry(finalEntry);\n\n          // Publish results using the publisher function\n          if (result.lowResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: finalEntry.lowResUrl!,\n              width: finalEntry.lowResWidth!,\n              height: finalEntry.lowResHeight!,\n            });\n          }\n          if (result.highResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: finalEntry.highResUrl!,\n              width: finalEntry.width!,\n              height: finalEntry.height!,\n            });\n          }\n        } catch (error: any) {\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued task for ${id} aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error during queued processing for ${id}:`, error);\n            this.onError?.(id, error.message || 'Queued processing failed');\n          }\n        } finally {\n          if (createdBitmap) {\n            try {\n              createdBitmap.close();\n            } catch (e) {\n              console.warn(`Error closing untransferred bitmap for ${id} (queued):`, e);\n            }\n          }\n          // Remove from active requests only when the queued task finishes/errors/aborts\n          this.activeRequests.delete(id);\n          console.log(\n            `ImageProcessor: Finished queued task for ${id}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself (rare)\n        console.error(`ImageProcessor: Error adding task to queue for ${id}:`, error);\n        this.activeRequests.delete(id); // Ensure cleanup if add fails\n        this.onError?.(id, error.message || 'Failed to queue task');\n      });\n  }\n\n  async processBatch(images: ImageInfo[]): Promise<void> {\n    const batchId = `batch-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\n    // Check if a batch request is already active/queued (using a placeholder ID structure)\n    // This simple check might not be sufficient if overlapping batches are possible\n    if (this.activeRequests.has(batchId)) {\n      // Use generated batchId for tracking\n      console.log(\n        `ImageProcessor: Batch request ${batchId} appears to be already active/queued. Skipping.`\n      );\n      return;\n    }\n\n    const controller = new AbortController();\n    this.activeRequests.set(batchId, controller);\n\n    // Add batch processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued batch task ${batchId}. Queue size: ${this.queue.size}`\n        );\n        const imagesToProcess: Array<{\n          id: string;\n          imageBitmap: ImageBitmap;\n          width: number;\n          height: number;\n        }> = [];\n        const transferList: ImageBitmap[] = [];\n        const preCheckPromises: Promise<void>[] = [];\n        const createdBitmaps: ImageBitmap[] = [];\n        let batchError: Error | null = null; // Track error within the queued task\n\n        try {\n          console.log(\n            `ImageProcessor: Starting batch preparation for ${images.length} images (queued). Batch ID: ${batchId}`\n          );\n\n          // --- Pre-check Cache and Fetch Bitmaps (inside queue task) ---\n          for (const image of images) {\n            const { id, src, width, height } = image;\n            if (!id || !src || !width || !height) {\n              console.error('Invalid image data in batch (queued):', image);\n              this.onError?.(id || 'unknown-batch', 'Invalid image data in batch');\n              continue;\n            }\n\n            preCheckPromises.push(\n              (async () => {\n                if (controller.signal.aborted) return;\n                let localBitmap: ImageBitmap | null = null;\n                try {\n                  const cachedEntry = await this.getCacheEntry(id);\n                  const lowResMatches =\n                    cachedEntry?.lowResWidth === Math.round(width / 4) &&\n                    cachedEntry?.lowResHeight === Math.round(height / 4);\n                  const highResMatches =\n                    cachedEntry?.width === width && cachedEntry?.height === height;\n\n                  if (\n                    cachedEntry?.lowResUrl &&\n                    cachedEntry?.highResUrl &&\n                    lowResMatches &&\n                    highResMatches\n                  ) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                    // Publish high-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'high',\n                      imageUrl: cachedEntry.highResUrl,\n                      width: cachedEntry.width!,\n                      height: cachedEntry.height!,\n                    });\n                    return;\n                  }\n\n                  if (cachedEntry && (!lowResMatches || !highResMatches)) {\n                    if (controller.signal.aborted) return;\n                    console.log(\n                      `ImageProcessor: Clearing mismatched cache for batch item ${id} (queued)`\n                    );\n                    await this.deleteCacheEntry(id);\n                  }\n\n                  if (controller.signal.aborted) return;\n                  console.log(`ImageProcessor: Fetching batch item ${id} (queued)`);\n                  const response = await fetch(src, { signal: controller.signal });\n                  if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);\n                  const blob = await response.blob();\n                  if (controller.signal.aborted) return;\n                  localBitmap = await createImageBitmap(blob);\n                  createdBitmaps.push(localBitmap);\n\n                  imagesToProcess.push({ id, imageBitmap: localBitmap, width, height });\n                  transferList.push(localBitmap);\n\n                  if (cachedEntry?.lowResUrl && lowResMatches) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                  }\n                } catch (error: any) {\n                  if (localBitmap) {\n                    try {\n                      localBitmap.close();\n                    } catch {}\n                    const index = createdBitmaps.indexOf(localBitmap);\n                    if (index > -1) createdBitmaps.splice(index, 1);\n                  }\n                  if (error.name !== 'AbortError') {\n                    console.error(\n                      `ImageProcessor: Error preparing batch item ${id} (queued):`,\n                      error\n                    );\n                    this.onError?.(id, error.message || 'Batch item preparation failed');\n                  } else {\n                    // Re-throw abort error to stop Promise.all\n                    throw error;\n                  }\n                }\n              })()\n            );\n          }\n\n          // Wait for preparation inside the queue task\n          await Promise.all(preCheckPromises);\n\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Batch ${batchId} aborted during preparation (queued).`);\n            throw new DOMException('Batch preparation aborted', 'AbortError');\n          }\n\n          // --- Call Worker ---\n          if (imagesToProcess.length > 0) {\n            console.log(\n              `ImageProcessor: Sending batch ${batchId} of ${imagesToProcess.length} images to worker via Comlink (queued).`\n            );\n            const batchResults = await this.proxy.processBatch(\n              Comlink.transfer(\n                { images: imagesToProcess /* signal: controller.signal */ },\n                transferList\n              )\n            );\n\n            // --- Process Results ---\n            if (controller.signal.aborted) {\n              console.log(\n                `ImageProcessor: Batch ${batchId} aborted after worker completed (queued).`\n              );\n              batchResults.forEach(r => {\n                if (r.lowResUrl) URL.revokeObjectURL(r.lowResUrl);\n                if (r.highResUrl) URL.revokeObjectURL(r.highResUrl);\n              });\n              // Still need to throw abort error to trigger finally cleanup correctly\n              throw new DOMException('Batch aborted post-worker', 'AbortError');\n            }\n\n            console.log(\n              `ImageProcessor: Received ${batchResults.length} results for batch ${batchId} (queued).`\n            );\n            const cacheUpdatePromises: Promise<void>[] = [];\n            for (const result of batchResults) {\n              const { id: resultId, lowResUrl, highResUrl } = result;\n              const originalItem = imagesToProcess.find(item => item.id === resultId);\n              const originalWidth = originalItem?.width;\n              const originalHeight = originalItem?.height;\n\n              if (!originalWidth || !originalHeight) continue;\n              const existingEntry = await this.getCacheEntry(resultId);\n              const finalEntry: ProcessedImageCacheEntry = {\n                id: resultId,\n                lowResUrl: result.lowResUrl ?? existingEntry?.lowResUrl,\n                lowResWidth: result.lowResUrl\n                  ? Math.round(originalWidth / 4)\n                  : existingEntry?.lowResWidth,\n                lowResHeight: result.lowResUrl\n                  ? Math.round(originalHeight / 4)\n                  : existingEntry?.lowResHeight,\n                highResUrl: result.highResUrl ?? existingEntry?.highResUrl,\n                width: result.highResUrl ? originalWidth : existingEntry?.width,\n                height: result.highResUrl ? originalHeight : existingEntry?.height,\n                timestamp: Date.now(),\n              };\n              cacheUpdatePromises.push(this.setCacheEntry(finalEntry));\n              // Publish results using the publisher function\n              if (result.lowResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'low',\n                  imageUrl: finalEntry.lowResUrl!,\n                  width: finalEntry.lowResWidth!,\n                  height: finalEntry.lowResHeight!,\n                });\n              }\n              if (result.highResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'high',\n                  imageUrl: finalEntry.highResUrl!,\n                  width: finalEntry.width!,\n                  height: finalEntry.height!,\n                });\n              }\n            }\n            await Promise.all(cacheUpdatePromises);\n          } else {\n            console.log(\n              `ImageProcessor: No images needed processing for batch ${batchId} (queued).`\n            );\n          }\n        } catch (error: any) {\n          batchError = error; // Store error to handle in finally\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued batch ${batchId} processing aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error processing queued batch ${batchId}:`, error);\n            this.onError?.(batchId, error.message || 'Queued batch processing failed');\n          }\n        } finally {\n          // Ensure bitmaps not transferred are closed if aborted/errored during prep\n          // Also close bitmaps if a non-abort error occurred after prep\n          if (batchError?.name === 'AbortError' || batchError) {\n            createdBitmaps.forEach(bitmap => {\n              // Check if it was actually transferred before trying to close\n              if (!transferList.includes(bitmap)) {\n                try {\n                  bitmap.close();\n                } catch {}\n              }\n            });\n          }\n          // Worker handles closing transferred bitmaps\n          this.activeRequests.delete(batchId);\n          console.log(\n            `ImageProcessor: Finished queued batch task ${batchId}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself\n        console.error(`ImageProcessor: Error adding batch task to queue ${batchId}:`, error);\n        this.activeRequests.delete(batchId); // Ensure cleanup\n        this.onError?.(batchId, error.message || 'Failed to queue batch task');\n      });\n  }\n\n  // --- Control Methods ---\n  cancel(id?: string) {\n    if (id) {\n      const controller = this.activeRequests.get(id);\n      if (controller) {\n        console.log(`ImageProcessor: Aborting request ${id}.`);\n        controller.abort();\n        // Don't delete immediately, let the queued task handle cleanup in finally\n        // this.activeRequests.delete(id);\n      } else {\n        console.log(`ImageProcessor: No active request found for ID ${id} to cancel.`);\n      }\n    } else {\n      console.log(\n        `ImageProcessor: Aborting all ${this.activeRequests.size} active requests and clearing queue.`\n      );\n      // Abort all active controllers\n      this.activeRequests.forEach(controller => controller.abort());\n      // Clear pending tasks from the queue\n      this.queue.clear();\n      // Clear the tracking map\n      this.activeRequests.clear();\n    }\n  }\n\n  cancelAll() {\n    this.cancel(); // cancel() without id now handles clearing everything\n  }\n\n  terminate() {\n    console.log(\n      'ImageProcessor: Terminating worker, cancelling active requests, clearing queue, and closing DB.'\n    );\n    this.cancelAll(); // Abort ongoing and clear pending\n    // Add a small delay to allow abort signals to propagate potentially?\n    // setTimeout(() => {...\n    try {\n      this.proxy[Comlink.releaseProxy]();\n    } catch (e) {\n      console.warn('ImageProcessor: Error releasing Comlink proxy:', e);\n    }\n    this.worker.terminate();\n    if (dbPromise) {\n      getDb().then(db => db.close());\n      dbPromise = null;\n    }\n    // }, 50); // Example delay\n  }\n}\n\nexport function createImageProcessor(options?: Omit<ImageProcessorOptions, 'onImageProcessed'>) {\n  return new ImageProcessor(options);\n}\n","import { createImageProcessor } from './imageProcessor.js';\n// Import the actual worker type for type safety\nimport LayoutWorker from './layoutWorker.worker.ts?worker'; // Vite worker import syntax\n// Import the new color extractor worker\nimport ColorExtractorWorker from './colorExtractor.worker.ts?worker';\n// Import the new grouping worker\nimport PQueue from 'p-queue'; // Import p-queue\nimport { v4 as uuidv4 } from 'uuid'; // Use UUID for unique request IDs\nimport GroupingWorker from './groupingWorker.worker.ts?worker';\n\n// Define the type for the processor instance more explicitly\ntype ImageProcessorInstance = ReturnType<typeof createImageProcessor>;\n// Define the type for the layout worker instance\ntype LayoutWorkerInstance = Worker;\n// Define the type for the color extractor worker instance\ntype ColorExtractorWorkerInstance = Worker;\n// Define the type for the grouping worker instance\ntype GroupingWorkerInstance = Worker;\ntype WorkerInstance = LayoutWorkerInstance | ColorExtractorWorkerInstance | GroupingWorkerInstance;\ntype WorkerType = 'layout' | 'color' | 'grouping';\n\n// Interface for messages sent TO workers (includes requestId)\ninterface WorkerRequestMessage<T = any> {\n  type: string; // Original message type\n  payload: T;\n  requestId: string;\n}\n\n// Interface for messages received FROM workers (includes requestId)\ninterface WorkerResponseMessage<T = any> {\n  type: string; // e.g., 'layoutResult', 'colorResult', 'groupingResult', 'error'\n  payload: T;\n  requestId: string;\n}\n\ninterface WorkerErrorMessage {\n  type: 'error';\n  message: string;\n  requestId?: string; // Optional: Worker might include ID with error\n}\n\ninterface PendingRequest<T> {\n  resolve: (value: T | PromiseLike<T>) => void; // Allow PromiseLike for better compatibility\n  reject: (reason?: any) => void;\n  timer?: ReturnType<typeof setTimeout>; // Optional: Timeout timer\n}\n\nclass WorkerPool {\n  private static instance: WorkerPool;\n  // Use the more specific type\n  private imageProcessor: ImageProcessorInstance | null = null;\n  private layoutWorker: LayoutWorkerInstance | null = null;\n  private colorExtractorWorker: ColorExtractorWorkerInstance | null = null; // Add state for color worker\n  private groupingWorker: GroupingWorkerInstance | null = null; // Add state for grouping worker\n  private isImageProcessorInitialized = false;\n  private isLayoutWorkerInitialized = false;\n  private isColorExtractorInitialized = false; // Add flag for color worker\n  private isGroupingWorkerInitialized = false; // Add flag for grouping worker\n  private layoutWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for color worker\n  private colorExtractorListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for grouping worker\n  private groupingWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n\n  // Initialization Promises\n  private layoutWorkerPromise: Promise<LayoutWorkerInstance> | null = null;\n  private colorExtractorWorkerPromise: Promise<ColorExtractorWorkerInstance> | null = null;\n  private groupingWorkerPromise: Promise<GroupingWorkerInstance> | null = null;\n\n  // Pending Requests Maps\n  private pendingLayoutRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingColorRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingGroupingRequests: Map<string, PendingRequest<any>> = new Map();\n\n  // --- p-queue Instances --- >\n  private layoutQueue: PQueue;\n  private colorQueue: PQueue;\n  private groupingQueue: PQueue;\n\n  private constructor() {\n    // Initialize queues with desired concurrency\n    // Layout and grouping are likely sequential operations affecting the whole view\n    this.layoutQueue = new PQueue({ concurrency: 1 });\n    this.groupingQueue = new PQueue({ concurrency: 1 });\n    // Color extraction can often run more concurrently\n    this.colorQueue = new PQueue({\n      concurrency: Math.max(1, (navigator.hardwareConcurrency || 4) - 1),\n    });\n    console.log(\n      `[WorkerPool] Initialized queues. Concurrency - Layout: ${this.layoutQueue.concurrency}, Grouping: ${this.groupingQueue.concurrency}, Color: ${this.colorQueue.concurrency}`\n    );\n  }\n\n  public static getInstance(): WorkerPool {\n    if (!WorkerPool.instance) {\n      WorkerPool.instance = new WorkerPool();\n    }\n    return WorkerPool.instance;\n  }\n\n  // --- Generic Worker Initializer ---\n  private initializeWorker<W extends WorkerInstance>(\n    workerType: WorkerType,\n    WorkerConstructor: new () => W,\n    setupListenersFn: (worker: W) => void\n  ): Promise<W> {\n    console.log(`WorkerPool: Initializing ${workerType} Worker...`);\n    return new Promise<W>((resolve, reject) => {\n      try {\n        const worker = new WorkerConstructor();\n        setupListenersFn(worker);\n        console.log(`WorkerPool: ${workerType} Worker initialized successfully.`);\n        resolve(worker);\n      } catch (error) {\n        console.error(`[WorkerPool] Failed to initialize ${workerType} Worker:`, error);\n        reject(new Error(`Failed to initialize ${workerType} Worker`));\n      }\n    });\n  }\n\n  // --- Image Processor Management ---\n\n  public getImageProcessor(): ImageProcessorInstance {\n    if (!this.imageProcessor) {\n      console.log('WorkerPool: Initializing Image Processor...');\n      this.imageProcessor = createImageProcessor();\n      this.isImageProcessorInitialized = true;\n    } else {\n      // console.log('WorkerPool: Returning existing Image Processor.');\n    }\n    return this.imageProcessor;\n  }\n\n  // Add method to cancel pending image processing tasks\n  public cancelPendingImageTasks() {\n    if (this.imageProcessor && this.isImageProcessorInitialized) {\n      console.log('WorkerPool: Cancelling pending image processing tasks...');\n      this.imageProcessor.cancel?.(); // Use optional chaining\n    } else {\n      // console.log('WorkerPool: No active image processor to cancel tasks for.');\n    }\n  }\n\n  // --- Layout Worker Management (Promise-based) ---\n  public getLayoutWorker(): Promise<LayoutWorkerInstance> {\n    if (!this.layoutWorkerPromise) {\n      this.layoutWorkerPromise = this.initializeWorker('layout', LayoutWorker, worker => {\n        this.layoutWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'layout',\n          this.pendingLayoutRequests,\n          this.layoutWorkerListeners\n        );\n      }).catch(err => {\n        this.layoutWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.layoutWorkerPromise;\n  }\n\n  // --- Color Extractor Worker Management (Promise-based) ---\n  public getColorExtractorWorker(): Promise<ColorExtractorWorkerInstance> {\n    if (!this.colorExtractorWorkerPromise) {\n      this.colorExtractorWorkerPromise = this.initializeWorker(\n        'color',\n        ColorExtractorWorker,\n        worker => {\n          this.colorExtractorWorker = worker; // Store the instance\n          this.setupWorkerMessageHandler(\n            worker,\n            'color',\n            this.pendingColorRequests,\n            this.colorExtractorListeners\n          );\n        }\n      ).catch(err => {\n        this.colorExtractorWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.colorExtractorWorkerPromise;\n  }\n\n  // --- Grouping Worker Management (Promise-based) ---\n  public getGroupingWorker(): Promise<GroupingWorkerInstance> {\n    if (!this.groupingWorkerPromise) {\n      this.groupingWorkerPromise = this.initializeWorker('grouping', GroupingWorker, worker => {\n        this.groupingWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'grouping',\n          this.pendingGroupingRequests,\n          this.groupingWorkerListeners\n        );\n      }).catch(err => {\n        this.groupingWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.groupingWorkerPromise;\n  }\n\n  // --- Generic Message Handler Setup ---\n  private setupWorkerMessageHandler<T>(\n    worker: WorkerInstance,\n    workerType: WorkerType,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    generalListeners: Map<string, (event: MessageEvent) => void>\n  ): void {\n    worker.onmessage = (event: MessageEvent<WorkerResponseMessage<T> | WorkerErrorMessage>) => {\n      const { data } = event;\n      const requestId = data.requestId;\n\n      // console.log(`[WorkerPool] Received message from ${workerType} worker:`, data);\n\n      if (requestId && pendingRequests.has(requestId)) {\n        const request = pendingRequests.get(requestId)!;\n        clearTimeout(request.timer); // Clear timeout if response received\n\n        if (data.type === 'error') {\n          console.error(\n            `[WorkerPool] Error response for request ${requestId} from ${workerType}:`,\n            (data as WorkerErrorMessage).message\n          );\n          request.reject(\n            new Error((data as WorkerErrorMessage).message || 'Worker returned an error')\n          );\n        } else {\n          // Assume other types are successful results\n          // console.log(`[WorkerPool] Resolving request ${requestId} for ${workerType}`);\n          request.resolve((data as WorkerResponseMessage<T>).payload);\n        }\n        pendingRequests.delete(requestId);\n      } else if (requestId) {\n        console.warn(\n          `[WorkerPool] Received message with unknown or stale requestId ${requestId} from ${workerType}:`,\n          data\n        );\n        // Optionally dispatch to general listeners if it's a non-error message?\n        // generalListeners.forEach(listener => listener(event));\n      } else {\n        // Message without requestId - likely a general status or unhandled message\n        // console.log(`[WorkerPool] Received non-request message from ${workerType}:`, data);\n        generalListeners.forEach(listener => listener(event));\n      }\n    };\n\n    worker.onerror = (event: ErrorEvent) => {\n      console.error(`[WorkerPool] Generic error from ${workerType} Worker:`, event.message, event);\n      // Attempt to reject related pending requests, though we lack specific request ID here\n      // This is a limitation if the worker crashes without sending a request-specific error\n      const error = new Error(`Worker ${workerType} encountered an error: ${event.message}`);\n      pendingRequests.forEach((request, requestId) => {\n        console.warn(\n          `[WorkerPool] Rejecting pending request ${requestId} due to generic ${workerType} worker error.`\n        );\n        clearTimeout(request.timer);\n        request.reject(error);\n      });\n      pendingRequests.clear(); // Clear all pending requests for this worker on generic error\n\n      // Also notify general listeners\n      generalListeners.forEach(listener => listener(event as any));\n\n      // Consider terminating and resetting the worker promise here?\n      // worker.terminate(); // Be careful with immediate termination\n      // this[`${workerType}WorkerPromise`] = null;\n      // this[`${workerType}Worker`] = null;\n    };\n  }\n\n  // --- Unified Request Posting (Uses p-queue) ---\n  public postRequest<RequestPayload, ResponsePayload>(\n    workerType: WorkerType,\n    messageType: string,\n    payload: RequestPayload,\n    options?: { priority?: number; timeoutMs?: number }\n  ): Promise<ResponsePayload> {\n    let queue: PQueue;\n    let pendingRequests: Map<string, PendingRequest<ResponsePayload>>;\n    let getWorkerPromise: () => Promise<WorkerInstance>;\n\n    // Select the appropriate queue, map, and getter\n    switch (workerType) {\n      case 'layout':\n        queue = this.layoutQueue;\n        pendingRequests = this.pendingLayoutRequests;\n        getWorkerPromise = this.getLayoutWorker.bind(this);\n        break;\n      case 'color':\n        queue = this.colorQueue;\n        pendingRequests = this.pendingColorRequests;\n        getWorkerPromise = this.getColorExtractorWorker.bind(this);\n        break;\n      case 'grouping':\n        queue = this.groupingQueue;\n        pendingRequests = this.pendingGroupingRequests;\n        getWorkerPromise = this.getGroupingWorker.bind(this);\n        break;\n      default:\n        return Promise.reject(new Error(`Invalid worker type: ${workerType}`));\n    }\n\n    // The task added to the queue - *Removed async keyword here*\n    const task = (): Promise<ResponsePayload> => {\n      // Return a new promise that encapsulates the entire worker interaction\n      return new Promise<ResponsePayload>(async (resolveTask, rejectTask) => {\n        const requestId = uuidv4();\n        // console.log(`[WorkerPool] Starting task ${requestId} (${messageType}) for ${workerType}`);\n\n        let worker: WorkerInstance;\n        try {\n          // Ensure worker is initialized within the promise executor\n          worker = await getWorkerPromise();\n        } catch (initError) {\n          console.error(\n            `[WorkerPool] Failed to initialize worker ${workerType} for task ${requestId}:`,\n            initError\n          );\n          rejectTask(initError); // Reject the task promise if init fails\n          return;\n        }\n\n        // Now, manage the specific response via the pendingRequests map\n        let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n        const responsePromise = new Promise<ResponsePayload>((resolveResponse, rejectResponse) => {\n          // Store the inner promise's resolve/reject for the message handler\n          pendingRequests.set(requestId, {\n            resolve: resolveResponse,\n            reject: rejectResponse,\n            timer,\n          });\n        });\n\n        // Setup timeout if specified for the *response* part\n        if (options?.timeoutMs) {\n          timer = setTimeout(() => {\n            if (pendingRequests.has(requestId)) {\n              console.warn(\n                `[WorkerPool] Request ${requestId} to ${workerType} timed out after ${options.timeoutMs}ms.`\n              );\n              // Reject the *response* promise via the map\n              pendingRequests.get(requestId)?.reject(new Error(`Request ${requestId} timed out`));\n              pendingRequests.delete(requestId);\n            }\n          }, options.timeoutMs);\n          // Update the timer reference in the map\n          if (pendingRequests.has(requestId)) {\n            pendingRequests.get(requestId)!.timer = timer;\n          }\n        }\n\n        // Construct the message\n        const workerMessage: WorkerRequestMessage<RequestPayload> = {\n          type: messageType,\n          payload,\n          requestId,\n        };\n\n        // Post the message to the worker\n        try {\n          // console.log(`[WorkerPool] Posting message for ${requestId} to ${workerType}`);\n          worker.postMessage(workerMessage);\n        } catch (postError) {\n          console.error(\n            `[WorkerPool] Error posting message for request ${requestId} to ${workerType}:`,\n            postError\n          );\n          clearTimeout(timer);\n          pendingRequests.delete(requestId);\n          rejectTask(postError); // Reject the outer task promise if postMessage fails\n          return;\n        }\n\n        // Link the outer task promise to the inner response promise\n        try {\n          const result = await responsePromise;\n          resolveTask(result);\n        } catch (error) {\n          rejectTask(error);\n        } finally {\n          clearTimeout(timer); // Ensure timer is cleared if response promise settles\n        }\n      });\n    };\n\n    // Add the task function to the queue\n    return queue.add(task, { priority: options?.priority ?? 0 }) as Promise<ResponsePayload>;\n  }\n\n  // --- Listener Management (for general messages, if still needed) ---\n\n  public addLayoutWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for LayoutWorker: ${id}`);\n    this.layoutWorkerListeners.set(id, listener);\n    this.getLayoutWorker(); // Ensure worker is initialized to receive potential messages\n  }\n\n  public removeLayoutWorkerListener(id: string): void {\n    if (this.layoutWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for LayoutWorker: ${id}`);\n      this.layoutWorkerListeners.delete(id);\n    }\n  }\n\n  public addColorExtractorListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for ColorExtractorWorker: ${id}`);\n    this.colorExtractorListeners.set(id, listener);\n    this.getColorExtractorWorker();\n  }\n\n  public removeColorExtractorListener(id: string): void {\n    if (this.colorExtractorListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for ColorExtractorWorker: ${id}`);\n      this.colorExtractorListeners.delete(id);\n    }\n  }\n\n  public addGroupingWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for GroupingWorker: ${id}`);\n    this.groupingWorkerListeners.set(id, listener);\n    this.getGroupingWorker();\n  }\n\n  public removeGroupingWorkerListener(id: string): void {\n    if (this.groupingWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for GroupingWorker: ${id}`);\n      this.groupingWorkerListeners.delete(id);\n    }\n  }\n\n  // --- Cancellation ---\n\n  public cancelPendingLayoutTasks(all: boolean = false) {\n    this.cancelTasks('layout', this.layoutQueue, this.pendingLayoutRequests, all);\n  }\n  public cancelPendingColorTasks(all: boolean = false) {\n    this.cancelTasks('color', this.colorQueue, this.pendingColorRequests, all);\n  }\n  public cancelPendingGroupingTasks(all: boolean = false) {\n    this.cancelTasks('grouping', this.groupingQueue, this.pendingGroupingRequests, all);\n  }\n\n  private cancelTasks<T>(\n    workerType: WorkerType,\n    queue: PQueue,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    all: boolean = true // Default to cancelling all\n  ) {\n    if (!all) {\n      console.warn(\n        `[WorkerPool] Specific request cancellation via ID is not directly supported with queue.clear(). Use cancelAllPendingTasks() or implement AbortSignal.`\n      );\n      return;\n    }\n\n    console.log(`[WorkerPool] Cancelling pending tasks and clearing queue for ${workerType}...`);\n\n    // 1. Clear tasks waiting in the queue (these haven't started)\n    queue.clear();\n\n    // 2. Reject promises for tasks already sent to the worker (in-flight)\n    pendingRequests.forEach((request, id) => {\n      console.warn(\n        `[WorkerPool] Rejecting in-flight request ${id} for ${workerType} due to cancellation.`\n      );\n      clearTimeout(request.timer);\n      request.reject(new Error(`Request ${id} for ${workerType} was cancelled.`));\n      // Optionally, try to notify the worker if it supports cancellation messages\n      // const worker = this[`${workerType}Worker`];\n      // if (worker) {\n      //     try { worker.postMessage({ type: 'cancel', requestId: id }); } catch(e) {}\n      // }\n    });\n    pendingRequests.clear(); // Clear the map after rejecting\n  }\n\n  // --- General Cleanup ---\n\n  public cleanup() {\n    console.log('WorkerPool: Starting cleanup...');\n    this.cancelAllPendingTasks(); // Cancel everything first\n\n    // Terminate Workers\n    this.terminateWorker('layout', this.layoutWorker);\n    this.layoutWorker = null;\n    this.layoutWorkerPromise = null;\n    this.layoutWorkerListeners.clear();\n\n    this.terminateWorker('color', this.colorExtractorWorker);\n    this.colorExtractorWorker = null;\n    this.colorExtractorWorkerPromise = null;\n    this.colorExtractorListeners.clear();\n\n    this.terminateWorker('grouping', this.groupingWorker);\n    this.groupingWorker = null;\n    this.groupingWorkerPromise = null;\n    this.groupingWorkerListeners.clear();\n\n    // Cleanup Image Processor\n    if (this.imageProcessor) {\n      console.log('WorkerPool: Cleaning up Image Processor...');\n      this.imageProcessor.terminate?.();\n      this.imageProcessor = null;\n    }\n\n    // Clear queues (should be empty after cancelAll, but good practice)\n    this.layoutQueue.clear();\n    this.groupingQueue.clear();\n    this.colorQueue.clear();\n\n    console.log('WorkerPool: Cleanup complete.');\n  }\n\n  private terminateWorker(workerType: WorkerType, worker: WorkerInstance | null) {\n    if (worker) {\n      console.log(`WorkerPool: Terminating ${workerType} worker...`);\n      try {\n        worker.terminate();\n      } catch (e) {\n        console.error(`Error terminating ${workerType} worker:`, e);\n      }\n    }\n  }\n\n  // Optional: Combined cancel function\n  public cancelAllPendingTasks() {\n    this.cancelPendingImageTasks(); // Assuming this one is different\n    this.cancelPendingLayoutTasks(true);\n    this.cancelPendingColorTasks(true);\n    this.cancelPendingGroupingTasks(true);\n  }\n}\n\nexport default WorkerPool;\n// Export types needed by consumers\nexport type { WorkerErrorMessage, WorkerRequestMessage, WorkerResponseMessage, WorkerType };\n","import { DBSchema, IDBPDatabase, openDB } from 'idb';\r\n\r\nconst UI_STATE_DB_NAME = 'mediaFlowUIScrollDB';\r\nconst SCROLL_STATE_STORE_NAME = 'scrollPosition';\r\nconst DB_VERSION = 1;\r\n\r\n// Define the structure of the state we want to store - ONLY scrollTop\r\nexport interface ScrollState {\r\n  scrollTop: number;\r\n  timestamp: number;\r\n}\r\n\r\n// Define the database schema\r\ninterface ScrollStateDB extends DBSchema {\r\n  [SCROLL_STATE_STORE_NAME]: {\r\n    key: string; // folderPath\r\n    value: ScrollState;\r\n  };\r\n}\r\n\r\n// Singleton promise to ensure DB is opened only once\r\nlet dbPromise: Promise<IDBPDatabase<ScrollStateDB>> | null = null;\r\n\r\nfunction openScrollStateDB(): Promise<IDBPDatabase<ScrollStateDB>> {\r\n  if (!dbPromise) {\r\n    dbPromise = openDB<ScrollStateDB>(UI_STATE_DB_NAME, DB_VERSION, {\r\n      upgrade(db) {\r\n        // Create the object store if it doesn't exist\r\n        if (!db.objectStoreNames.contains(SCROLL_STATE_STORE_NAME)) {\r\n          db.createObjectStore(SCROLL_STATE_STORE_NAME);\r\n        }\r\n      },\r\n    });\r\n  }\r\n  return dbPromise;\r\n}\r\n\r\n/**\r\n * Saves the scroll top position for a specific folder path to IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @param scrollTop - The scroll position to save.\r\n */\r\nexport async function saveScrollState(folderPath: string, scrollTop: number): Promise<void> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const stateToSave: ScrollState = {\r\n      scrollTop: scrollTop,\r\n      timestamp: Date.now(),\r\n    };\r\n    await store.put(stateToSave, folderPath);\r\n    await tx.done;\r\n  } catch (error) {\r\n    console.error('Failed to save scroll state for path:', folderPath, error);\r\n  }\r\n}\r\n\r\n/**\r\n * Loads the scroll state for a specific folder path from IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @returns The saved ScrollState object (containing scrollTop and timestamp) or null.\r\n */\r\nexport async function loadScrollState(folderPath: string): Promise<ScrollState | null> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readonly');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const state = await store.get(folderPath);\r\n    await tx.done;\r\n    return state ?? null;\r\n  } catch (error) {\r\n    console.error('Failed to load scroll state for path:', folderPath, error);\r\n    return null;\r\n  }\r\n}\r\n","import gsap from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\n\r\ngsap.registerPlugin(ScrollTrigger);\r\n\r\ninterface AnimationTarget {\r\n  element: HTMLElement;\r\n  animation: gsap.core.Tween | gsap.core.Timeline;\r\n}\r\n\r\nclass ScrollTriggerManager {\r\n  private static instance: ScrollTriggerManager;\r\n  private targets: Map<string, AnimationTarget> = new Map();\r\n  private timeline: gsap.core.Timeline;\r\n  private mainTrigger: ScrollTrigger;\r\n\r\n  private constructor() {\r\n    this.timeline = gsap.timeline({\r\n      paused: true,\r\n      smoothChildTiming: true,\r\n    });\r\n\r\n    // Create one main ScrollTrigger\r\n    this.mainTrigger = ScrollTrigger.create({\r\n      trigger: document.body,\r\n      start: 'top top',\r\n      end: 'bottom bottom',\r\n      onUpdate: self => {\r\n        // Update timeline progress based on scroll\r\n        this.timeline.progress(self.progress);\r\n      },\r\n      markers: false, // Always disable markers\r\n    });\r\n  }\r\n\r\n  static getInstance(): ScrollTriggerManager {\r\n    if (!ScrollTriggerManager.instance) {\r\n      ScrollTriggerManager.instance = new ScrollTriggerManager();\r\n    }\r\n    return ScrollTriggerManager.instance;\r\n  }\r\n\r\n  addAnimation(id: string, element: HTMLElement, animationProps: gsap.TweenVars) {\r\n    // Create the animation but don't play it yet\r\n    const animation = gsap.to(element, {\r\n      ...animationProps,\r\n      paused: true,\r\n    });\r\n\r\n    // Add it to our timeline\r\n    this.timeline.add(animation, 0);\r\n\r\n    // Store reference\r\n    this.targets.set(id, { element, animation });\r\n\r\n    return animation;\r\n  }\r\n\r\n  removeAnimation(id: string) {\r\n    const target = this.targets.get(id);\r\n    if (target) {\r\n      this.timeline.remove(target.animation);\r\n      this.targets.delete(id);\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    // Kill all ScrollTriggers to prevent memory leaks\r\n    this.targets.forEach(({ animation }) => {\r\n      animation.kill();\r\n    });\r\n\r\n    if (this.mainTrigger) {\r\n      this.mainTrigger.kill();\r\n    }\r\n\r\n    this.timeline.kill();\r\n    this.targets.clear();\r\n    ScrollTrigger.getAll().forEach(trigger => trigger.kill());\r\n  }\r\n}\r\n\r\nexport default ScrollTriggerManager;\r\n","import gsap from 'gsap';\nimport { CustomEase } from 'gsap/CustomEase';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport ScrollTriggerManager from './ScrollTriggerManager';\n\ngsap.registerPlugin(ScrollTrigger, CustomEase);\n\n// Simplified animation system without ripples and energy mechanics\nexport class AnimationSystem {\n  private static instance: AnimationSystem;\n  private scrollTriggerManager: ScrollTriggerManager;\n\n  private constructor() {\n    this.initializeCustomEases();\n    this.scrollTriggerManager = ScrollTriggerManager.getInstance();\n  }\n\n  private initializeCustomEases() {\n    CustomEase.create(\n      'smoothOut',\n      'M0,0 C0.126,0.382 0.282,0.674 0.44,0.822 0.632,1.002 0.818,1 1,1'\n    );\n    CustomEase.create('gentleIn', 'M0,0 C0.39,0 0.575,0.565 0.669,0.782 0.762,1 0.846,1 1,1');\n  }\n\n  static getInstance(): AnimationSystem {\n    if (!AnimationSystem.instance) {\n      AnimationSystem.instance = new AnimationSystem();\n    }\n    return AnimationSystem.instance;\n  }\n\n  getAnimationProperties(itemId: string): gsap.TweenVars {\n    return {\n      duration: 0.5,\n      ease: 'power2.out',\n      transformOrigin: 'center center',\n      scale: 1,\n      rotation: 0,\n    };\n  }\n\n  createHoverAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      scale: 1.05,\n      duration: 0.3,\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  createMorphAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      duration: 0.5,\n      borderRadius: '8px',\n      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  // New method that uses the ScrollTriggerManager for scroll-based animations\n  createScrollAnimation(element: HTMLElement, itemId: string, animationProps: gsap.TweenVars) {\n    return this.scrollTriggerManager.addAnimation(itemId, element, animationProps);\n  }\n}\n\nexport default AnimationSystem;\n","import { ImageInfo, ViewMode } from '../types/index.js';\n\n// Constants\nexport const MIN_IMAGE_WIDTH = 200;\nexport const MAX_COLUMNS = 7;\nexport const MIN_COLUMNS = 1;\nexport const BASE_GAP = 4;\nexport const MIN_GAP = 2;\nexport const MAX_GAP = 12;\nexport const MIN_ZOOM = 0.5;\nexport const MAX_ZOOM = 3;\n\n// Types\nexport interface LayoutConfig {\n  containerWidth: number;\n  zoom: number;\n  viewMode: ViewMode;\n  isGrouped: boolean;\n}\n\nexport interface RowConfig {\n  width: number;\n  height: number;\n  gap: number;\n  images: ImageInfo[];\n  imageWidths?: number[];\n  offset?: number;\n}\n\nexport interface ImageDimensions {\n  width: number;\n  height: number;\n  aspectRatio: number;\n}\n\n// Cache for aspect ratios and dimensions\nconst aspectRatioCache = new WeakMap<ImageInfo, number>();\nconst layoutCache = new Map<string, RowConfig[]>();\n\n// Example: Caching sorted order of images\nconst sortedImagesCache = new Map<string, ImageInfo[]>();\n\nconst getSortedImages = (images: ImageInfo[]): ImageInfo[] => {\n  // Generate an identifier for the current order; could be a hash of ids\n  const cacheKey = images.map(img => img.id).join(',');\n  if (sortedImagesCache.has(cacheKey)) {\n    return sortedImagesCache.get(cacheKey)!;\n  }\n  // Sort images by aspect ratio (or any other criteria)\n  const sorted = [...images].sort((a, b) => a.width / a.height - b.width / b.height);\n  sortedImagesCache.set(cacheKey, sorted);\n  return sorted;\n};\n\n// Enhanced cache key generation with size awareness\nconst generateCacheKey = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  viewMode: string\n): string => {\n  return `${containerWidth}-${zoom}-${viewMode}-${images.map(img => img.id).join(',')}`;\n};\n\n// Cache invalidation threshold (in pixels)\nconst CACHE_INVALIDATION_THRESHOLD = 8;\n\nclass SizeAwareCache<T> {\n  private cache: Map<string, { data: T; width: number }>;\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, width: number): void {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, { data: value, width });\n  }\n\n  get(key: string, currentWidth: number): T | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    // Invalidate cache if width difference exceeds threshold\n    if (Math.abs(entry.width - currentWidth) > CACHE_INVALIDATION_THRESHOLD) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Replace existing caches with size-aware versions\nconst rowLayoutCache = new SizeAwareCache<RowConfig>(100);\nconst dimensionsCache = new SizeAwareCache<ImageDimensions>(500);\n\n// Core calculation functions\nexport const calculateColumns = (containerWidth: number, zoom: number): number => {\n  const effectiveWidth = containerWidth / zoom;\n  const baseColumns = Math.floor(effectiveWidth / (MIN_IMAGE_WIDTH * zoom));\n  return Math.min(Math.max(baseColumns, MIN_COLUMNS), MAX_COLUMNS);\n};\n\n// Add smooth zoom transition helper\nexport const interpolateZoom = (\n  currentZoom: number,\n  targetZoom: number,\n  progress: number\n): number => {\n  return currentZoom + (targetZoom - currentZoom) * progress;\n};\n\nexport const calculateGapSize = (zoom: number): number => {\n  // Normalize zoom level\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  // Calculate base gap size with finer granularity\n  const zoomFactor = (normalizedZoom - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);\n  const baseGap = BASE_GAP * (1 + zoomFactor * 0.25);\n\n  // Round to nearest even number to ensure consistent spacing\n  const roundedGap = Math.round(baseGap * 2) / 2;\n\n  // Ensure gap stays within bounds\n  return Math.min(Math.max(roundedGap, MIN_GAP), MAX_GAP);\n};\n\n// Optimized aspect ratio calculation with caching\nconst getAspectRatio = (image: ImageInfo): number => {\n  let ratio = aspectRatioCache.get(image);\n  if (!ratio) {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      ratio = image.width / image.height;\n      aspectRatioCache.set(image, ratio);\n    } else {\n      ratio = 1; // Default fallback\n    }\n  }\n  return ratio;\n};\n\n// Batch process aspect ratios\nconst batchProcessAspectRatios = (images: ImageInfo[]): number[] => {\n  return images.map(getAspectRatio);\n};\n\n// Optimized image dimensions calculation with caching\nexport const calculateImageDimensions = (\n  image: ImageInfo,\n  containerWidth: number,\n  zoom: number\n): ImageDimensions => {\n  const cacheKey = generateCacheKey([image], containerWidth, zoom, 'dimensions');\n  const cachedDimensions = dimensionsCache.get(cacheKey, containerWidth);\n\n  if (cachedDimensions) {\n    return cachedDimensions;\n  }\n\n  const aspectRatio = getAspectRatio(image);\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  const maxWidth = Math.min(containerWidth, MIN_IMAGE_WIDTH * MAX_COLUMNS);\n  const baseWidth = Math.min(\n    Math.max(MIN_IMAGE_WIDTH * normalizedZoom, containerWidth / MAX_COLUMNS),\n    maxWidth\n  );\n\n  const width = Math.round(baseWidth);\n  const height = Math.round(width / aspectRatio);\n\n  const dimensions = { width, height, aspectRatio };\n  dimensionsCache.set(cacheKey, dimensions, containerWidth);\n\n  return dimensions;\n};\n\nexport const detectOverflow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number\n): boolean => {\n  const gap = calculateGapSize(zoom);\n  const totalWidth = images.reduce((sum, image) => {\n    const { width } = calculateImageDimensions(image, containerWidth, zoom);\n    return sum + width + gap;\n  }, -gap); // Subtract last gap\n\n  return totalWidth > containerWidth;\n};\n\n// Add new helper function for calculating optimal row distribution\nconst calculateOptimalDistribution = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { idealHeight: number; widths: number[] } => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate ideal height that would make images fill the width perfectly\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate widths based on aspect ratios and ideal height\n  const widths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  return { idealHeight, widths };\n};\n\n// Enhanced checkRowFit function\nconst checkRowFit = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { fits: boolean; idealHeight: number; predictedWidths: number[] } => {\n  const { idealHeight, widths } = calculateOptimalDistribution(images, containerWidth, zoom, gap);\n  const minWidth = MIN_IMAGE_WIDTH * zoom;\n\n  // Check if any image would be too narrow based on aspect ratio\n  const allImagesWideEnough = widths.every(width => width >= minWidth);\n\n  // Calculate total width including gaps\n  const totalWidth = widths.reduce((sum, width) => sum + width, 0) + (images.length - 1) * gap;\n\n  return {\n    fits: allImagesWideEnough && totalWidth <= containerWidth,\n    idealHeight,\n    predictedWidths: widths,\n  };\n};\n\n// Update distributeImages function\nexport const distributeImages = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  targetRowHeight: number = 200\n): RowConfig[] => {\n  if (containerWidth <= 0 || images.length === 0) {\n    console.warn('Invalid input detected');\n    return [];\n  }\n\n  const sortedImages = getSortedImages(images);\n  const gap = calculateGapSize(zoom);\n  const rows: RowConfig[] = [];\n  let currentRow: ImageInfo[] = [];\n  let currentRowAspectRatio = 0;\n\n  for (let i = 0; i < sortedImages.length; i++) {\n    const testRow = [...currentRow, sortedImages[i]];\n    const { fits, idealHeight, predictedWidths } = checkRowFit(testRow, containerWidth, zoom, gap);\n\n    if (!fits && currentRow.length > 0) {\n      // --- Finalize the current row ---\n      const { idealHeight, widths: currentWidths } = calculateOptimalDistribution(\n        currentRow,\n        containerWidth,\n        zoom,\n        gap\n      );\n      const rowHeight = Math.floor(idealHeight);\n      // Adjust widths to fit exactly\n      const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n      let calculatedWidthSum = 0;\n      const adjustedWidths = currentRow.map((img, index) => {\n        const width = Math.floor(getAspectRatio(img) * rowHeight);\n        calculatedWidthSum += width;\n        return width;\n      });\n\n      // Distribute remainder/deficit due to flooring\n      const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n      if (discrepancy !== 0 && adjustedWidths.length > 0) {\n        // Add discrepancy to the last image for simplicity\n        adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n      }\n\n      rows.push({\n        width: containerWidth,\n        height: rowHeight,\n        gap,\n        images: currentRow,\n        imageWidths: adjustedWidths, // Use adjusted widths\n        offset: 0,\n      });\n      // --- End finalize current row ---\n\n      // Start new row with current image\n      currentRow = [sortedImages[i]];\n      currentRowAspectRatio = getAspectRatio(sortedImages[i]);\n    } else {\n      // Add image to current row\n      currentRow = testRow;\n      currentRowAspectRatio += getAspectRatio(sortedImages[i]);\n    }\n  }\n\n  // Handle last row\n  if (currentRow.length > 0) {\n    // --- Finalize the last row ---\n    const { idealHeight, widths: initialWidths } = calculateOptimalDistribution(\n      currentRow,\n      containerWidth,\n      zoom,\n      gap\n    );\n    const rowHeight = Math.floor(idealHeight);\n    // Adjust widths to fit exactly\n    const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n    let calculatedWidthSum = 0;\n    const adjustedWidths = currentRow.map((img, index) => {\n      const width = Math.floor(getAspectRatio(img) * rowHeight);\n      calculatedWidthSum += width;\n      return width;\n    });\n\n    // Distribute remainder/deficit due to flooring\n    const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n    if (discrepancy !== 0 && adjustedWidths.length > 0) {\n      // Add discrepancy to the last image for simplicity\n      adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n    }\n\n    rows.push({\n      width: containerWidth,\n      height: rowHeight,\n      gap,\n      images: currentRow,\n      imageWidths: adjustedWidths, // Use adjusted widths\n      offset: 0,\n    });\n    // --- End finalize last row ---\n  }\n\n  return rows;\n};\n\n// Helper function to create a centered row\nconst createCenteredRow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): RowConfig => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate row height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate image widths based on aspect ratios and available width\n  const imageWidths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  // Calculate actual total width including gaps\n  const totalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n\n  // Distribute any remaining pixels to prevent rounding issues\n  const remainingPixels = containerWidth - totalWidth;\n  if (remainingPixels > 0 && imageWidths.length > 0) {\n    // Add remaining pixels to the first image to maintain alignment\n    imageWidths[0] += remainingPixels;\n  }\n\n  // Calculate centering offset\n  const offset = Math.floor((containerWidth - totalWidth) / 2);\n\n  return {\n    width: containerWidth,\n    height: Math.floor(idealHeight),\n    gap,\n    images,\n    imageWidths,\n    offset,\n  };\n};\n\n// Optimized row layout calculation\nexport const optimizeRowLayout = (\n  row: RowConfig,\n  containerWidth: number,\n  zoom: number\n): RowConfig => {\n  if (containerWidth <= 0) {\n    console.warn('Invalid container width detected in optimizeRowLayout');\n    return row;\n  }\n\n  const cacheKey = generateCacheKey(row.images, containerWidth, zoom, 'row');\n  const cachedLayout = rowLayoutCache.get(cacheKey, containerWidth);\n  if (cachedLayout) {\n    return cachedLayout;\n  }\n\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n  const baseGap = calculateGapSize(normalizedZoom);\n\n  // Ensure integer gaps to prevent rounding issues\n  const gap = Math.round(baseGap);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (row.images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting all gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  const aspectRatios = batchProcessAspectRatios(row.images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate ideal height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n  const minRequiredHeight = (MIN_IMAGE_WIDTH * zoom) / Math.max(...aspectRatios);\n  const maxAllowedHeight = availableWidth / totalAspectRatio;\n  const rowHeight = Math.round(\n    Math.max(minRequiredHeight, Math.min(maxAllowedHeight, idealHeight))\n  );\n\n  // Calculate initial image widths based on aspect ratios\n  const imageWidths = aspectRatios.map(ratio => Math.floor(rowHeight * ratio));\n\n  // Calculate total width of all images\n  const totalImageWidth = imageWidths.reduce((sum, width) => sum + width, 0);\n\n  // Calculate the remaining width to distribute\n  const remainingWidth = availableWidth - totalImageWidth;\n\n  if (remainingWidth !== 0 && imageWidths.length > 0) {\n    // Distribute remaining width evenly among all images\n    const widthPerImage = Math.floor(remainingWidth / imageWidths.length);\n    const extraPixels = remainingWidth % imageWidths.length;\n\n    // Add base distribution to all images\n    imageWidths.forEach((_, index) => {\n      imageWidths[index] += widthPerImage;\n    });\n\n    // Add any extra pixels to the first few images\n    for (let i = 0; i < extraPixels; i++) {\n      imageWidths[i] += 1;\n    }\n  }\n\n  // Verify total width matches container width exactly\n  const finalTotalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n  if (finalTotalWidth !== containerWidth && imageWidths.length > 0) {\n    // Add any remaining pixels to the first image\n    const diff = containerWidth - finalTotalWidth;\n    imageWidths[0] += diff;\n  }\n\n  const optimizedRow = {\n    ...row,\n    width: containerWidth,\n    height: rowHeight,\n    gap,\n    imageWidths,\n  };\n\n  rowLayoutCache.set(cacheKey, optimizedRow, containerWidth);\n  return optimizedRow;\n};\n\n// Layout calculation for different view modes\nexport const calculateLayout = (config: LayoutConfig) => {\n  const { containerWidth, zoom, viewMode, isGrouped } = config;\n  const columns = calculateColumns(containerWidth, zoom);\n  const gap = calculateGapSize(zoom);\n\n  return {\n    columns,\n    gap,\n    minImageWidth: MIN_IMAGE_WIDTH * zoom,\n    maxImageWidth: containerWidth / columns - gap,\n  };\n};\n\n// Utility function for maintaining aspect ratio\nexport const maintainAspectRatio = (\n  image: ImageInfo,\n  containerWidth: number,\n  containerHeight: number\n): { width: number; height: number } => {\n  const imgRatio = getAspectRatio(image);\n  const containerRatio = containerWidth / containerHeight;\n  let width: number;\n  let height: number;\n\n  if (imgRatio > containerRatio) {\n    // Image is wider than container\n    width = containerWidth;\n    height = width / imgRatio;\n  } else {\n    // Image is taller than container\n    height = containerHeight;\n    width = height * imgRatio;\n  }\n\n  return { width: Math.round(width), height: Math.round(height) };\n};\n","import { Variants } from 'framer-motion';\n\n// Type alias for clarity\ntype TweenVars = gsap.TweenVars;\n\n// --- Framer Motion Variants ---\n\nexport const motionVariants = {\n  fadeIn: {\n    initial: { opacity: 0, y: 10 },\n    animate: { opacity: 1, y: 0 },\n    exit: { opacity: 0, y: -10 },\n    // Transition properties are typically applied on the motion component itself\n    // or within the transition prop, not directly in the variant definition.\n  } satisfies Variants,\n\n  hoverPop: {\n    rest: { scale: 1 },\n    hover: { scale: 1.05 },\n    // Transition properties like stiffness/damping go on the motion component\n  } satisfies Variants,\n\n  // Add more presets as needed...\n  // e.g., enterFromBottom, slideInLeft, pulse, etc.\n};\n\n// --- GSAP Configuration Objects ---\n// Note: These are simplified examples. You might need more complex configs\n// depending on how you integrate them into the pipeline later.\n\nexport const gsapConfigs = {\n  fadeIn: {\n    defaults: { duration: 0.5, ease: 'power2.out' },\n    vars: { opacity: 1, y: 0 },\n    initialVars: { opacity: 0, y: 10 }, // For setting initial state if needed\n  } satisfies { defaults?: TweenVars; vars: TweenVars; initialVars?: TweenVars },\n\n  hoverPop: {\n    defaults: { duration: 0.3, ease: 'power2.out', overwrite: 'auto' },\n    vars: { scale: 1.05 },\n    // You might need a 'rest' state config for GSAP hover-off\n    restVars: { scale: 1 },\n  } satisfies { defaults?: TweenVars; vars: TweenVars; restVars?: TweenVars },\n\n  // Add corresponding GSAP configs...\n};\n\n// --- Combined Type for Preset Names (ensures consistency) ---\nexport type MotionPresetName = keyof typeof motionVariants & keyof typeof gsapConfigs;\n\n// Helper function to get variants (example, might not be needed long-term)\nexport const getMotionVariant = (name: MotionPresetName): Variants => {\n  return motionVariants[name];\n};\n\n// Helper function to get GSAP config (example)\nexport const getGsapConfig = (name: MotionPresetName) => {\n  return gsapConfigs[name];\n};\n","import {\r\n  AnimationProps,\r\n  HTMLMotionProps,\r\n  motion,\r\n  TargetAndTransition,\r\n  Transition,\r\n  VariantLabels,\r\n} from 'framer-motion';\r\nimport React from 'react';\r\nimport { MotionPresetName, motionVariants } from './motionPresets';\r\n\r\n// --- Define the supported elements explicitly for type safety ---\r\ntype SupportedMotionElement =\r\n  | 'div'\r\n  | 'span'\r\n  | 'img'\r\n  | 'button'\r\n  | 'li'\r\n  | 'ul'\r\n  | 'p'\r\n  | 'h1'\r\n  | 'h2'\r\n  | 'h3';\r\n\r\nconst motionComponents: {\r\n  [key in SupportedMotionElement]: React.ComponentType<HTMLMotionProps<key>>;\r\n} = {\r\n  div: motion.div,\r\n  span: motion.span,\r\n  img: motion.img,\r\n  button: motion.button,\r\n  li: motion.li,\r\n  ul: motion.ul,\r\n  p: motion.p,\r\n  h1: motion.h1,\r\n  h2: motion.h2,\r\n  h3: motion.h3,\r\n};\r\n\r\n// Props for the MotionPreset component\r\n// Separate standard HTML/React props from MotionProps for clarity\r\ninterface BasePresetProps {\r\n  as?: SupportedMotionElement;\r\n  preset: MotionPresetName;\r\n  children?: React.ReactNode;\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n  onClick?: React.MouseEventHandler<HTMLElement>;\r\n  onMouseEnter?: React.MouseEventHandler<HTMLElement>;\r\n  onMouseLeave?: React.MouseEventHandler<HTMLElement>;\r\n}\r\n\r\n// Combine with relevant MotionProps, excluding 'variants' which we handle internally\r\ntype MotionPresetProps = BasePresetProps &\r\n  Omit<AnimationProps, 'variants'> & {\r\n    // Use AnimationProps for initial, animate, exit\r\n    // Explicitly type hover/tap/drag states\r\n    whileHover?: VariantLabels | TargetAndTransition;\r\n    whileTap?: VariantLabels | TargetAndTransition;\r\n    whileFocus?: VariantLabels | TargetAndTransition;\r\n    whileDrag?: VariantLabels | TargetAndTransition;\r\n    whileInView?: VariantLabels | TargetAndTransition;\r\n    // Allow transition prop override\r\n    transition?: Transition;\r\n    // Capture other valid HTML attributes if necessary\r\n    [key: string]: any;\r\n  };\r\n\r\nconst MotionPreset: React.FC<MotionPresetProps> = ({\r\n  as = 'div',\r\n  preset,\r\n  children,\r\n  className,\r\n  style,\r\n  onClick,\r\n  onMouseEnter,\r\n  onMouseLeave,\r\n  // Destructure AnimationProps\r\n  initial = 'initial',\r\n  animate = 'animate',\r\n  exit,\r\n  // Destructure state props\r\n  whileHover,\r\n  whileTap,\r\n  whileFocus,\r\n  whileDrag,\r\n  whileInView,\r\n  // Destructure transition\r\n  transition,\r\n  ...rest // Capture any remaining valid HTML attributes\r\n}) => {\r\n  const MotionComponent = motionComponents[as];\r\n  if (!MotionComponent) {\r\n    console.warn(`MotionPreset: Element type \"${as}\" is not supported. Defaulting to div.`);\r\n    const FallbackComponent = motion.div;\r\n    // Render children within the fallback\r\n    return (\r\n      <FallbackComponent style={style} className={className} {...rest}>\r\n        {children}\r\n      </FallbackComponent>\r\n    );\r\n  }\r\n\r\n  const variants = motionVariants[preset];\r\n\r\n  // Define default transitions based on preset\r\n  let defaultTransition: Transition = {};\r\n  if (preset === 'hoverPop') {\r\n    defaultTransition = { type: 'spring', stiffness: 300, damping: 15 };\r\n  }\r\n  if (preset === 'fadeIn') {\r\n    defaultTransition = { type: 'spring', stiffness: 120, damping: 20 };\r\n  }\r\n\r\n  const mergedTransition = transition ?? defaultTransition;\r\n\r\n  // Determine hover/tap targets safely\r\n  const hasHoverVariant = 'hover' in variants;\r\n  const hasTapVariant = 'tap' in variants;\r\n  // Use the actual variant name if available, otherwise undefined\r\n  const hoverTarget = whileHover ?? (hasHoverVariant ? 'hover' : undefined);\r\n  const tapTarget = whileTap ?? (hasTapVariant ? 'tap' : undefined);\r\n\r\n  // Note: whileFocus, whileDrag, whileInView would need similar checks\r\n  // if presets included 'focus', 'drag', or 'inView' keys.\r\n\r\n  return (\r\n    <MotionComponent\r\n      className={className}\r\n      style={style}\r\n      onClick={onClick}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseLeave={onMouseLeave}\r\n      variants={variants}\r\n      initial={initial}\r\n      animate={animate}\r\n      exit={exit} // Pass exit directly\r\n      whileHover={hoverTarget}\r\n      whileTap={tapTarget}\r\n      whileFocus={whileFocus} // Pass through directly\r\n      whileDrag={whileDrag} // Pass through directly\r\n      whileInView={whileInView} // Pass through directly\r\n      transition={mergedTransition}\r\n      {...rest} // Pass down remaining props\r\n    >\r\n      {children}\r\n    </MotionComponent>\r\n  );\r\n};\r\n\r\nexport default MotionPreset;\r\n","import { AnimatePresence, motion } from 'framer-motion';\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport MotionPreset from '../animations/MotionPreset';\nimport { ProcessedImageUpdate, useImageProcessing } from '../contexts/ImageProcessingContext';\nimport styles from '../styles/ImageItem.module.scss';\nimport { ImageInfo } from '../types/index.js';\nimport { truncateImageTitle } from '../utils/stringUtils.js';\n\n// Define hover data payload\nexport interface ImageHoverData {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates relative to viewport/background\n  color: string | null; // Dominant color of the image, if available\n  imageId: string;\n}\n\n// Type for the processed image callback data\ninterface ProcessedImageData {\n  id: string;\n  quality: 'low' | 'high';\n  processedImage: string;\n}\n\ninterface ImageItemProps {\n  image: ImageInfo;\n  onClick: (image: ImageInfo) => void;\n  containerWidth: number;\n  containerHeight: number;\n  zoom: number;\n  groupCount?: number;\n  onResize?: (width: number, height: number) => void;\n  width: number;\n  height: number;\n  isCarousel: boolean;\n  groupImages: ImageInfo[];\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColor?: string | null; // Added optional prop for color from worker\n}\n\n// Define animation variants\nconst placeholderVariants = {\n  initial: { opacity: 1, scale: 1, filter: 'blur(0px)' }, // Start fully visible\n  exit: {\n    // Animate out when isHighResLoaded becomes true\n    opacity: 0,\n    scale: 0.98, // Slight scale down\n    // filter: 'blur(10px)', // Optional blur out\n    transition: {\n      type: 'spring',\n      stiffness: 100,\n      damping: 20,\n      duration: 0.3, // Allow spring to resolve faster\n    },\n  },\n};\n\nconst imageVariants = {\n  initial: { opacity: 0, scale: 0.98 }, // Start hidden and slightly smaller\n  animate: {\n    // Animate in when isHighResLoaded becomes true\n    opacity: 1,\n    scale: 1,\n    transition: {\n      type: 'spring',\n      stiffness: 120,\n      damping: 25,\n      delay: 0.05, // Slight delay to ensure placeholder starts exiting\n    },\n  },\n};\n\n// ResponsiveImage component (Refined & Forwarding Ref)\ninterface ResponsiveImageProps {\n  src: string;\n  alt: string;\n  width?: number;\n  isProcessed: boolean;\n  onLoad: () => void;\n  onError: () => void;\n  className?: string;\n  style?: React.CSSProperties;\n  animate?: 'initial' | 'animate'; // Control animation state from parent\n}\n\nconst ResponsiveImage = React.forwardRef<HTMLImageElement, ResponsiveImageProps>(\n  (\n    { src, alt, width, isProcessed, onLoad, onError, className, style, animate = 'initial' },\n    ref\n  ) => {\n    const handleLoad = useCallback(() => {\n      onLoad();\n    }, [onLoad]);\n\n    const handleError = useCallback(() => {\n      onError();\n    }, [onError]);\n\n    const useSrcSet = !isProcessed && width && !src.startsWith('blob:');\n    const srcSet = useSrcSet\n      ? [\n          `${src}&w=${Math.round(width as number)} 1x`,\n          `${src}&w=${Math.round((width as number) * 2)} 2x`,\n          `${src}&w=${Math.round((width as number) * 3)} 3x`,\n        ].join(', ')\n      : undefined;\n    const sizes = useSrcSet ? `${Math.round(width as number)}px` : undefined;\n\n    return (\n      <motion.img\n        ref={ref}\n        key={src}\n        src={src}\n        alt={alt}\n        className={className}\n        style={style}\n        loading=\"lazy\"\n        variants={imageVariants}\n        initial=\"initial\"\n        animate={animate}\n        onLoad={handleLoad}\n        onError={handleError}\n        srcSet={srcSet}\n        sizes={sizes}\n      />\n    );\n  }\n);\nResponsiveImage.displayName = 'ResponsiveImage';\n\nconst ImageItem: React.FC<ImageItemProps> = ({\n  image,\n  onClick,\n  containerWidth,\n  containerHeight,\n  zoom = 1,\n  groupCount,\n  onResize,\n  width,\n  height,\n  isCarousel = false,\n  groupImages = [],\n  onImageHover,\n  onImageLoadError,\n  dominantColor,\n}) => {\n  const imageRef = useRef<HTMLImageElement>(null);\n  const [isHighResLoaded, setIsHighResLoaded] = useState(false);\n  const [processedUrls, setProcessedUrls] = useState<{ low?: string; high?: string }>({});\n  const [hasError, setHasError] = useState(false);\n  const { subscribeToImageUpdates } = useImageProcessing();\n\n  const placeholderColor = useMemo(() => {\n    return dominantColor || '#333';\n  }, [dominantColor]);\n\n  const targetWidth = containerWidth;\n  const targetHeight = containerHeight;\n\n  const aspectRatio = useMemo(() => {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      return `${image.width} / ${image.height}`;\n    }\n    if (targetWidth > 0 && targetHeight > 0) {\n      return `${targetWidth} / ${targetHeight}`;\n    }\n    return '1 / 1';\n  }, [image.width, image.height, targetWidth, targetHeight]);\n\n  useEffect(() => {\n    if (onResize) {\n      onResize(targetWidth, targetHeight);\n    }\n  }, [targetWidth, targetHeight, onResize]);\n\n  const handleMouseEnter = useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      const rect = event.currentTarget.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      const normalizedX = centerX / window.innerWidth;\n      const normalizedY = centerY / window.innerHeight;\n      onImageHover({\n        isHovering: true,\n        position: { x: normalizedX, y: normalizedY },\n        color: dominantColor || null,\n        imageId: image.id,\n      });\n    },\n    [onImageHover, image.id, dominantColor]\n  );\n\n  const handleMouseLeave = useCallback(() => {\n    onImageHover({\n      isHovering: false,\n      position: null,\n      color: null,\n      imageId: image.id,\n    });\n  }, [onImageHover, image.id]);\n\n  const handleProcessedImageUpdate = useCallback(\n    (data: ProcessedImageUpdate) => {\n      console.log(`[ImageItem ${image.id}] Received processed data via context: ${data.quality}`);\n      setProcessedUrls(prev => ({\n        ...prev,\n        [data.quality]: data.imageUrl,\n      }));\n    },\n    [image.id]\n  );\n\n  useEffect(() => {\n    const unsubscribe = subscribeToImageUpdates(image.id, handleProcessedImageUpdate);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [image.id, subscribeToImageUpdates, handleProcessedImageUpdate]);\n\n  useEffect(() => {\n    const currentLowUrl = processedUrls.low;\n    const currentHighUrl = processedUrls.high;\n    if (currentLowUrl) {\n      console.log(`[ImageItem ${image.id}] Revoking low-res blob URL on unmount: ${currentLowUrl}`);\n      URL.revokeObjectURL(currentLowUrl);\n    }\n    if (currentHighUrl) {\n      console.log(\n        `[ImageItem ${image.id}] Revoking high-res blob URL on unmount: ${currentHighUrl}`\n      );\n      URL.revokeObjectURL(currentHighUrl);\n    }\n  }, []);\n\n  const imageUrl = useMemo(() => {\n    if (hasError) return '';\n    if (processedUrls.high) return processedUrls.high;\n    if (processedUrls.low) return processedUrls.low;\n    return image.src;\n  }, [image.src, processedUrls, hasError]);\n\n  const isProcessed = !!(processedUrls.low || processedUrls.high);\n\n  const handleImageLoad = useCallback(() => {\n    if (imageUrl === processedUrls.high || (!processedUrls.high && imageUrl === image.src)) {\n      setIsHighResLoaded(true);\n    }\n    setHasError(false);\n  }, [imageUrl, processedUrls.high, image.src, image.id]);\n\n  const handleImageError = useCallback(() => {\n    console.error(`ImageItem: Failed to load image ${image.id}`, imageUrl);\n    setHasError(true);\n    onImageLoadError(image.id);\n  }, [image.id, imageUrl, onImageLoadError]);\n\n  const truncatedTitle = useMemo(\n    () => truncateImageTitle(image.alt || image.title || 'Untitled'),\n    [image.alt, image.title]\n  );\n\n  return (\n    <MotionPreset\n      as=\"div\"\n      preset=\"hoverPop\"\n      className={`${styles.imageItem} group`}\n      layout\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      onClick={() => onClick(image)}\n      style={{\n        position: 'relative',\n        width: `${width}px`,\n        height: `${height}px`,\n        overflow: 'hidden',\n        cursor: 'pointer',\n        aspectRatio: aspectRatio,\n      }}\n      initial={false}\n      animate={false}\n    >\n      <AnimatePresence>\n        {!isHighResLoaded && !hasError && (\n          <motion.div\n            key=\"placeholder\"\n            className={styles.placeholder}\n            style={{ '--placeholder-color': placeholderColor } as React.CSSProperties}\n            variants={placeholderVariants}\n            initial=\"initial\"\n            exit=\"exit\"\n          />\n        )}\n      </AnimatePresence>\n\n      {!hasError && imageUrl && (\n        <ResponsiveImage\n          ref={imageRef}\n          key={imageUrl}\n          src={imageUrl}\n          alt={image.alt ?? ''}\n          width={targetWidth}\n          isProcessed={isProcessed}\n          onLoad={handleImageLoad}\n          onError={handleImageError}\n          className={`${styles.imageElement}`}\n          style={{ position: 'absolute', inset: 0 }}\n          animate={isHighResLoaded ? 'animate' : 'initial'}\n        />\n      )}\n\n      {hasError && <div className={styles.errorIndicator}>Error</div>}\n\n      {!hasError && (\n        <motion.div\n          className={styles.overlay}\n          initial={{ opacity: 0 }}\n          whileHover={{ opacity: 1 }}\n          transition={{ duration: 0.2 }}\n        >\n          <p className={styles.title}>{truncatedTitle}</p>\n        </motion.div>\n      )}\n\n      {!hasError && groupCount && groupCount > 1 && (\n        <div className={styles.groupIndicator}>{groupCount}</div>\n      )}\n    </MotionPreset>\n  );\n};\n\nexport default memo(ImageItem);\n","export function truncateImageTitle(title: string | undefined): string {\n  if (!title) return 'Untitled';\n\n  // Remove file extensions and common suffixes anywhere in the string\n  const cleanTitle = title\n    // Remove file extensions and version numbers\n    .replace(/\\.(preview|thumbnail|jpg|jpeg|png|gif|webp)/gi, '')\n    .replace(/[-_.](v\\d+|example|intro|concept)[-_.]?\\d*/gi, '')\n    // Remove technical suffixes and common patterns\n    .replace(/[-_.]?(flux|lora|ai|toolkit|preview|example\\d*|poster)[-_.]?/gi, ' ')\n    // Remove numbered suffixes like .0, .1, .2\n    .replace(/\\.\\d+$/, '')\n    // Remove long number sequences and IDs\n    .replace(/[-_.]?\\d{6,}[-_.]?/g, '')\n    // Remove underscore/dash/dot between numbers\n    .replace(/(\\d)[-_.](\\d)/g, '$1$2')\n    // Remove numbers at the end of titles (like \"Character Style 1\")\n    .replace(/\\s+\\d+$/, '')\n    // Clean up remaining underscores, dashes, dots and extra spaces\n    .replace(/[-_.]+/g, ' ')\n    .replace(/\\s+/g, ' ');\n\n  // Split into words and properly capitalize each word\n  const formattedTitle = cleanTitle\n    .split(' ')\n    .map(word => {\n      // Keep acronyms uppercase, capitalize first letter of other words\n      return word.match(/^[A-Z]{2,}$/)\n        ? word\n        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ')\n    .trim();\n\n  // Truncate if necessary\n  const maxLength = 30;\n  return formattedTitle.length > maxLength\n    ? formattedTitle.substring(0, maxLength) + '...'\n    : formattedTitle;\n}\n","import { motion, useAnimation, Variants } from 'framer-motion';\nimport React, { useRef } from 'react';\nimport styles from '../styles/ImageRow.module.scss';\nimport { ImageInfo } from '../types/index.js';\n// import { createImageProcessor } from '../workers/imageProcessor'; // No longer needed directly\nimport WorkerPool from '../workers/workerPool'; // Import WorkerPool type\nimport ImageItem, { ImageHoverData } from './ImageItem.js';\n\n// Define the props interface for the ImageRow component\ninterface ImageRowProps {\n  images: ImageInfo[];\n  imageWidths: number[];\n  onImageClick: (clickedImage: ImageInfo) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  groupedImages: { key: string; images: ImageInfo[]; isCarousel: boolean }[];\n  workerPool: WorkerPool;\n  gap: number;\n  containerWidth: number;\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColorMap?: Map<string, string>; // Added optional prop for colors\n}\n\n// Define a smoother transition for layout animations using a soft spring\nconst smoothLayoutTransition = {\n  type: 'spring', // Back to spring for a more natural feel\n  stiffness: 120, // Lower stiffness for less aggression\n  damping: 30, // Higher damping to reduce oscillation\n  mass: 1, // Standard mass\n  // Removed tween-specific parameters\n};\n\n// Define variants for item entrance animation\nconst itemVariants: Variants = {\n  hidden: { opacity: 0, scale: 0.95 },\n  visible: (i: number) => ({\n    // Accept custom data (index)\n    opacity: 1,\n    scale: 1,\n    transition: {\n      delay: i * 0.03, // Stagger the animation based on index\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  }),\n};\n\n// Define the ImageRow component\nconst ImageRow: React.FC<ImageRowProps> = ({\n  images,\n  imageWidths,\n  onImageClick,\n  columns,\n  zoom,\n  isLastRow,\n  rowHeight,\n  groupedImages,\n  workerPool,\n  gap,\n  containerWidth,\n  onImageHover,\n  onImageLoadError,\n  dominantColorMap, // Destructure the new prop\n}) => {\n  const rowRef = useRef<HTMLDivElement>(null);\n  const controls = useAnimation();\n\n  if (\n    !images ||\n    images.length === 0 ||\n    !imageWidths ||\n    imageWidths.length !== images.length ||\n    rowHeight <= 0\n  ) {\n    return null;\n  }\n\n  return (\n    <motion.div\n      ref={rowRef}\n      className={styles.imageRow}\n      animate={controls}\n      initial={false}\n      style={{\n        display: 'flex',\n        flexWrap: 'nowrap',\n        overflow: 'hidden',\n        gap: `${gap}px`,\n        height: `${rowHeight}px`,\n        marginBottom: `${gap}px`,\n        position: 'relative',\n        willChange: 'transform',\n        width: '100%',\n        maxWidth: `${containerWidth}px`,\n        justifyContent: 'flex-start',\n        alignItems: 'stretch',\n      }}\n      layout\n      transition={smoothLayoutTransition}\n    >\n      {images.map((image, index) => {\n        const group = groupedImages.find(g => g.images.some(img => img.id === image.id));\n        const width = imageWidths[index];\n\n        if (width === undefined || width <= 0) {\n          console.warn(\n            `Invalid width (${width}) calculated for image ${image.id} at index ${index}`\n          );\n          return null;\n        }\n\n        // Get the dominant color for this specific image from the map\n        const dominantColor = dominantColorMap?.get(image.id);\n\n        return (\n          <motion.div\n            key={image.id}\n            className={`${styles.imageWrapper} card`}\n            custom={index}\n            initial=\"hidden\"\n            animate=\"visible\"\n            variants={itemVariants}\n            style={{\n              width: `${width}px`,\n              height: `${rowHeight}px`,\n              flexShrink: 0,\n              flexGrow: 0,\n              position: 'relative',\n              overflow: 'hidden',\n            }}\n            layout\n            transition={smoothLayoutTransition}\n          >\n            <ImageItem\n              image={image}\n              onClick={() => onImageClick(image)}\n              containerWidth={width}\n              containerHeight={rowHeight}\n              width={width}\n              height={rowHeight}\n              zoom={zoom}\n              isCarousel={group?.isCarousel || false}\n              groupImages={group?.images || []}\n              onImageHover={onImageHover}\n              onImageLoadError={onImageLoadError}\n              dominantColor={dominantColor} // Pass the specific color down\n            />\n          </motion.div>\n        );\n      })}\n    </motion.div>\n  );\n};\n\n// Export the memoized component\nexport default React.memo(ImageRow);\n","import React from 'react';\nimport styles from '../styles/ImageItem.module.scss';\n\ninterface ImageSkeletonProps {\n  containerWidth: number;\n  containerHeight: number;\n  placeholderColor?: string;\n}\n\nconst ImageSkeleton: React.FC<ImageSkeletonProps> = ({\n  containerWidth,\n  containerHeight,\n  placeholderColor,\n}) => {\n  const backgroundStyle = placeholderColor ? { backgroundColor: placeholderColor } : {};\n\n  return (\n    <div\n      className={`${styles.imageItem} ${styles.imageSkeleton}`}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        maxWidth: '100%',\n        maxHeight: '100%',\n        aspectRatio: `${containerWidth} / ${containerHeight}`,\n        ...backgroundStyle,\n      }}\n    >\n      <div className={styles.skeletonAnimation}></div>\n    </div>\n  );\n};\n\nexport default ImageSkeleton;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport { motion } from 'framer-motion';\n\ninterface BannerViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst BannerView: React.FC<BannerViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  return (\n    <div className=\"banner-view space-y-4\">\n      {images.map((image, index) => (\n        <motion.div\n          key={image.id}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.5, delay: index * 0.1 }}\n          className=\"banner-item relative\"\n        >\n          <div\n            className=\"banner-image-container w-full h-[300px] rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-shadow duration-300\"\n            style={{ height: `${300 * zoom}px` }}\n          >\n            <img src={image.src} alt={image.alt} className=\"w-full h-full object-cover\" />\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n              <p className=\"text-white/80 text-sm\">\n                {image.width} × {image.height}\n              </p>\n            </div>\n          </div>\n        </motion.div>\n      ))}\n    </div>\n  );\n};\n\nexport default BannerView;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport Slider from 'react-slick';\nimport { motion } from 'framer-motion';\nimport { FaChevronLeft, FaChevronRight } from 'react-icons/fa';\n\ninterface CarouselViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst NextArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute right-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronRight />\n    </button>\n  );\n};\n\nconst PrevArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute left-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronLeft />\n    </button>\n  );\n};\n\nconst CarouselView: React.FC<CarouselViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  const settings = {\n    dots: true,\n    infinite: true,\n    speed: 500,\n    slidesToShow: 1,\n    slidesToScroll: 1,\n    nextArrow: <NextArrow />,\n    prevArrow: <PrevArrow />,\n    adaptiveHeight: true,\n    customPaging: (i: number) => (\n      <div className=\"w-3 h-3 mx-1 rounded-full bg-white/50 hover:bg-white/70 transition-colors duration-300\" />\n    ),\n  };\n\n  return (\n    <div className=\"carousel-view\">\n      <Slider {...settings}>\n        {images.map((image, index) => (\n          <motion.div\n            key={image.id}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ duration: 0.5 }}\n            className=\"outline-none\"\n          >\n            <div className=\"relative aspect-video\">\n              <img\n                src={image.src}\n                alt={image.alt}\n                className=\"w-full h-full object-contain\"\n                style={{\n                  maxHeight: `${600 * zoom}px`,\n                }}\n              />\n              <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n                <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n                <p className=\"text-white/80 text-sm\">\n                  {image.width} × {image.height}\n                </p>\n              </div>\n            </div>\n          </motion.div>\n        ))}\n      </Slider>\n    </div>\n  );\n};\n\nexport default CarouselView;\n","import React from 'react';\r\nimport { ImageInfo } from '../../types';\r\nimport Masonry from 'react-masonry-css';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface MasonryViewProps {\r\n  images: ImageInfo[];\r\n  zoom: number;\r\n}\r\n\r\nconst MasonryView: React.FC<MasonryViewProps> = ({ images, zoom }) => {\r\n  const breakpointColumns = {\r\n    default: 4,\r\n    1536: 4,\r\n    1280: 3,\r\n    1024: 3,\r\n    768: 2,\r\n    640: 1,\r\n  };\r\n\r\n  if (!images.length) {\r\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\r\n  }\r\n\r\n  return (\r\n    <Masonry\r\n      breakpointCols={breakpointColumns}\r\n      className=\"flex -ml-4 w-auto\"\r\n      columnClassName=\"pl-4 bg-clip-padding\"\r\n    >\r\n      {images.map((image, index) => (\r\n        <motion.div\r\n          key={image.id}\r\n          initial={{ opacity: 0, scale: 0.9 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          transition={{ duration: 0.5, delay: index * 0.1 }}\r\n          className=\"mb-4\"\r\n        >\r\n          <div className=\"relative group rounded-lg overflow-hidden shadow-md hover:shadow-xl transition-shadow duration-300\">\r\n            <img\r\n              src={image.src}\r\n              alt={image.alt}\r\n              className=\"w-full h-auto\"\r\n              style={{\r\n                maxHeight: `${400 * zoom}px`,\r\n                objectFit: 'cover',\r\n              }}\r\n            />\r\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4 transform translate-y-full group-hover:translate-y-0 transition-transform duration-300\">\r\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\r\n              <p className=\"text-white/80 text-sm\">\r\n                {image.width} × {image.height}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </motion.div>\r\n      ))}\r\n    </Masonry>\r\n  );\r\n};\r\n\r\nexport default MasonryView;\r\n","import { useVirtualizer } from '@tanstack/react-virtual';\nimport { motion } from 'framer-motion';\nimport React, {\n  CSSProperties,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport Lightbox from 'yet-another-react-lightbox';\nimport Captions from 'yet-another-react-lightbox/plugins/captions';\nimport 'yet-another-react-lightbox/plugins/captions.css';\nimport Counter from 'yet-another-react-lightbox/plugins/counter';\nimport 'yet-another-react-lightbox/plugins/counter.css';\nimport Thumbnails from 'yet-another-react-lightbox/plugins/thumbnails';\nimport 'yet-another-react-lightbox/plugins/thumbnails.css';\nimport Zoom from 'yet-another-react-lightbox/plugins/zoom';\nimport 'yet-another-react-lightbox/styles.css';\nimport { ColorContext } from '../contexts/ColorContext';\nimport { useImageProcessing } from '../contexts/ImageProcessingContext';\nimport { useFolderImages } from '../hooks/query/useFolderImages';\nimport { usePrefetchManager } from '../hooks/usePrefetchManager.js';\nimport useWindowSize from '../hooks/useWindowSize.js';\nimport { loadScrollState, saveScrollState, ScrollState } from '../lib/cache/feedStateCache';\nimport styles from '../styles/ImageFeed.module.scss';\nimport { ImageInfo, ViewMode } from '../types/index.js';\nimport AnimationSystem from '../utils/AnimationSystem';\nimport {\n  calculateGapSize,\n  calculateLayout,\n  LayoutConfig,\n  MIN_IMAGE_WIDTH,\n  RowConfig,\n} from '../utils/layoutCalculator';\nimport WorkerPool, { WorkerType } from '../workers/workerPool';\nimport AuraBackground from './AuraBackground';\nimport { ImageHoverData } from './ImageItem.js';\nimport ImageRow from './ImageRow.js';\nimport ImageSkeleton from './ImageSkeleton.js';\nimport { BannerView, CarouselView, MasonryView } from './views';\n\n// Simple throttle function\nfunction throttle<F extends (...args: any[]) => any>(func: F, limit: number) {\n  let inThrottle: boolean;\n  let lastResult: ReturnType<F>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const throttled = function (this: ThisParameterType<F>, ...args: Parameters<F>): void {\n    const context = this;\n    if (!inThrottle) {\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n      // Call the function but don't worry about returning its result for listener\n      func.apply(context, args);\n    }\n    // Explicitly return void for listener compatibility\n    // return lastResult; // Removed potentially problematic return\n  };\n\n  return throttled;\n}\n\n// Simple debounce function (with cancel)\nfunction debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = (...args: Parameters<F>) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => func(...args), waitFor);\n  };\n\n  // Add the cancel method\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null; // Clear the ID after cancelling\n    }\n  };\n\n  return debounced as F & { cancel: () => void };\n}\n\n// Define the props interface for ImageFeed component\ninterface ImageFeedProps {\n  folderPath: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: React.RefObject<HTMLElement>;\n}\n\ninterface CustomStyle extends CSSProperties {\n  '--energy-color'?: string;\n  '--ripple-x'?: string;\n  '--ripple-y'?: string;\n  '--ripple-strength'?: string;\n}\n\n// Interface for messages from ColorExtractorWorker\ninterface ColorResultData {\n  id: string;\n  color: string | null;\n}\n\n// Interface for messages from GroupingWorker\ninterface ImageGroup {\n  key: string;\n  images: ImageInfo[];\n  isCarousel: boolean;\n}\ninterface GroupingResultData {\n  groupedImages: ImageGroup[];\n}\n\n// Define payload TYPESCRIPT INTERFACES for worker requests if needed for clarity,\n// but use component's internal types for results where appropriate.\ninterface GroupingRequestPayload {\n  images: ImageInfo[];\n  isGrouped: boolean;\n}\ninterface LayoutRequestPayload {\n  images: ImageInfo[];\n  containerWidth: number;\n  zoom: number;\n  targetRowHeight: number;\n}\ninterface ColorRequestPayload {\n  id: string;\n  src: string;\n}\n// Define the TYPE for the expected successful PAYLOAD from the color worker\n// Align this with what the color worker actually sends back in its payload\ninterface ColorWorkerSuccessPayload {\n  id: string;\n  color: string | null;\n}\n\n// Define the ImageFeed component\nconst ImageFeed: React.FC<ImageFeedProps> = ({\n  folderPath,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  const {\n    data: originalImages,\n    isLoading: isLoadingImages,\n    isError,\n    error,\n    isPlaceholderData,\n  } = useFolderImages(folderPath);\n\n  const windowSize = useWindowSize();\n  const feedRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [columns, setColumns] = useState(4);\n  const [lightboxIndex, setLightboxIndex] = useState<number>(-1);\n  const [lightboxImages, setLightboxImages] = useState<ImageInfo[]>([]);\n  const animationSystem = useMemo(() => AnimationSystem.getInstance(), []);\n  const { setDominantColors, setHoverState } = useContext(ColorContext);\n  const [dominantColorMap, setDominantColorMap] = useState<Map<string, string>>(new Map());\n  const requestedColorIds = useRef<Set<string>>(new Set());\n  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const [restoredState, setRestoredState] = useState<ScrollState | null>(null);\n  const previousFolderPathRef = useRef<string | null>(null);\n  const rowHeightsRef = useRef<number[]>([]);\n  const isRestoringScrollRef = useRef(false);\n  const velocityEMARef = useRef(0);\n  const OVERSCAN_BASE = 3;\n  const OVERSCAN_MAX = 15;\n  const EMA_ALPHA = 0.2;\n  const OVERSCAN_FACTOR = 10;\n  const [dynamicOverscan, setDynamicOverscan] = useState(OVERSCAN_BASE);\n  const [failedImageIds, setFailedImageIds] = useState<Set<string>>(new Set());\n  const { publishImageUpdate } = useImageProcessing();\n\n  // --- Define getImageUrl earlier --- >\n  const getImageUrl = useCallback((imagePath: string) => {\n    let path = imagePath.replace(/\\\\/g, '/');\n    if (path.startsWith('/api/image/') || path.startsWith('/')) {\n      return path;\n    }\n    return `/api/image/${path}`;\n  }, []); // Empty dependency array, safe to define early\n\n  // --- Memoized Images & Failed Image Handling --- >\n  const images = useMemo(() => {\n    if (!originalImages) return [];\n    return originalImages.filter(img => img && !failedImageIds.has(img.id)); // Added check for img existence\n  }, [originalImages, failedImageIds]);\n\n  const handleImageLoadError = useCallback((imageId: string) => {\n    setFailedImageIds(prev => {\n      if (prev.has(imageId)) return prev;\n      console.log(`ImageFeed: Registering error for image ${imageId}`);\n      const newSet = new Set(prev);\n      newSet.add(imageId);\n      return newSet;\n    });\n  }, []);\n\n  // --- Worker Pool --- >\n  const workerPool = useMemo(() => WorkerPool.getInstance(), []);\n\n  // --- State for Worker Operations --- >\n  const [calculatedRows, setCalculatedRows] = useState<RowConfig[]>([]);\n  const [isLayoutCalculating, setIsLayoutCalculating] = useState(false);\n  const [processedGroupedImages, setProcessedGroupedImages] = useState<ImageGroup[]>([]);\n  const [isGrouping, setIsGrouping] = useState(false);\n  // Flag to track if an async operation is currently active for a worker type\n  const activeRequestRef = useRef<{ [key in WorkerType]?: boolean }>({});\n\n  // --- Layout Data Map --- >\n  const layoutDataMap = useMemo(() => {\n    const map = new Map<string, { top: number; left: number; width: number; height: number }>();\n    let currentTop = 0;\n    const gap = calculateGapSize(zoom);\n    calculatedRows.forEach(row => {\n      let currentLeft = 0;\n      row.images.forEach((img, index) => {\n        if (!row.imageWidths || row.imageWidths.length <= index) {\n          console.warn(`[ImageFeed] Missing imageWidths for image ${img.id} in row.`);\n          return; // Skip this image if width data is missing\n        }\n        const width = row.imageWidths[index];\n        map.set(img.id, {\n          top: currentTop,\n          left: currentLeft,\n          width: width,\n          height: row.height,\n        });\n        currentLeft += width + gap;\n      });\n      currentTop += row.height + gap;\n    });\n    return map;\n  }, [calculatedRows, zoom]);\n\n  // --- Initialize Prefetch Manager --- >\n  // Only initialize if we have images and the necessary layout data\n  usePrefetchManager({\n    scrollContainerRef,\n    imageList: images, // Use the filtered images\n    layoutData: layoutDataMap,\n    // We can add configuration options here later (lookaheadDistance, concurrency)\n  });\n\n  // --- Debouncing Logic for isGrouped ---\n  const [debouncedIsGrouped, setDebouncedIsGrouped] = useState(isGrouped);\n  const updateDebouncedGrouped = useCallback(\n    // Use the local debounce function now\n    debounce((newValue: boolean) => {\n      setDebouncedIsGrouped(newValue);\n      console.log('[ImageFeed] Applying debounced isGrouped:', newValue);\n    }, 300), // 300ms debounce delay\n    [] // No dependencies needed as debounce is defined outside/statically\n  );\n  useEffect(() => {\n    updateDebouncedGrouped(isGrouped);\n    // Access the cancel method correctly\n    return () => updateDebouncedGrouped.cancel();\n  }, [isGrouped, updateDebouncedGrouped]);\n\n  // --- Scroll Persistence Logic ---\n\n  // Debounced function to save scroll state during active scroll\n  const debouncedSaveScroll = useCallback(\n    debounce((path: string, scroll: number /*, heights: number[], width: number */) => {\n      if (path && !isRestoringScrollRef.current) {\n        saveScrollState(path, scroll);\n      }\n    }, 500),\n    []\n  );\n\n  // Load state on mount/folder change & Save state on unmount/folder change\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadAndSetState = async () => {\n      const loadedState = await loadScrollState(folderPath);\n      if (isMounted) {\n        if (loadedState) {\n          setRestoredState(loadedState);\n          isRestoringScrollRef.current = true;\n        } else {\n          setRestoredState(null);\n          if (scrollContainerRef.current) {\n            scrollContainerRef.current.scrollTop = 0;\n          }\n          isRestoringScrollRef.current = false;\n        }\n      }\n    };\n\n    loadAndSetState();\n\n    const currentPathForCleanup = folderPath;\n    previousFolderPathRef.current = currentPathForCleanup;\n\n    return () => {\n      isMounted = false;\n      const scrollElement = scrollContainerRef.current;\n      const folderToSave = previousFolderPathRef.current;\n\n      if (scrollElement && folderToSave && rowHeightsRef.current.length > 0) {\n        saveScrollState(folderToSave, scrollElement.scrollTop);\n      }\n\n      debouncedSaveScroll.cancel?.();\n      // --- Cancel All Pending Worker Tasks on Unmount --- >\n      console.log('ImageFeed: Unmounting, cancelling all pending worker tasks.');\n      workerPool.cancelAllPendingTasks();\n      // No need to remove listeners here as they are not used for request/response\n    };\n  }, [\n    folderPath,\n    scrollContainerRef,\n    debouncedSaveScroll,\n    workerPool, // Add workerPool as dependency for cleanup\n  ]);\n  // --- End Scroll Persistence Logic ---\n\n  // --- Compute Stable Keys for Memoization --- >\n  const imagesKey = useMemo(() => images.map(i => i.id).join('|'), [images]);\n\n  // --- Avg Aspect Ratio & Layout Metrics (unchanged) --- >\n  const avgAspectRatio = useMemo(() => {\n    if (!originalImages || originalImages.length === 0) return 1; // Default aspect ratio\n    const validImages = originalImages.filter(img => img && img.width > 0 && img.height > 0);\n    if (validImages.length === 0) return 1;\n    const totalRatio = validImages.reduce((sum, img) => sum + img.width / img.height, 0);\n    return totalRatio / validImages.length;\n  }, [originalImages]);\n\n  const layoutMetrics = useMemo(() => {\n    const gapSize = calculateGapSize(zoom);\n    let estimatedRowHeightFallback = 200; // Default\n    if (containerWidth > 0 && columns > 0 && avgAspectRatio > 0) {\n      const totalGapWidth = Math.max(0, columns - 1) * gapSize;\n      const availableWidthForImages = Math.max(0, containerWidth - totalGapWidth);\n      if (availableWidthForImages > 0) {\n        const estimatedAvgImageWidth = availableWidthForImages / columns;\n        estimatedRowHeightFallback = Math.max(\n          50,\n          Math.round(estimatedAvgImageWidth / avgAspectRatio)\n        );\n      }\n    }\n    return {\n      gapSize,\n      estimatedRowHeightFallback,\n    };\n  }, [containerWidth, columns, zoom, avgAspectRatio]);\n\n  // --- Memoize Layout Inputs --- >\n  const layoutInputs = useMemo(\n    () => ({\n      imagesKey,\n      containerWidth,\n      zoom,\n      viewMode,\n      isGrouped: debouncedIsGrouped,\n      // Include estimated height as it affects the worker call\n      targetRowHeight: layoutMetrics.estimatedRowHeightFallback,\n    }),\n    [\n      imagesKey,\n      containerWidth,\n      zoom,\n      viewMode,\n      debouncedIsGrouped,\n      layoutMetrics.estimatedRowHeightFallback,\n    ]\n  );\n\n  // --- UPDATED: Reset/Cancel Effect --- >\n  useEffect(() => {\n    setLightboxIndex(-1);\n    setLightboxImages([]);\n    setDominantColorMap(new Map());\n    requestedColorIds.current.clear();\n    setFailedImageIds(new Set());\n    setCalculatedRows([]);\n    setIsLayoutCalculating(false); // Reset loading state\n    setProcessedGroupedImages([]);\n    setIsGrouping(false); // Reset loading state\n\n    console.log(\n      `ImageFeed: Deps changed (${folderPath}/${viewMode}/${isGrouped}/${zoom}), cancelling pending worker tasks.`\n    );\n    // Cancel tasks related to the previous state\n    workerPool.cancelAllPendingTasks();\n    activeRequestRef.current = {}; // Reset active request flags\n  }, [folderPath, viewMode, isGrouped, zoom, workerPool]); // isGrouped and zoom trigger cancellation now\n\n  // --- Container Width Management (UPDATED: Use debounce) --- >\n  const updateContainerWidthInternal = useCallback(() => {\n    if (!feedRef.current) return;\n    const rect = feedRef.current.getBoundingClientRect();\n    const newWidth = Math.max(MIN_IMAGE_WIDTH, rect.width);\n    setContainerWidth(prevWidth => {\n      if (newWidth !== prevWidth) {\n        const config: LayoutConfig = {\n          containerWidth: newWidth,\n          zoom,\n          viewMode,\n          isGrouped: debouncedIsGrouped, // Use debounced value here\n        };\n        const layout = calculateLayout(config);\n        setColumns(layout.columns);\n        return newWidth;\n      }\n      return prevWidth;\n    });\n  }, [zoom, viewMode, debouncedIsGrouped]); // Keep dependencies of the internal logic\n\n  // --- Memoize the debounced function --- >\n  const debouncedUpdateContainerWidth = useMemo(\n    () => debounce(updateContainerWidthInternal, 100), // 100ms debounce\n    [updateContainerWidthInternal] // Recreate debounce only if internal logic changes\n  );\n\n  // --- Use the debounced function in effects --- >\n  useLayoutEffect(() => {\n    // Run immediately on mount\n    updateContainerWidthInternal();\n    // Ensure cleanup cancels the debounced call\n    return () => debouncedUpdateContainerWidth.cancel();\n  }, [updateContainerWidthInternal, debouncedUpdateContainerWidth]); // Add debounced func to deps\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(debouncedUpdateContainerWidth); // Use debounced version\n    if (feedRef.current) {\n      resizeObserver.observe(feedRef.current);\n    }\n    // Still use the debounced version for window resize\n    window.addEventListener('resize', debouncedUpdateContainerWidth);\n    return () => {\n      resizeObserver.disconnect();\n      window.removeEventListener('resize', debouncedUpdateContainerWidth);\n      debouncedUpdateContainerWidth.cancel(); // Cancel on unmount\n    };\n  }, [debouncedUpdateContainerWidth]); // Depend only on the stable debounced function reference\n  // --- End Container Width Management ---\n\n  // --- Effect for Pre-fetching Placeholder Colors (Now safe to use getImageUrl) --- >\n  useEffect(() => {\n    if (images && images.length > 0 && !isLoadingImages) {\n      const initialImageCount = Math.min(images.length, 30);\n      console.log(`[ImageFeed] Pre-fetching colors for initial ${initialImageCount} images...`);\n\n      for (let i = 0; i < initialImageCount; i++) {\n        const imageInfo = images[i];\n        if (\n          imageInfo &&\n          imageInfo.id &&\n          imageInfo.src &&\n          !dominantColorMap.has(imageInfo.id) &&\n          !requestedColorIds.current.has(imageInfo.id)\n        ) {\n          const imageUrl = getImageUrl(imageInfo.src); // Now defined\n          requestedColorIds.current.add(imageInfo.id);\n          // ... (rest of the postRequest logic)\n          workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              { id: imageInfo.id, src: imageUrl },\n              { priority: 2 }\n            )\n            .then(result => {\n              // ... (update map)\n            })\n            .catch(error => {\n              // ... (log error)\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(imageInfo.id);\n            });\n        }\n      }\n    }\n  }, [images, isLoadingImages, workerPool, getImageUrl]); // Keep getImageUrl in deps\n\n  // --- Combined Grouping & Layout Worker Trigger (Based on Memoized Inputs) --- >\n  useEffect(() => {\n    // Destructure inputs for clarity inside the effect\n    const {\n      imagesKey, // Used implicitly by `images` dependency below\n      containerWidth,\n      zoom,\n      viewMode,\n      isGrouped,\n      targetRowHeight,\n    } = layoutInputs;\n\n    console.log(\n      '[ImageFeed] Layout inputs changed. Triggering group/layout pipeline...',\n      layoutInputs\n    );\n\n    // Cancel any previous pipeline runs\n    // Note: cancelAllPendingTasks might be too broad if other workers run independently.\n    // If needed, use specific cancel functions (e.g., cancelPendingLayoutTasks).\n    workerPool.cancelAllPendingTasks();\n    activeRequestRef.current = {}; // Reset active flags\n    setIsGrouping(true); // Indicate start of pipeline\n    if (viewMode === ViewMode.GRID) {\n      setIsLayoutCalculating(true);\n    }\n\n    // Define the pipeline\n    const runPipeline = async () => {\n      try {\n        // 1. Grouping\n        console.log('[ImageFeed] Pipeline: Requesting grouping...');\n        const groupingResult = await workerPool.postRequest<\n          GroupingRequestPayload,\n          { groupedImages: ImageGroup[] }\n        >(\n          'grouping',\n          'groupImages',\n          { images: images, isGrouped: isGrouped }, // Use current images and isGrouped from layoutInputs\n          { priority: 9 }\n        );\n        console.log('[ImageFeed] Pipeline: Received grouping result.');\n        // Update grouping state immediately (or batch if using batch hook)\n        setProcessedGroupedImages(groupingResult.groupedImages);\n        setIsGrouping(false);\n\n        // 2. Layout (only if GRID view and grouping succeeded)\n        if (viewMode === ViewMode.GRID) {\n          const firstImages = groupingResult.groupedImages\n            .map(group => group.images[0])\n            .filter(image => image && image.width > 0 && image.height > 0);\n\n          if (firstImages.length > 0 && containerWidth > 0) {\n            console.log('[ImageFeed] Pipeline: Requesting layout...');\n            const layoutResult = await workerPool.postRequest<LayoutRequestPayload, RowConfig[]>(\n              'layout',\n              'calculateLayout',\n              {\n                images: firstImages,\n                containerWidth,\n                zoom,\n                targetRowHeight,\n              },\n              { priority: 10 }\n            );\n            console.log('[ImageFeed] Pipeline: Received layout result.');\n            // Update layout state (or batch)\n            setCalculatedRows(layoutResult);\n          } else {\n            console.log(\n              '[ImageFeed] Pipeline: Skipping layout (no valid first images or zero width).'\n            );\n            setCalculatedRows([]); // Clear layout if skipped\n          }\n        } else {\n          setCalculatedRows([]); // Clear layout if not in GRID view\n        }\n      } catch (error) {\n        // Handle errors from either worker\n        console.error('[ImageFeed] Pipeline error:', error);\n        setProcessedGroupedImages([]);\n        setCalculatedRows([]);\n      } finally {\n        // Reset loading flags regardless of success/error\n        setIsGrouping(false);\n        setIsLayoutCalculating(false);\n        // Clear active refs (might need more granular control if tasks overlap)\n        activeRequestRef.current = {};\n      }\n    };\n\n    // Only run the pipeline if we have images and a valid container width\n    if (images && images.length > 0 && containerWidth > 0) {\n      runPipeline();\n    } else {\n      // If no images or width, clear states and loading flags\n      console.log('[ImageFeed] Skipping pipeline (no images or zero width).');\n      setProcessedGroupedImages([]);\n      setCalculatedRows([]);\n      setIsGrouping(false);\n      setIsLayoutCalculating(false);\n      activeRequestRef.current = {};\n    }\n\n    // Cleanup: Cancellation is handled at the start of the effect\n    // and on unmount by the main cleanup effect.\n  }, [layoutInputs, images, workerPool]); // Depend on memoized inputs, images array identity, and workerPool instance\n\n  // Define the useEffect that updates rowHeightsRef HERE, AFTER calculatedRows state\n  useEffect(() => {\n    if (viewMode === ViewMode.GRID && calculatedRows && calculatedRows.length > 0) {\n      rowHeightsRef.current = calculatedRows.map(row => row.height);\n    } else {\n      rowHeightsRef.current = [];\n    }\n  }, [calculatedRows, viewMode, folderPath]);\n\n  // Handle image overflow (wrapped in useCallback)\n  const handleImageOverflow = useCallback((image: ImageInfo) => {\n    console.warn('Image overflow detected:', image.id);\n  }, []);\n\n  // Update handleImageClick to work with grouped images and set lightbox plugins (wrapped in useCallback)\n  const handleImageClick = useCallback(\n    (clickedImage: ImageInfo) => {\n      const groupIndex = processedGroupedImages.findIndex(group =>\n        group.images.some(img => img.id === clickedImage.id)\n      );\n      if (groupIndex !== -1) {\n        const group = processedGroupedImages[groupIndex];\n        const imageIndexInGroup = group.images.findIndex(img => img.id === clickedImage.id);\n        if (imageIndexInGroup !== -1) {\n          setLightboxImages(group.images);\n          setLightboxIndex(imageIndexInGroup);\n        }\n      }\n    },\n    [processedGroupedImages]\n  );\n\n  // --- Scroll Velocity and Dynamic Overscan --- >\n  const lastScrollTopRef = useRef(0);\n  const lastScrollTimeRef = useRef(performance.now());\n\n  const handleScroll = useCallback(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (!scrollElement) return;\n\n    const now = performance.now();\n    const scrollTop = scrollElement.scrollTop;\n    const timeDelta = now - lastScrollTimeRef.current;\n    const scrollDelta = scrollTop - lastScrollTopRef.current;\n\n    if (timeDelta > 10) {\n      const velocity = Math.abs(scrollDelta) / timeDelta;\n      velocityEMARef.current = EMA_ALPHA * velocity + (1 - EMA_ALPHA) * velocityEMARef.current;\n      const calculatedOverscan =\n        OVERSCAN_BASE +\n        Math.min(velocityEMARef.current * OVERSCAN_FACTOR, OVERSCAN_MAX - OVERSCAN_BASE);\n      setDynamicOverscan(Math.round(calculatedOverscan));\n      lastScrollTopRef.current = scrollTop;\n      lastScrollTimeRef.current = now;\n      debouncedSaveScroll(folderPath, scrollTop);\n    }\n  }, [scrollContainerRef, folderPath, debouncedSaveScroll]);\n\n  // Attach scroll listener\n  useEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (scrollElement) {\n      // Use throttle for the scroll handler to limit frequency\n      const throttledScrollHandler = throttle(handleScroll, 100); // Throttle to ~10fps\n      scrollElement.addEventListener('scroll', throttledScrollHandler);\n      return () => scrollElement.removeEventListener('scroll', throttledScrollHandler);\n    }\n  }, [scrollContainerRef, handleScroll]);\n  // --- End Scroll Velocity Logic --- >\n\n  // --- Virtualization Setup ---\n  const rowVirtualizer = useVirtualizer({\n    count: calculatedRows.length,\n    getScrollElement: () => scrollContainerRef.current,\n    estimateSize: useCallback(\n      (index: number) => {\n        const rowHeight = calculatedRows[index]?.height ?? layoutMetrics.estimatedRowHeightFallback;\n        return rowHeight + layoutMetrics.gapSize;\n      },\n      [calculatedRows, layoutMetrics.estimatedRowHeightFallback, layoutMetrics.gapSize]\n    ),\n    overscan: dynamicOverscan,\n  });\n\n  // Remeasure rows whenever zoom, containerWidth, row count, row height fallback, gap size, view mode, or grouping changes\n  useLayoutEffect(() => {\n    rowVirtualizer.measure?.();\n  }, [\n    zoom,\n    containerWidth,\n    calculatedRows.length,\n    layoutMetrics.estimatedRowHeightFallback,\n    layoutMetrics.gapSize,\n    viewMode,\n    debouncedIsGrouped,\n    folderPath,\n    rowVirtualizer,\n  ]);\n\n  // Get the virtual items to render\n  const virtualItems = rowVirtualizer.getVirtualItems();\n\n  // --- End Virtualization Setup ---\n\n  // --- Add Scroll Restoration Effect ---\n  useLayoutEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    // Try to restore scroll only after layout is stable\n    if (isRestoringScrollRef.current && restoredState && rowHeightsRef.current.length > 0) {\n      if (scrollElement) {\n        console.log(`Restoring scroll to: ${restoredState.scrollTop}`);\n        // Wrap scroll restoration in requestAnimationFrame for smoothness\n        requestAnimationFrame(() => {\n          scrollElement.scrollTop = restoredState.scrollTop;\n          // Reset the flag *after* applying the scroll\n          isRestoringScrollRef.current = false;\n        });\n      } else {\n        isRestoringScrollRef.current = false; // Reset if element not found\n      }\n    }\n  }, [restoredState, scrollContainerRef, virtualItems, folderPath]); // Depend on restored state, ref, virtual items, and folderPath\n  // --- End Scroll Restoration Effect ---\n\n  // Callback function for image hover - with delay logic\n  const handleImageHover = useCallback(\n    (data: ImageHoverData) => {\n      // Clear any existing timeout\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n        hoverTimeoutRef.current = null;\n      }\n\n      if (data.isHovering) {\n        // Set a timeout to activate hover state after a delay\n        hoverTimeoutRef.current = setTimeout(() => {\n          // Get color from the state map if available\n          const color = dominantColorMap.get(data.imageId) || null;\n          setHoverState({ isHovering: true, position: data.position, color: color });\n        }, 150); // 150ms delay\n      } else {\n        // If mouse leaves, immediately deactivate hover state\n        setHoverState({ isHovering: false, position: null, color: null });\n      }\n    },\n    [setHoverState, dominantColorMap] // Dependency remains setHoverState\n  );\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    // Clear timeout if component unmounts\n    return () => {\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, []); // Empty dependency array ensures this runs only on mount and unmount\n\n  // --- Color Extraction Worker Integration (Add Priority for visible items) --- >\n  useEffect(() => {\n    // Only run if we have virtual items and rows calculated\n    if (virtualItems.length === 0 || calculatedRows.length === 0 || images.length === 0) {\n      return;\n    }\n\n    const visibleImageIds = new Set<string>();\n    virtualItems.forEach(virtualItem => {\n      const row = calculatedRows[virtualItem.index];\n      row?.images.forEach(img => visibleImageIds.add(img.id));\n    });\n\n    // Track promises for colors requested in this pass\n    const colorPromises: Promise<void>[] = [];\n\n    visibleImageIds.forEach(id => {\n      if (!dominantColorMap.has(id) && !requestedColorIds.current.has(id)) {\n        const imageInfo = images.find(img => img.id === id);\n        if (imageInfo?.src) {\n          const imageUrl = getImageUrl(imageInfo.src);\n          requestedColorIds.current.add(id);\n\n          const promise = workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              {\n                id: imageInfo.id,\n                src: imageUrl,\n              },\n              { priority: 1 }\n            )\n            .then(result => {\n              // Check result and specifically if color is a non-null string\n              if (result && typeof result.color === 'string') {\n                // Assign to a new variable to help TS with type narrowing inside the setter\n                const colorValue: string = result.color;\n                setDominantColorMap(prevMap => {\n                  const newMap = new Map(prevMap);\n                  // Use the explicitly typed colorValue\n                  newMap.set(result.id, colorValue);\n                  return newMap;\n                });\n              } else {\n                // console.log(`[ImageFeed] Color extraction failed or null for ${result?.id}`);\n              }\n            })\n            .catch(error => {\n              console.error(`[ImageFeed] Color worker request failed for image ID ${id}:`, error);\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(id);\n            });\n\n          colorPromises.push(promise);\n        }\n      }\n    });\n\n    // After processing all visible items in this pass, update the context\n    // Use Promise.allSettled to wait for all requests in this batch to finish\n    // before updating context, preventing rapid flickering.\n    if (colorPromises.length > 0) {\n      Promise.allSettled(colorPromises).then(() => {\n        // Re-calculate visible colors *after* potential map updates\n        const currentVisibleColors: string[] = [];\n        virtualItems.forEach(virtualItem => {\n          const row = calculatedRows[virtualItem.index];\n          row?.images.forEach(img => {\n            // Read from the potentially updated dominantColorMap state\n            const itemColor = dominantColorMap.get(img.id);\n            if (itemColor) {\n              currentVisibleColors.push(itemColor);\n            }\n          });\n        });\n        // Update context with the first 1 or 2 valid visible colors\n        if (currentVisibleColors.length > 0) {\n          // console.log('[ImageFeed] Updating context dominantColors after batch:', currentVisibleColors.slice(0, 2));\n          setDominantColors(currentVisibleColors.slice(0, 2));\n        } else {\n          // console.log('[ImageFeed] No dominant colors found after batch, resetting context.');\n          setDominantColors([]); // Reset if no colors found\n        }\n      });\n    } else {\n      // If no new colors were requested, still update context based on current visible colors\n      // This handles scrolling without new requests\n      const currentVisibleColors: string[] = [];\n      virtualItems.forEach(virtualItem => {\n        const row = calculatedRows[virtualItem.index];\n        row?.images.forEach(img => {\n          const itemColor = dominantColorMap.get(img.id);\n          if (itemColor) {\n            currentVisibleColors.push(itemColor);\n          }\n        });\n      });\n      if (currentVisibleColors.length > 0) {\n        // console.log('[ImageFeed] Updating context dominantColors (no new requests):', currentVisibleColors.slice(0, 2));\n        setDominantColors(currentVisibleColors.slice(0, 2));\n      } else {\n        // console.log('[ImageFeed] No dominant colors found (no new requests), resetting context.');\n        setDominantColors([]); // Reset if no colors found\n      }\n    }\n\n    // Cleanup: No specific listener removal needed here.\n    // Cancellation is handled by the main dependency change effect.\n  }, [\n    workerPool,\n    virtualItems, // Re-run when visible items change\n    calculatedRows, // Re-run if row layout changes\n    images, // Re-run if images change\n    getImageUrl,\n    dominantColorMap, // Re-run if the map updates (to potentially update context)\n    setDominantColors, // Context setter\n  ]);\n  // --- End Color Extraction Worker Integration ---\n\n  // --- Effect to set the publisher on the ImageProcessor --- >\n  useEffect(() => {\n    const processor = workerPool.getImageProcessor();\n    // Check if the processor has the setPublisher method (for safety)\n    if (processor && typeof (processor as any).setPublisher === 'function') {\n      (processor as any).setPublisher(publishImageUpdate);\n    } else {\n      console.warn('[ImageFeed] ImageProcessor instance not found or setPublisher method missing.');\n    }\n    // No cleanup needed for this specifically, publisher is set once\n    // Dependencies ensure it runs if publisher or processor instance changes\n  }, [workerPool, publishImageUpdate]);\n\n  // --- Render Logic --- >\n  const renderContent = () => {\n    const { gapSize } = layoutMetrics;\n    if (!containerWidth) return null;\n\n    const showLoadingState =\n      isLoadingImages || isGrouping || (viewMode === ViewMode.GRID && isLayoutCalculating);\n\n    // --- Render Dynamic Skeletons during Loading --- >\n    if (showLoadingState && viewMode === ViewMode.GRID) {\n      return (\n        <div\n          className={styles.gridContainer} // Use a container for skeleton layout\n          style={{\n            gap: `${gapSize}px`,\n            // Basic grid layout for skeletons based on current column count\n            // Note: This won't perfectly match the final layout worker result,\n            // but provides a reasonable placeholder structure.\n            display: 'grid',\n            gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,\n            padding: gapSize / 2, // Optional padding similar to final layout\n          }}\n        >\n          {(images ?? []).map(image => {\n            if (!image || image.width <= 0 || image.height <= 0) return null; // Skip invalid images\n            const color = dominantColorMap.get(image.id);\n            return (\n              <ImageSkeleton\n                key={`skeleton-${image.id}`}\n                containerWidth={image.width} // Use actual image dimensions\n                containerHeight={image.height}\n                placeholderColor={color} // Pass fetched color\n              />\n            );\n          })}\n        </div>\n      );\n    }\n\n    // Handle non-GRID view modes (pass raw images)\n    if (viewMode !== ViewMode.GRID) {\n      let ViewComponent;\n      switch (viewMode) {\n        case ViewMode.MASONRY:\n          ViewComponent = MasonryView;\n          break;\n        case ViewMode.BANNER:\n          ViewComponent = BannerView;\n          break;\n        case ViewMode.CAROUSEL:\n          ViewComponent = CarouselView;\n          break;\n        default:\n          return null;\n      }\n      // Ensure non-grid views also receive potentially filtered images\n      return <ViewComponent images={images} zoom={zoom} />;\n    }\n\n    // --- Render Final Virtualized GRID View --- >\n    // Only render if *not* in loading state and rows are calculated\n    if (!showLoadingState && calculatedRows.length > 0) {\n      return (\n        <div // Outer container: Sets the total scrollable height\n          style={{\n            height: `${rowVirtualizer.getTotalSize()}px`,\n            width: '100%',\n            position: 'relative',\n          }}\n        >\n          <div // Inner container: Absolutely positioned items are placed here\n            style={{\n              width: '100%',\n              position: 'relative',\n            }}\n          >\n            {virtualItems.map(virtualItem => {\n              const row = calculatedRows[virtualItem.index];\n              if (!row) return null;\n              return (\n                <motion.div // Wrapper with animation\n                  key={virtualItem.key}\n                  layout\n                  transition={{ type: 'spring', stiffness: 260, damping: 30 }}\n                  data-index={virtualItem.index}\n                  ref={rowVirtualizer.measureElement}\n                  style={{\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: virtualItem.size,\n                    y: virtualItem.start,\n                  }}\n                >\n                  <ImageRow\n                    // Pass necessary props down\n                    images={row.images}\n                    imageWidths={row.imageWidths ?? []}\n                    onImageClick={handleImageClick}\n                    columns={columns}\n                    zoom={zoom}\n                    isLastRow={virtualItem.index === calculatedRows.length - 1}\n                    rowHeight={row.height}\n                    // Pass processedGroupedImages down for context (e.g., carousel indicator)\n                    groupedImages={processedGroupedImages}\n                    workerPool={workerPool}\n                    gap={gapSize}\n                    containerWidth={containerWidth}\n                    onImageHover={handleImageHover}\n                    onImageLoadError={handleImageLoadError}\n                    // Pass the color map down to ImageRow/ImageItem if needed\n                    dominantColorMap={dominantColorMap}\n                  />\n                </motion.div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    // Fallback if still loading but not caught above, or rows aren't ready\n    // Can render a simpler spinner or nothing\n    return null; // Or a loading indicator\n  };\n\n  // Lightbox configuration\n  const lightboxPlugins = useMemo(() => [Captions, Counter, Thumbnails, Zoom], []);\n\n  // Prepare the lightbox slide objects\n  const slides = useMemo(() => {\n    if (!lightboxImages.length) return [];\n    return lightboxImages.map(image => ({\n      src: getImageUrl(image.src),\n      alt: image.alt,\n      title: image.title,\n      width: image.width,\n      height: image.height,\n    }));\n  }, [lightboxImages, getImageUrl]);\n\n  // --- Render Logic --- > Restored Error/Empty/Main return\n  if (isError) {\n    return (\n      <div ref={feedRef} className={`${styles.container} ${styles.error}`}>\n        Error loading images: {error?.message || 'Unknown error'}\n      </div>\n    );\n  }\n\n  const hasNoImages = !isLoadingImages && (!images || images.length === 0);\n  if (hasNoImages && !isGrouping && !isLayoutCalculating) {\n    return (\n      <div ref={feedRef} className={styles.container}>\n        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className={styles.noImages}>\n          No images found for this folder.\n        </motion.div>\n      </div>\n    );\n  }\n\n  // Main component return\n  return (\n    <div\n      ref={feedRef}\n      className={styles.container}\n      style={{\n        position: 'relative',\n      }}\n    >\n      <AuraBackground />\n      <div className={styles.feed}>{renderContent()}</div>\n\n      <Lightbox\n        open={lightboxIndex !== -1}\n        close={() => setLightboxIndex(-1)}\n        index={lightboxIndex}\n        slides={slides}\n        plugins={lightboxPlugins}\n      />\n    </div>\n  );\n}; // Correct closing brace for the component function\n\nexport default React.memo(ImageFeed);\n","import { useCallback, useEffect, useState } from 'react';\n\n// Define the structure for the window size object\ninterface WindowSize {\n  width: number | undefined;\n  height: number | undefined;\n}\n\n// Debounce timeout in milliseconds\nconst DEBOUNCE_TIMEOUT = 150;\n\n// Custom hook to track and return the current window size\nfunction useWindowSize() {\n  // State to store the current window size\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Memoized resize handler\n  const handleResize = useCallback(() => {\n    const newWidth = window.innerWidth;\n    const newHeight = window.innerHeight;\n\n    // Only update if dimensions actually changed\n    if (newWidth !== windowSize.width || newHeight !== windowSize.height) {\n      // Use RAF for smooth updates\n      requestAnimationFrame(() => {\n        setWindowSize({\n          width: newWidth,\n          height: newHeight,\n        });\n      });\n    }\n  }, [windowSize.width, windowSize.height]);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // Debounced resize handler\n    function debouncedResize() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(handleResize, DEBOUNCE_TIMEOUT);\n    }\n\n    // Initial size calculation\n    handleResize();\n\n    // Add event listener with debouncing\n    window.addEventListener('resize', debouncedResize);\n\n    // Cleanup\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      window.removeEventListener('resize', debouncedResize);\n    };\n  }, [handleResize]);\n\n  return windowSize;\n}\n\nexport default useWindowSize;\n","import throttle from 'lodash/throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ImageInfo } from '../types';\nimport WorkerPool from '../workers/workerPool';\n\ninterface PrefetchManagerOptions {\n  scrollContainerRef: React.RefObject<HTMLElement>;\n  imageList: ImageInfo[];\n  layoutData: Map<string, { top: number; left: number; width: number; height: number }>; // Assuming layout data is available\n  lookaheadDistance?: number; // Pixels or items? Let's start with pixels\n  priorityThreshold?: number; // Minimum priority score to consider prefetching\n  concurrency?: number; // How many items to prefetch concurrently\n  throttleDelay?: number; // ms delay for scroll/resize events\n}\n\ninterface PrefetchCandidate extends ImageInfo {\n  priority: number;\n  layout: { top: number; left: number; width: number; height: number };\n}\n\nconst DEFAULT_LOOKAHEAD = 600; // Look ahead 600px beyond viewport\nconst DEFAULT_CONCURRENCY = 3; // Prefetch up to 3 items at once\nconst DEFAULT_THROTTLE_DELAY = 50; // Throttle event handling to 50ms (was 100ms)\n\nexport function usePrefetchManager({\n  scrollContainerRef,\n  imageList,\n  layoutData,\n  lookaheadDistance = DEFAULT_LOOKAHEAD,\n  concurrency = DEFAULT_CONCURRENCY,\n  throttleDelay = DEFAULT_THROTTLE_DELAY,\n}: PrefetchManagerOptions) {\n  const workerPool = WorkerPool.getInstance();\n  const imageProcessor = workerPool.getImageProcessor();\n  const [viewport, setViewport] = useState({ top: 0, bottom: 0, height: 0 });\n  const processingRef = useRef<Set<string>>(new Set());\n\n  // Ref to store the latest version of the logic function for the throttled call\n  const runPrefetchLogicRef = useRef<() => Promise<void>>();\n\n  const updateViewport = useCallback(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    const { scrollTop, clientHeight } = container;\n    const currentTop = scrollTop;\n    const currentBottom = scrollTop + clientHeight;\n    // Use functional update to potentially avoid depending on viewport in useCallback\n    setViewport(prev => ({ top: currentTop, bottom: currentBottom, height: clientHeight }));\n  }, [scrollContainerRef]);\n\n  const calculatePriority = useCallback(\n    (\n      image: ImageInfo,\n      imageLayout: { top: number; left: number; width: number; height: number }\n    ): number => {\n      const imageCenterY = imageLayout.top + imageLayout.height / 2;\n      // Read viewport directly from state here\n      const viewportCenterY = viewport.top + viewport.height / 2;\n      const distance = Math.abs(imageCenterY - viewportCenterY);\n      return distance;\n    },\n    [viewport] // Dependency on viewport state is correct here\n  );\n\n  // Define the core logic function - this will be updated in the ref\n  const runPrefetchLogicAsyncInternal = useCallback(async () => {\n    // Read viewport state *inside* the function instead of relying on useCallback capture\n    const currentViewport = viewport;\n    if (!scrollContainerRef.current || imageList.length === 0 || layoutData.size === 0) {\n      return;\n    }\n\n    const candidates: PrefetchCandidate[] = [];\n    const prefetchTop = Math.max(0, currentViewport.top - lookaheadDistance);\n    const prefetchBottom = currentViewport.bottom + lookaheadDistance;\n\n    for (const image of imageList) {\n      const imageLayout = layoutData.get(image.id);\n      if (!imageLayout) continue;\n      const imageTop = imageLayout.top;\n      const imageBottom = imageLayout.top + imageLayout.height;\n      if (imageBottom >= prefetchTop && imageTop <= prefetchBottom) {\n        // Use the calculatePriority function (which depends on current viewport state)\n        const priority = calculatePriority(image, imageLayout);\n        candidates.push({ ...image, priority, layout: imageLayout });\n      }\n    }\n\n    candidates.sort((a, b) => a.priority - b.priority);\n\n    let processedCount = 0;\n    for (const candidate of candidates) {\n      if (processedCount >= concurrency) break;\n      if (processingRef.current.has(candidate.id)) continue;\n\n      console.log(\n        `[PrefetchManager] Requesting process for ${candidate.id}, Priority: ${candidate.priority.toFixed(0)}`\n      );\n      processingRef.current.add(candidate.id);\n      processedCount++;\n\n      imageProcessor\n        .processImage(candidate)\n        .catch(err => {\n          console.error(`[PrefetchManager] Error processing ${candidate.id}:`, err);\n        })\n        .finally(() => {\n          processingRef.current.delete(candidate.id);\n        });\n    }\n  }, [\n    // Dependencies that define the logic: Stable references or core data\n    imageList,\n    layoutData,\n    lookaheadDistance,\n    concurrency,\n    imageProcessor, // Assumed stable instance from WorkerPool\n    calculatePriority, // This function still changes when viewport changes, but runPrefetchLogicAsyncInternal doesn't directly depend on viewport state anymore\n    scrollContainerRef,\n    // REMOVED viewport dependency\n  ]);\n\n  // Update the ref whenever the internal logic function changes\n  useEffect(() => {\n    runPrefetchLogicRef.current = runPrefetchLogicAsyncInternal;\n  }, [runPrefetchLogicAsyncInternal]);\n\n  // Create the throttled function once, calling the function from the ref\n  const throttledRunPrefetch = useMemo(\n    () =>\n      throttle(() => {\n        // Added check: only run if the ref is current and component is mounted\n        if (runPrefetchLogicRef.current) {\n          runPrefetchLogicRef.current();\n        }\n      }, throttleDelay),\n    [throttleDelay]\n  );\n\n  // --- Effects ---\n\n  // Effect 1: Setup listeners and initial viewport\n  useEffect(() => {\n    // Initial viewport update on mount\n    updateViewport();\n\n    const container = scrollContainerRef.current;\n    if (container) {\n      // Attach the stable throttled listener\n      container.addEventListener('scroll', throttledRunPrefetch, { passive: true });\n      // Optional: Add resize listener if needed\n      // const handleResize = () => { updateViewport(); throttledRunPrefetch(); };\n      // window.addEventListener('resize', handleResize);\n    }\n\n    return () => {\n      throttledRunPrefetch.cancel();\n      if (container) {\n        container.removeEventListener('scroll', throttledRunPrefetch);\n        // window.removeEventListener('resize', handleResize);\n      }\n    };\n    // Dependencies: only need things required for setup/cleanup\n  }, [scrollContainerRef, updateViewport, throttledRunPrefetch]);\n\n  // Effect 2: Run prefetch logic when core data changes (images, layout)\n  useEffect(() => {\n    // Only run if we have images and layout data\n    // This prevents running unnecessarily when transitioning to empty state\n    if (imageList.length > 0 && layoutData.size > 0) {\n      console.log('[PrefetchManager] Running logic due to imageList/layoutData change.');\n      // Directly call the latest logic function from the ref\n      runPrefetchLogicRef.current?.();\n    }\n    // This effect should ONLY run when the core data list/layout changes.\n    // It intentionally does *not* depend on viewport or functions derived from it.\n  }, [imageList, layoutData]); // Removed runPrefetchLogicAsyncInternal dependency\n\n  // No return value needed, the hook manages prefetching internally\n}\n","import React, { RefObject } from 'react';\nimport styles from '../styles/ImageViewer.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport ImageFeed from './ImageFeed.js';\n\n// Define the props interface for the ImageViewer component\ninterface ImageViewerProps {\n  selectedFolder: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: RefObject<HTMLElement>;\n}\n\n// Define the ImageViewer component\nconst ImageViewer: React.FC<ImageViewerProps> = ({\n  selectedFolder,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  return (\n    // Main container with flex layout\n    <div className={`${styles.imageViewer} flex flex-col h-full bg-transparent`}>\n      {/* Content container with scrolling */}\n      <div className={`${styles.contentContainer} flex-1`}>\n        {/* Render ImageFeed directly, passing the folderPath and ref */}\n        {/* ImageFeed now handles its own loading, error, and empty states */}\n        <ImageFeed\n          folderPath={selectedFolder}\n          isGrouped={isGrouped}\n          zoom={zoom}\n          viewMode={viewMode}\n          scrollContainerRef={scrollContainerRef}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Export the ImageViewer component\nexport default ImageViewer;\n","import React from 'react';\r\nimport { ViewMode } from '../types/index.js';\r\nimport ImageViewer from './ImageViewer.js';\r\n\r\n// Define the props interface for the MainContent component\r\ninterface MainContentProps {\r\n  // images: ImageInfo[]; // Removed\r\n  selectedFolder: string;\r\n  searchQuery: string; // Kept for now, but its usage needs re-evaluation\r\n  // isLoading: boolean; // Removed\r\n  // error: string | null; // Removed\r\n  zoom: number;\r\n  isGrouped: boolean;\r\n  viewMode: ViewMode;\r\n  scrollContainerRef: React.RefObject<HTMLElement>;\r\n}\r\n\r\n// MainContent component that renders the primary content area of the application\r\nconst MainContent: React.FC<MainContentProps> = ({\r\n  // images, // Removed\r\n  selectedFolder,\r\n  searchQuery, // Kept for now\r\n  // isLoading, // Removed\r\n  // error, // Removed\r\n  zoom,\r\n  isGrouped,\r\n  viewMode,\r\n  scrollContainerRef,\r\n}) => {\r\n  // Removed the filtering logic for now. Search needs to be handled differently.\r\n  // const filteredImages = useMemo(() => {\r\n  //   if (!searchQuery) return images;\r\n  //   return images.filter(image => image.alt.toLowerCase().includes(searchQuery.toLowerCase()));\r\n  // }, [images, searchQuery]);\r\n\r\n  // Render the main content\r\n  return (\r\n    <>\r\n      {/* Render the ImageViewer component */}\r\n      <ImageViewer\r\n        // images={filteredImages} // Removed\r\n        // isLoading={isLoading} // Removed\r\n        // error={error} // Removed\r\n        selectedFolder={selectedFolder}\r\n        zoom={zoom}\r\n        isGrouped={isGrouped}\r\n        viewMode={viewMode}\r\n        scrollContainerRef={scrollContainerRef}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\n// Export the MainContent component\r\nexport default MainContent;\r\n","import { gsap } from 'gsap';\nimport { MotionPresetName, gsapConfigs } from './motionPresets';\n\n// Define the structure for a step in the pipeline\ninterface AnimationStepOptions {\n  delay?: number | string; // GSAP delay or position parameter like \"+=0.5\"\n  duration?: number;\n  ease?: string;\n  // Add other potential GSAP overrides if needed\n}\n\ninterface AnimationStep {\n  id?: string; // Optional ID for the step\n  target: gsap.DOMTarget; // Element(s) to animate\n  preset: MotionPresetName; // Name of the preset to use\n  options?: AnimationStepOptions; // Overrides for this specific step\n  // Later: Add 'type' for spring vs preset, 'engine' for Framer vs GSAP\n}\n\n// Type guard to check if a config has initialVars\nfunction hasInitialVars(config: any): config is { initialVars: gsap.TweenVars } {\n  return config && typeof config === 'object' && 'initialVars' in config;\n}\n\nexport class AnimationPipeline {\n  private timeline: gsap.core.Timeline | null;\n  private steps: AnimationStep[] = []; // Keep track of added steps\n\n  constructor(options?: gsap.TimelineVars) {\n    this.timeline = gsap.timeline({\n      paused: true, // Default to paused, require explicit play()\n      smoothChildTiming: true,\n      ...options,\n    });\n  }\n\n  /**\n   * Adds an animation step to the pipeline based on a preset.\n   */\n  addStep(step: AnimationStep): this {\n    if (!this.timeline) return this; // Don't add if killed\n\n    const { target, preset, options = {} } = step;\n    const presetConfig = gsapConfigs[preset];\n\n    if (!presetConfig) {\n      console.warn(`[AnimationPipeline] Preset \"${preset}\" not found in gsapConfigs.`);\n      return this;\n    }\n\n    // Combine defaults, step options, and preset variables\n    const tweenVars: gsap.TweenVars = {\n      ...presetConfig.defaults,\n      ...options,\n      ...presetConfig.vars,\n    };\n\n    // Handle initial state using the type guard\n    if (hasInitialVars(presetConfig)) {\n      gsap.set(target, presetConfig.initialVars);\n    }\n\n    // Add the tween to the timeline\n    this.timeline.to(target, tweenVars, options?.delay);\n    this.steps.push(step); // Store the step definition\n\n    return this; // Allow chaining\n  }\n\n  /**\n   * Plays the animation pipeline from the current position.\n   */\n  play(): Promise<void> {\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\n    // Return a promise that resolves when the timeline completes\n    return new Promise(resolve => {\n      // Ensure timeline exists before setting callback\n      if (!this.timeline) {\n        resolve();\n        return;\n      }\n      this.timeline.eventCallback('onComplete', () => {\n        resolve();\n        this.timeline?.eventCallback('onComplete', null); // Clean up listener safely\n      });\n      this.timeline.play();\n    });\n  }\n\n  /**\n   * Pauses the animation pipeline.\n   */\n  pause(): this {\n    this.timeline?.pause(); // Use optional chaining\n    return this;\n  }\n\n  /**\n   * Reverses the animation pipeline from the current position.\n   */\n  reverse(): Promise<void> {\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\n    return new Promise(resolve => {\n      if (!this.timeline) {\n        resolve();\n        return;\n      }\n      this.timeline.eventCallback('onReverseComplete', () => {\n        resolve();\n        this.timeline?.eventCallback('onReverseComplete', null); // Clean up listener safely\n      });\n      this.timeline.reverse();\n    });\n  }\n\n  /**\n   * Restarts the animation pipeline from the beginning.\n   */\n  restart(): Promise<void> {\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\n    this.timeline.pause(); // Ensure it's paused before restarting\n    this.timeline.seek(0);\n    return this.play(); // play() already handles killed timeline\n  }\n\n  /**\n   * Kills the timeline and removes tweens, freeing resources.\n   * Should be called when the component using the pipeline unmounts.\n   */\n  kill(): void {\n    if (this.timeline) {\n      this.timeline.kill();\n      this.timeline = null; // Set to null after killing\n    }\n    this.steps = [];\n  }\n\n  // --- Future additions ---\n  // addFramerStep(...) - To control Framer Motion components\n  // addSpringStep(...) - To integrate react-spring\n  // clear() - To remove steps without killing the timeline instance\n  // seek() - To jump to a specific time/label\n  // progress() - To get/set progress\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport Layout from '../components/Layout.js';\nimport MainContent from '../components/MainContent.js';\nimport { useFolderImages } from '../hooks/query/useFolderImages';\nimport { useAnimationPipeline } from '../hooks/useAnimationPipeline';\nimport { ViewMode } from '../types/index.js';\nimport { getHomeDirectory } from '../utils/settings.js';\n\n/**\n * Home component - the main page of the application.\n * It manages the overall state and layout of the app.\n *\n * @component\n * @returns {JSX.Element} The main application page.\n */\nconst Home: React.FC = () => {\n  // State declarations for managing application data and UI\n  const [selectedFolder, setSelectedFolder] = useState<string>(() => {\n    return getHomeDirectory() || '';\n  });\n  const { data: images, isLoading: isLoadingImages } = useFolderImages(selectedFolder);\n  const [zoom, setZoom] = useState<number>(1);\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  const [isGrouped, setIsGrouped] = useState<boolean>(true);\n  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.GRID);\n\n  // Refs\n  const mainScrollRef = useRef<HTMLElement>(null);\n  const layoutWrapperRef = useRef<HTMLDivElement>(null); // Ref for the outer wrapper div\n  const sidebarRef = useRef<HTMLDivElement>(null); // Ref for Sidebar\n  const navbarRef = useRef<HTMLDivElement>(null); // Ref for Navbar\n  const contentAreaRef = useRef<HTMLDivElement>(null); // Ref for MainContent wrapper area\n\n  // --- Animation Setup ---\n  const homeEnterPipeline = useAnimationPipeline({ paused: true });\n\n  // Configure the entrance animation steps once\n  useEffect(() => {\n    if (\n      layoutWrapperRef.current &&\n      sidebarRef.current &&\n      navbarRef.current &&\n      contentAreaRef.current\n    ) {\n      homeEnterPipeline\n        .addStep({\n          target: layoutWrapperRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.1, duration: 0.4 },\n        })\n        .addStep({\n          target: sidebarRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.2, duration: 0.4 },\n        })\n        .addStep({\n          target: navbarRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.2, duration: 0.4 },\n        })\n        .addStep({\n          target: contentAreaRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.3, duration: 0.5 },\n        });\n      // Pipeline remains paused until triggered\n    }\n  }, [homeEnterPipeline]);\n\n  /**\n   * Handler for folder selection change.\n   * Updates the selected folder state.\n   * @param {string} folder - The newly selected folder.\n   */\n  const handleFolderChange = (folder: string) => {\n    setSelectedFolder(folder);\n  };\n\n  // Restart the entrance animation whenever images finish loading for a new folder\n  const prevLoading = useRef<boolean>(true);\n  useEffect(() => {\n    if (prevLoading.current && !isLoadingImages) {\n      homeEnterPipeline.restart();\n    }\n    prevLoading.current = isLoadingImages;\n  }, [isLoadingImages, homeEnterPipeline]);\n\n  /**\n   * Handler for zoom level change.\n   * Updates the zoom state.\n   * @param {number} newZoom - The new zoom level.\n   */\n  const handleZoomChange = (newZoom: number) => {\n    setZoom(newZoom);\n  };\n\n  /**\n   * Handler for search query change.\n   * Updates the search query state.\n   * @param {string} query - The new search query.\n   */\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    // Search result display needs to be handled\n  };\n\n  /**\n   * Handler for file upload completion.\n   * Refreshes the images in the current folder.\n   * TODO: Replace with query invalidation using queryClient\n   */\n  const handleUploadComplete = () => {\n    // Example: queryClient.invalidateQueries(['images', selectedFolder]);\n    console.log('TODO: Invalidate query for folder:', selectedFolder);\n  };\n\n  /**\n   * Handler for grouping toggle.\n   * Toggles the grouping state.\n   */\n  const handleGroupToggle = () => {\n    setIsGrouped(prevState => !prevState);\n  };\n\n  const handleViewModeChange = (newMode: ViewMode) => {\n    setViewMode(newMode);\n  };\n\n  // Render the main layout with all necessary props\n  // Note: 'folders' & 'currentDirectory' props are removed from Layout\n  return (\n    // Remove initial style - let it render normally\n    <div ref={layoutWrapperRef}>\n      <Layout\n        ref={layoutWrapperRef} // Pass ref even if not animating for now\n        selectedFolder={selectedFolder}\n        onFolderChange={handleFolderChange}\n        onSearch={handleSearch}\n        zoom={zoom}\n        onZoomChange={handleZoomChange}\n        isGrouped={isGrouped}\n        onGroupToggle={handleGroupToggle}\n        viewMode={viewMode}\n        onViewModeChange={handleViewModeChange}\n        mainRef={mainScrollRef} // For scrolling\n        // Pass down refs for internal elements\n        sidebarRef={sidebarRef}\n        navbarRef={navbarRef}\n        contentAreaRef={contentAreaRef}\n      >\n        {/* MainContent is rendered inside Layout as children */}\n        <MainContent\n          zoom={zoom}\n          searchQuery={searchQuery}\n          selectedFolder={selectedFolder}\n          isGrouped={isGrouped}\n          viewMode={viewMode}\n          scrollContainerRef={mainScrollRef}\n        />\n      </Layout>\n    </div>\n  );\n};\n\nexport default Home;\n","import { useEffect, useMemo, useRef } from 'react';\r\nimport { AnimationPipeline } from '../animations/AnimationPipeline';\r\n\r\n/**\r\n * Custom hook to create and manage an AnimationPipeline instance.\r\n *\r\n * @param options Optional GSAP TimelineVars for the pipeline.\r\n * @returns An instance of AnimationPipeline.\r\n */\r\nexport function useAnimationPipeline(options?: gsap.TimelineVars): AnimationPipeline {\r\n  // Use useRef to hold the pipeline instance so it persists across renders\r\n  // without causing re-renders itself when its internal state changes.\r\n  const pipelineRef = useRef<AnimationPipeline | null>(null);\r\n\r\n  // Memoize the options object to prevent unnecessary pipeline recreation\r\n  // Note: A deep comparison might be needed if options are complex and change often.\r\n  // For typical timeline options (like paused, onComplete), this shallow comparison is usually sufficient.\r\n  const memoizedOptions = useMemo(() => options, [JSON.stringify(options)]); // Simple serialization for comparison\r\n\r\n  // Initialize the pipeline only once or if options change\r\n  if (pipelineRef.current === null) {\r\n    pipelineRef.current = new AnimationPipeline(memoizedOptions);\r\n  }\r\n\r\n  // Cleanup function to kill the timeline when the component unmounts\r\n  useEffect(() => {\r\n    const pipeline = pipelineRef.current;\r\n    // Return the cleanup function\r\n    return () => {\r\n      if (pipeline) {\r\n        // console.log('[useAnimationPipeline] Cleaning up pipeline');\r\n        pipeline.kill();\r\n        pipelineRef.current = null; // Clear the ref\r\n      }\r\n    };\r\n  }, [memoizedOptions]); // Re-run effect only if memoized options change (unlikely for constructor options)\r\n\r\n  // Ensure we always return a valid instance (or handle error)\r\n  if (!pipelineRef.current) {\r\n    // This case should ideally not happen if initialization logic is correct\r\n    // but provides a fallback.\r\n    pipelineRef.current = new AnimationPipeline(memoizedOptions);\r\n    console.error('[useAnimationPipeline] Pipeline was null after initialization. Recreated.');\r\n  }\r\n\r\n  return pipelineRef.current;\r\n}\r\n","import { useEffect } from 'react';\nimport {\n  AnimationControllerProvider,\n  useAnimationController,\n} from './contexts/AnimationControllerContext';\nimport { ColorProvider } from './contexts/ColorContext';\nimport { ImageProcessingProvider } from './contexts/ImageProcessingContext';\nimport Home from './pages/Home.js';\nimport './styles/views.css';\n\nfunction AppContent() {\n  // Enable global pageEnter trigger\n  const { trigger } = useAnimationController();\n\n  // Trigger the 'pageEnter' event once on mount\n  useEffect(() => {\n    trigger('pageEnter');\n  }, [trigger]);\n\n  return (\n    <div className=\"App\">\n      <Home />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <AnimationControllerProvider>\n      <ColorProvider>\n        <ImageProcessingProvider>\n          <AppContent />\n        </ImageProcessingProvider>\n      </ColorProvider>\n    </AnimationControllerProvider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App.js';\n\nexport function render() {\n  const html = ReactDOMServer.renderToString(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n  return { html };\n}\n"],"names":["AnimationControllerContext","createContext","AnimationControllerProvider","children","pipelinesRef","useRef","Map","trigger","useCallback","eventName","console","log","current","forEach","registered","triggerEvents","includes","id","playOnTrigger","pipeline","play","catch","err","error","restart","registerPipeline","has","warn","set","delete","contextValue","useMemo","Provider","value","initialDefaultColor","initialHoverState","isHovering","position","color","ColorContext","dominantColors","setDominantColors","hoverState","setHoverState","ColorProvider","setDominantColorsState","useState","setHoverStateInternal","newState","prevState","ImageProcessingContext","subscriptions","ImageProcessingProvider","subscribeToImageUpdates","imageId","callback","Set","get","add","size","publishImageUpdate","data","useImageProcessing","context","useContext","Error","ViewMode","api","axios","create","baseURL","async","getFolders","map","folder","name","path","getCurrentDirectory","currentDirectory","CurrentDirectoryButton","isLoading","isError","useQuery","queryKey","queryFn","staleTime","refetchOnWindowFocus","buttonContent","buttonClass","iconColor","jsxs","motion","button","className","whileHover","scale","whileTap","disabled","jsx","IconFolder","div","initial","opacity","animate","transition","duration","SearchBar","onSearch","query","setQuery","useAnimation","form","onSubmit","e","preventDefault","styles","width","type","stiffness","damping","background","input","onChange","target","placeholder","whileFocus","ZoomSlider","zoom","onZoomChange","isDragging","setIsDragging","controls","sliderWidth","glowOpacity","glowScale","useEffect","start","style","boxShadow","onClick","Math","max","svg","height","viewBox","fill","xmlns","rotate","d","stroke","strokeWidth","strokeLinecap","strokeLinejoin","top","left","transform","pointerEvents","precision","min","step","parseFloat","onMouseDown","onMouseUp","onTouchStart","onTouchEnd","Navbar","forwardRef","isGrouped","onGroupToggle","viewMode","onViewModeChange","ref","svgRef","querySelector","length","getTotalLength","strokeDasharray","strokeDashoffset","getBoundingClientRect","values","mode","charAt","toUpperCase","slice","displayName","HOME_DIRECTORY_KEY","getHomeDirectory","localStorage","getItem","Sidebar","selectedFolder","onFolderChange","folders","currentHomeDir","setCurrentHomeDir","handleSetHome","folderPath","event","stopPropagation","setItem","setHomeDirectory","sidebar","loading","message","sidebarInner","logo","folderList","folderItem","role","tabIndex","onKeyDown","key","folderName","setHomeButton","isHome","title","FaHome","uploadButton","CUSTOM_PROPERTIES","DEFAULT_CUSTOM_PROPERTY_VALUES","CUSTOM_PROPERTIES_SCROLL_Y","CUSTOM_PROPERTIES_MOUSE_X","CUSTOM_PROPERTIES_MOUSE_Y","hexToVec3","hex","r","g","b","parseInt","lerpArray","end","t","val","i","lerp","AuraBackground$1","React","memo","canvasRef","glRef","programRef","bufferRef","attribLocationsRef","uniformLocationsRef","animationFrameRef","animatedColor1","animatedColor2","animatedMixFactor","animatedHoverPos","x","y","animatedIsHovering","createShader","gl","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","VERTEX_SHADER","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","renderLoop","time","requestAnimationFrame","timeSeconds","lerpSpeed","targetColor1","targetColor2","targetMix","targetIsHovering","targetPos","viewport","canvas","useProgram","bindBuffer","ARRAY_BUFFER","posLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","uniform2f","resolution","uniform1f","uniform3fv","colorTarget1","colorTarget2","colorMixFactor","uniform2fv","hoverPos","drawArrays","TRIANGLES","canvasElement","getContext","alpha","antialias","FRAGMENT_SHADER","detachShader","positions","Float32Array","createBuffer","bufferData","STATIC_DRAW","getAttribLocation","getUniformLocation","hoverColor","resizeObserver","ResizeObserver","entries","contentRect","observe","cancelAnimationFrame","disconnect","currentGl","deleteBuffer","overflow","zIndex","gsap","registerPlugin","ScrollToPlugin","Layout","mainRef","navbarRef","sidebarRef","contentAreaRef","updateCustomProperties","mouseX","clientX","mouseY","clientY","document","documentElement","setProperty","updateScrollProperty","scrollY","window","Object","property","addEventListener","removeEventListener","AuraBackground","useFolderImages","response","encodeURIComponent","Array","isArray","_a","statusText","request","getImages","enabled","placeholderData","previousData","STORE_NAME","dbPromise","getDb","dbPromise$1","openDB","upgrade","db","objectStoreNames","contains","createObjectStore","keyPath","ImageProcessor","constructor","options","__publicField","this","onError","concurrency","navigator","hardwareConcurrency","queue","PQueue","worker","Worker","URL","url","proxy","wrap","onerror","call","initializeCacheCheck","checkCacheForStaleBlobs","setPublisher","publisher","getCacheEntry","setCacheEntry","entry","put","deleteCacheEntry","allEntries","getAll","staleCount","shouldDelete","lowResUrl","startsWith","fetch","ok","highResUrl","processImage","image","src","cachedEntry","lowResMatches","lowResWidth","round","lowResHeight","highResMatches","_b","quality","imageUrl","_c","cacheError","activeRequests","controller","AbortController","createdBitmap","signal","aborted","DOMException","reason","blob","createImageBitmap","fetchError","_d","result","Comlink","transfer","imageBitmap","revokeObjectURL","finalEntry","timestamp","Date","now","_e","_f","_g","close","processBatch","images","batchId","random","toString","imagesToProcess","transferList","preCheckPromises","createdBitmaps","batchError","push","localBitmap","index","indexOf","splice","Promise","all","batchResults","cacheUpdatePromises","resultId","originalItem","find","item","originalWidth","originalHeight","existingEntry","bitmap","cancel","abort","clear","cancelAll","terminate","releaseProxy","then","_WorkerPool","layoutQueue","groupingQueue","colorQueue","getInstance","instance","initializeWorker","workerType","WorkerConstructor","setupListenersFn","resolve","reject","getImageProcessor","imageProcessor","isImageProcessorInitialized","cancelPendingImageTasks","getLayoutWorker","layoutWorkerPromise","LayoutWorker","layoutWorker","setupWorkerMessageHandler","pendingLayoutRequests","layoutWorkerListeners","getColorExtractorWorker","colorExtractorWorkerPromise","ColorExtractorWorker","colorExtractorWorker","pendingColorRequests","colorExtractorListeners","getGroupingWorker","groupingWorkerPromise","GroupingWorker","groupingWorker","pendingGroupingRequests","groupingWorkerListeners","pendingRequests","generalListeners","onmessage","requestId","clearTimeout","timer","payload","listener","postRequest","messageType","getWorkerPromise","bind","resolveTask","rejectTask","uuidv4","initError","responsePromise","resolveResponse","rejectResponse","timeoutMs","setTimeout","workerMessage","postMessage","postError","priority","addLayoutWorkerListener","removeLayoutWorkerListener","addColorExtractorListener","removeColorExtractorListener","addGroupingWorkerListener","removeGroupingWorkerListener","cancelPendingLayoutTasks","cancelTasks","cancelPendingColorTasks","cancelPendingGroupingTasks","cleanup","cancelAllPendingTasks","terminateWorker","WorkerPool","SCROLL_STATE_STORE_NAME","openScrollStateDB","saveScrollState","scrollTop","tx","transaction","store","objectStore","stateToSave","done","ScrollTrigger","_ScrollTriggerManager","timeline","paused","smoothChildTiming","mainTrigger","body","onUpdate","self","progress","markers","addAnimation","element","animationProps","animation","to","targets","removeAnimation","remove","kill","ScrollTriggerManager","CustomEase","_AnimationSystem","initializeCustomEases","scrollTriggerManager","getAnimationProperties","itemId","ease","transformOrigin","rotation","createHoverAnimation","force3D","createMorphAnimation","borderRadius","createScrollAnimation","AnimationSystem","calculateGapSize","baseGap","roundedGap","calculateLayout","config","containerWidth","columns","effectiveWidth","baseColumns","floor","calculateColumns","gap","minImageWidth","maxImageWidth","motionVariants","fadeIn","exit","hoverPop","rest","hover","gsapConfigs","defaults","vars","initialVars","overwrite","restVars","motionComponents","span","img","li","ul","p","h1","h2","h3","MotionPreset","as","preset","onMouseEnter","onMouseLeave","whileDrag","whileInView","MotionComponent","FallbackComponent","variants","defaultTransition","placeholderVariants","filter","imageVariants","delay","ResponsiveImage","alt","isProcessed","onLoad","handleLoad","handleError","useSrcSet","srcSet","join","sizes","ImageItem$1","containerHeight","groupCount","onResize","isCarousel","groupImages","onImageHover","onImageLoadError","dominantColor","imageRef","isHighResLoaded","setIsHighResLoaded","processedUrls","setProcessedUrls","hasError","setHasError","placeholderColor","targetWidth","targetHeight","aspectRatio","handleMouseEnter","rect","currentTarget","centerX","centerY","normalizedX","innerWidth","normalizedY","innerHeight","handleMouseLeave","handleProcessedImageUpdate","prev","unsubscribe","currentLowUrl","low","currentHighUrl","high","handleImageLoad","handleImageError","truncatedTitle","formattedTitle","replace","split","word","match","toLowerCase","trim","substring","truncateImageTitle","imageItem","layout","cursor","AnimatePresence","imageElement","inset","errorIndicator","overlay","groupIndicator","smoothLayoutTransition","mass","itemVariants","hidden","visible","ImageRow$1","imageWidths","onImageClick","isLastRow","rowHeight","groupedImages","workerPool","dominantColorMap","rowRef","display","flexWrap","marginBottom","willChange","maxWidth","justifyContent","alignItems","group","some","custom","flexShrink","flexGrow","ImageItem","ImageSkeleton","imageSkeleton","maxHeight","backgroundColor","skeletonAnimation","BannerView","NextArrow","props","FaChevronRight","PrevArrow","FaChevronLeft","CarouselView","Slider","dots","infinite","speed","slidesToShow","slidesToScroll","nextArrow","prevArrow","adaptiveHeight","customPaging","MasonryView","Masonry","breakpointCols","default","columnClassName","objectFit","debounce","func","waitFor","timeoutId","debounced","args","ImageFeed$1","scrollContainerRef","originalImages","isLoadingImages","isPlaceholderData","windowSize","setWindowSize","handleResize","newWidth","newHeight","debouncedResize","useWindowSize","feedRef","setContainerWidth","setColumns","lightboxIndex","setLightboxIndex","lightboxImages","setLightboxImages","setDominantColorMap","requestedColorIds","hoverTimeoutRef","restoredState","setRestoredState","previousFolderPathRef","rowHeightsRef","isRestoringScrollRef","velocityEMARef","dynamicOverscan","setDynamicOverscan","failedImageIds","setFailedImageIds","getImageUrl","imagePath","handleImageLoadError","newSet","calculatedRows","setCalculatedRows","isLayoutCalculating","setIsLayoutCalculating","processedGroupedImages","setProcessedGroupedImages","isGrouping","setIsGrouping","activeRequestRef","layoutDataMap","currentTop","row","currentLeft","imageList","layoutData","lookaheadDistance","throttleDelay","setViewport","bottom","processingRef","runPrefetchLogicRef","updateViewport","container","clientHeight","currentBottom","calculatePriority","imageLayout","imageCenterY","viewportCenterY","abs","runPrefetchLogicAsyncInternal","currentViewport","candidates","prefetchTop","prefetchBottom","imageTop","sort","a","processedCount","candidate","toFixed","finally","throttledRunPrefetch","throttle","passive","usePrefetchManager","debouncedIsGrouped","setDebouncedIsGrouped","updateDebouncedGrouped","newValue","debouncedSaveScroll","scroll","isMounted","loadedState","state","loadScrollState","loadAndSetState","currentPathForCleanup","scrollElement","folderToSave","imagesKey","avgAspectRatio","validImages","reduce","sum","layoutMetrics","gapSize","estimatedRowHeightFallback","totalGapWidth","availableWidthForImages","estimatedAvgImageWidth","layoutInputs","targetRowHeight","updateContainerWidthInternal","prevWidth","debouncedUpdateContainerWidth","useLayoutEffect","initialImageCount","imageInfo","GRID","groupingResult","firstImages","layoutResult","runPipeline","handleImageClick","clickedImage","groupIndex","findIndex","imageIndexInGroup","lastScrollTopRef","lastScrollTimeRef","performance","handleScroll","timeDelta","scrollDelta","velocity","calculatedOverscan","OVERSCAN_MAX","throttledScrollHandler","limit","inThrottle","apply","rowVirtualizer","useVirtualizer","count","getScrollElement","estimateSize","overscan","measure","virtualItems","getVirtualItems","handleImageHover","visibleImageIds","virtualItem","colorPromises","promise","colorValue","prevMap","newMap","allSettled","currentVisibleColors","itemColor","processor","lightboxPlugins","Captions","Counter","Thumbnails","Zoom","slides","feed","showLoadingState","gridContainer","gridTemplateColumns","padding","ViewComponent","MASONRY","BANNER","CAROUSEL","getTotalSize","measureElement","ImageRow","Lightbox","open","plugins","noImages","ImageViewer","ImageFeed","MainContent","searchQuery","Fragment","AnimationPipeline","addStep","presetConfig","tweenVars","gsap$1","steps","eventCallback","pause","reverse","seek","Home","setSelectedFolder","setZoom","setSearchQuery","setIsGrouped","setViewMode","mainScrollRef","layoutWrapperRef","homeEnterPipeline","pipelineRef","memoizedOptions","JSON","stringify","useAnimationPipeline","prevLoading","newZoom","newMode","AppContent","useAnimationController","App","render","html","ReactDOMServer","renderToString","StrictMode"],"mappings":"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"}