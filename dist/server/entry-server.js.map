{"version":3,"file":"entry-server.js","sources":["../../src/types/index.ts","../../src/utils/stringUtils.ts","../../src/contexts/ColorContext.tsx","../../src/utils/ScrollTriggerManager.ts","../../src/utils/AnimationSystem.ts","../../src/components/ImageItem.tsx","../../src/components/ImageRow.tsx","../../src/components/ImageSkeleton.tsx","../../src/lib/api.ts","../../src/hooks/query/useFolderImages.ts","../../src/lib/cache/feedStateCache.ts","../../src/utils/layoutCalculator.ts","../../src/workers/imageProcessor.ts","../../src/workers/workerPool.ts","../../src/components/AuraBackground.tsx","../../src/components/views/BannerView.tsx","../../src/components/views/CarouselView.tsx","../../src/components/views/MasonryView.tsx","../../src/components/ImageFeed.tsx","../../src/hooks/useWindowSize.ts","../../src/components/ImageViewer.tsx","../../src/components/MainContent.tsx","../../src/components/CurrentDirectoryButton.tsx","../../src/hooks/query/useCurrentDirectory.ts","../../src/components/SearchBar.tsx","../../src/components/ZoomSlider.tsx","../../src/components/Navbar.tsx","../../src/utils/settings.ts","../../src/components/Sidebar.tsx","../../src/hooks/query/useFolders.ts","../../src/utils/constants.ts","../../src/components/Layout.tsx","../../src/hooks/useCustomProperties.ts","../../src/pages/Home.tsx","../../src/App.tsx","../../src/entry-server.tsx"],"sourcesContent":["import { createImageProcessor } from '../workers/imageProcessor.js';\n\nexport interface ImageInfo {\n  id: string;\n  src: string;\n  alt: string;\n  title: string;\n  width: number;\n  height: number;\n  group?: {\n    key: string;\n    images: ImageInfo[];\n    isCarousel: boolean;\n  };\n}\n\nexport interface FolderInfo {\n  name: string;\n  path: string;\n}\n\nexport interface UploadProps {\n  selectedFolder: string;\n  onUploadComplete: () => void;\n}\n\nexport interface SearchProps {\n  onSearch: (query: string) => void;\n}\n\nexport interface ImageFeedProps {\n  images: ImageInfo[];\n  isLoading: boolean;\n}\n\nexport interface ImageRowProps {\n  images: ImageInfo[];\n  onImageClick: (image: ImageInfo, groupImages: ImageInfo[]) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  imageProcessor: ReturnType<typeof createImageProcessor>;\n}\n\nexport interface LayoutProps {\n  children: React.ReactNode;\n  folders: FolderInfo[];\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface NavbarProps {\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface GroupedImageInfo {\n  id: string;\n  title: string;\n  images: ImageInfo[];\n}\n\nexport enum ViewMode {\n  GRID = 'grid',\n  BANNER = 'banner',\n  MASONRY = 'masonry',\n  CAROUSEL = 'carousel',\n}\n","export function truncateImageTitle(title: string | undefined): string {\n  if (!title) return 'Untitled';\n\n  // Remove file extensions and common suffixes anywhere in the string\n  const cleanTitle = title\n    // Remove file extensions and version numbers\n    .replace(/\\.(preview|thumbnail|jpg|jpeg|png|gif|webp)/gi, '')\n    .replace(/[-_.](v\\d+|example|intro|concept)[-_.]?\\d*/gi, '')\n    // Remove technical suffixes and common patterns\n    .replace(/[-_.]?(flux|lora|ai|toolkit|preview|example\\d*|poster)[-_.]?/gi, ' ')\n    // Remove numbered suffixes like .0, .1, .2\n    .replace(/\\.\\d+$/, '')\n    // Remove long number sequences and IDs\n    .replace(/[-_.]?\\d{6,}[-_.]?/g, '')\n    // Remove underscore/dash/dot between numbers\n    .replace(/(\\d)[-_.](\\d)/g, '$1$2')\n    // Remove numbers at the end of titles (like \"Character Style 1\")\n    .replace(/\\s+\\d+$/, '')\n    // Clean up remaining underscores, dashes, dots and extra spaces\n    .replace(/[-_.]+/g, ' ')\n    .replace(/\\s+/g, ' ');\n\n  // Split into words and properly capitalize each word\n  const formattedTitle = cleanTitle\n    .split(' ')\n    .map(word => {\n      // Keep acronyms uppercase, capitalize first letter of other words\n      return word.match(/^[A-Z]{2,}$/)\n        ? word\n        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ')\n    .trim();\n\n  // Truncate if necessary\n  const maxLength = 30;\n  return formattedTitle.length > maxLength\n    ? formattedTitle.substring(0, maxLength) + '...'\n    : formattedTitle;\n}\n","import React, { createContext, ReactNode, useCallback, useMemo, useState } from 'react';\n\n// Define hover state structure\ninterface HoverState {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates [0, 1] relative to background\n  color: string | null; // Optional: Dominant color of hovered item\n}\n\n// Define the shape of the context data\ninterface ColorContextProps {\n  // Store maybe 1 or 2 dominant colors. Using string[] for flexibility.\n  dominantColors: string[];\n  setDominantColors: (colors: string[]) => void;\n  // Add hover state\n  hoverState: HoverState;\n  setHoverState: (newState: Partial<HoverState>) => void; // Allow partial updates\n}\n\n// Default initial background color (dark blueish)\nconst initialDefaultColor = '#041024';\n\n// Initial hover state\nconst initialHoverState: HoverState = {\n  isHovering: false,\n  position: null,\n  color: null,\n};\n\n// Create the context with a default value\nexport const ColorContext = createContext<ColorContextProps>({\n  dominantColors: [initialDefaultColor],\n  setDominantColors: () => {}, // No-op function as default\n  hoverState: initialHoverState,\n  setHoverState: () => {}, // No-op\n});\n\n// Create the provider component\ninterface ColorProviderProps {\n  children: ReactNode;\n}\n\nexport const ColorProvider: React.FC<ColorProviderProps> = ({ children }) => {\n  const [dominantColors, setDominantColorsState] = useState<string[]>([initialDefaultColor]);\n  const [hoverState, setHoverStateInternal] = useState<HoverState>(initialHoverState);\n\n  // Create a stable setter function that allows partial updates\n  const setHoverState = useCallback((newState: Partial<HoverState>) => {\n    setHoverStateInternal(prevState => ({ ...prevState, ...newState }));\n  }, []);\n\n  // Avoid re-creating the context value object on every render\n  const contextValue = useMemo(\n    () => ({\n      dominantColors,\n      setDominantColors: setDominantColorsState,\n      hoverState,\n      setHoverState, // Provide the stable setter\n    }),\n    [dominantColors, hoverState, setHoverState] // Add dependencies\n  );\n\n  return <ColorContext.Provider value={contextValue}>{children}</ColorContext.Provider>;\n};\n","import gsap from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\n\r\ngsap.registerPlugin(ScrollTrigger);\r\n\r\ninterface AnimationTarget {\r\n  element: HTMLElement;\r\n  animation: gsap.core.Tween | gsap.core.Timeline;\r\n}\r\n\r\nclass ScrollTriggerManager {\r\n  private static instance: ScrollTriggerManager;\r\n  private targets: Map<string, AnimationTarget> = new Map();\r\n  private timeline: gsap.core.Timeline;\r\n  private mainTrigger: ScrollTrigger;\r\n\r\n  private constructor() {\r\n    this.timeline = gsap.timeline({\r\n      paused: true,\r\n      smoothChildTiming: true,\r\n    });\r\n\r\n    // Create one main ScrollTrigger\r\n    this.mainTrigger = ScrollTrigger.create({\r\n      trigger: document.body,\r\n      start: 'top top',\r\n      end: 'bottom bottom',\r\n      onUpdate: self => {\r\n        // Update timeline progress based on scroll\r\n        this.timeline.progress(self.progress);\r\n      },\r\n      markers: false, // Always disable markers\r\n    });\r\n  }\r\n\r\n  static getInstance(): ScrollTriggerManager {\r\n    if (!ScrollTriggerManager.instance) {\r\n      ScrollTriggerManager.instance = new ScrollTriggerManager();\r\n    }\r\n    return ScrollTriggerManager.instance;\r\n  }\r\n\r\n  addAnimation(id: string, element: HTMLElement, animationProps: gsap.TweenVars) {\r\n    // Create the animation but don't play it yet\r\n    const animation = gsap.to(element, {\r\n      ...animationProps,\r\n      paused: true,\r\n    });\r\n\r\n    // Add it to our timeline\r\n    this.timeline.add(animation, 0);\r\n\r\n    // Store reference\r\n    this.targets.set(id, { element, animation });\r\n\r\n    return animation;\r\n  }\r\n\r\n  removeAnimation(id: string) {\r\n    const target = this.targets.get(id);\r\n    if (target) {\r\n      this.timeline.remove(target.animation);\r\n      this.targets.delete(id);\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    // Kill all ScrollTriggers to prevent memory leaks\r\n    this.targets.forEach(({ animation }) => {\r\n      animation.kill();\r\n    });\r\n\r\n    if (this.mainTrigger) {\r\n      this.mainTrigger.kill();\r\n    }\r\n\r\n    this.timeline.kill();\r\n    this.targets.clear();\r\n    ScrollTrigger.getAll().forEach(trigger => trigger.kill());\r\n  }\r\n}\r\n\r\nexport default ScrollTriggerManager;\r\n","import gsap from 'gsap';\nimport { CustomEase } from 'gsap/CustomEase';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport ScrollTriggerManager from './ScrollTriggerManager';\n\ngsap.registerPlugin(ScrollTrigger, CustomEase);\n\n// Simplified animation system without ripples and energy mechanics\nexport class AnimationSystem {\n  private static instance: AnimationSystem;\n  private scrollTriggerManager: ScrollTriggerManager;\n\n  private constructor() {\n    this.initializeCustomEases();\n    this.scrollTriggerManager = ScrollTriggerManager.getInstance();\n  }\n\n  private initializeCustomEases() {\n    CustomEase.create(\n      'smoothOut',\n      'M0,0 C0.126,0.382 0.282,0.674 0.44,0.822 0.632,1.002 0.818,1 1,1'\n    );\n    CustomEase.create('gentleIn', 'M0,0 C0.39,0 0.575,0.565 0.669,0.782 0.762,1 0.846,1 1,1');\n  }\n\n  static getInstance(): AnimationSystem {\n    if (!AnimationSystem.instance) {\n      AnimationSystem.instance = new AnimationSystem();\n    }\n    return AnimationSystem.instance;\n  }\n\n  getAnimationProperties(itemId: string): gsap.TweenVars {\n    return {\n      duration: 0.5,\n      ease: 'power2.out',\n      transformOrigin: 'center center',\n      scale: 1,\n      rotation: 0,\n    };\n  }\n\n  createHoverAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      scale: 1.05,\n      duration: 0.3,\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  createMorphAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      duration: 0.5,\n      borderRadius: '8px',\n      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  // New method that uses the ScrollTriggerManager for scroll-based animations\n  createScrollAnimation(element: HTMLElement, itemId: string, animationProps: gsap.TweenVars) {\n    return this.scrollTriggerManager.addAnimation(itemId, element, animationProps);\n  }\n}\n\nexport default AnimationSystem;\n","import { motion } from 'framer-motion';\nimport React, { memo, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { ColorContext } from '../contexts/ColorContext';\nimport styles from '../styles/ImageItem.module.scss';\nimport { ImageInfo } from '../types/index.js';\nimport AnimationSystem from '../utils/AnimationSystem';\nimport { truncateImageTitle } from '../utils/stringUtils.js';\nimport WorkerPool from '../workers/workerPool';\n\n// Define hover data payload\nexport interface ImageHoverData {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates relative to viewport/background\n  color: string | null; // Dominant color of the image, if available\n  imageId: string;\n}\n\n// Type for the processed image callback data\ninterface ProcessedImageData {\n  id: string;\n  quality: 'low' | 'high';\n  processedImage: string;\n}\n\ninterface ImageItemProps {\n  image: ImageInfo;\n  onClick: (image: ImageInfo) => void;\n  containerWidth: number;\n  containerHeight: number;\n  zoom: number;\n  groupCount?: number;\n  workerPool: WorkerPool;\n  onResize?: (width: number, height: number) => void;\n  width: number;\n  height: number;\n  isCarousel: boolean;\n  groupImages: ImageInfo[];\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n}\n\n// ResponsiveImage component (Refined & Forwarding Ref)\ninterface ResponsiveImageProps {\n  src: string;\n  alt: string;\n  width?: number;\n  isProcessed: boolean;\n  // isLoaded state is managed internally by ResponsiveImage now\n  onLoad: () => void;\n  onError: () => void;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst ResponsiveImage = React.forwardRef<HTMLImageElement, ResponsiveImageProps>(\n  ({ src, alt, width, isProcessed, onLoad, onError, className, style }, ref) => {\n    const [isInternallyLoaded, setIsInternallyLoaded] = useState(false);\n\n    // Reset loaded state if src changes\n    useEffect(() => {\n      setIsInternallyLoaded(false);\n    }, [src]);\n\n    const handleLoad = useCallback(() => {\n      setIsInternallyLoaded(true);\n      onLoad(); // Notify parent\n    }, [onLoad]);\n\n    const handleError = useCallback(() => {\n      setIsInternallyLoaded(false); // Ensure opacity stays 0 on error\n      onError(); // Notify parent\n    }, [onError]);\n\n    const useSrcSet = !isProcessed && width && !src.startsWith('blob:');\n    const srcSet = useSrcSet\n      ? [\n          `${src}&w=${Math.round(width as number)} 1x`,\n          `${src}&w=${Math.round((width as number) * 2)} 2x`,\n          `${src}&w=${Math.round((width as number) * 3)} 3x`,\n        ].join(', ')\n      : undefined;\n    const sizes = useSrcSet ? `${Math.round(width as number)}px` : undefined;\n\n    return (\n      <motion.img\n        ref={ref}\n        key={src}\n        src={src}\n        alt={alt}\n        className={className}\n        loading=\"lazy\"\n        style={{\n          display: 'block',\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n          position: 'absolute', // Position absolutely to overlay placeholder\n          top: 0,\n          left: 0,\n          ...style,\n        }}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: isInternallyLoaded ? 1 : 0 }} // Use internal loaded state\n        transition={{ duration: 0.4, ease: 'easeIn' }}\n        onLoad={handleLoad}\n        onError={handleError} // Use the internal error handler\n        srcSet={srcSet}\n        sizes={sizes}\n      />\n    );\n  }\n);\nResponsiveImage.displayName = 'ResponsiveImage';\n\nconst ImageItem: React.FC<ImageItemProps> = ({\n  image,\n  onClick,\n  containerWidth,\n  containerHeight,\n  zoom = 1,\n  groupCount,\n  workerPool,\n  onResize,\n  width,\n  height,\n  isCarousel = false,\n  groupImages = [],\n  onImageHover,\n  onImageLoadError,\n}) => {\n  const imageRef = useRef<HTMLImageElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  // isLoaded now primarily tracks if the HIGH-RES version is ready\n  const [isHighResLoaded, setIsHighResLoaded] = useState(false);\n  const [processedUrls, setProcessedUrls] = useState<{ low?: string; high?: string }>({});\n  const animationSystem = useMemo(() => AnimationSystem.getInstance(), []);\n  const { dominantColors } = useContext(ColorContext);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n  const processedRequestedRef = useRef(false);\n  const [hasError, setHasError] = useState(false);\n  const [hasLowResProcessed, setHasLowResProcessed] = useState(false);\n  const [hasHighResProcessed, setHasHighResProcessed] = useState(false);\n\n  // Get dominant color for placeholder - Use fallback only\n  const placeholderColor = useMemo(() => {\n    // Cannot use dominantColors[image.id] as it's likely string[]\n    // console.log('Dominant Colors from context:', dominantColors); // Optional: Log to see the actual structure\n    return '#333'; // Fallback color\n  }, [image.id]); // Remove dominantColors from dependency array\n\n  const targetWidth = containerWidth;\n  const targetHeight = containerHeight;\n\n  const aspectRatio = useMemo(() => {\n    // Use intrinsic image ratio if available and valid\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      return `${image.width} / ${image.height}`;\n    }\n    // Fallback based on container dimensions if intrinsic is missing/invalid\n    if (targetWidth > 0 && targetHeight > 0) {\n      return `${targetWidth} / ${targetHeight}`;\n    }\n    return '1 / 1'; // Default fallback aspect ratio (square)\n  }, [image.width, image.height, targetWidth, targetHeight]);\n\n  // Notify parent of size changes using cached dimensions\n  useEffect(() => {\n    if (onResize) {\n      onResize(targetWidth, targetHeight);\n    }\n  }, [targetWidth, targetHeight, onResize]);\n\n  // Hover Handlers (Only for Context Update)\n  const handleMouseEnter = useCallback(() => {\n    if (containerRef.current) {\n      // Calculate position and notify parent (for AuraBackground)\n      const rect = containerRef.current.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n\n      // Normalize position relative to viewport\n      const normalizedX = centerX / window.innerWidth;\n      const normalizedY = centerY / window.innerHeight;\n\n      // Cannot reliably get specific item color from context if it's just an array\n      const itemColor = null;\n      onImageHover({\n        isHovering: true,\n        position: { x: normalizedX, y: normalizedY },\n        color: itemColor,\n        imageId: image.id,\n      });\n    }\n  }, [onImageHover, image.id]); // Remove dominantColors from dependency array\n\n  const handleMouseLeave = useCallback(() => {\n    // Notify parent that hover ended (for AuraBackground)\n    console.log('[ImageItem Hover Leave]');\n    onImageHover({\n      isHovering: false,\n      position: null,\n      color: null,\n      imageId: image.id,\n    });\n  }, [onImageHover, image.id]);\n\n  // Callback for when the worker sends back processed data\n  const handleProcessedImage = useCallback(\n    (data: ProcessedImageData) => {\n      if (data.id === image.id) {\n        setProcessedUrls(prev => ({\n          ...prev,\n          [data.quality]: data.processedImage,\n        }));\n        // Track which versions have been processed\n        if (data.quality === 'low') {\n          setHasLowResProcessed(true);\n        }\n        if (data.quality === 'high') {\n          setHasHighResProcessed(true);\n          // Consider high-res loaded once its data URL is received\n          // setIsHighResLoaded(true); // Let ResponsiveImage's onLoad handle the final loaded state\n        }\n      }\n    },\n    [image.id]\n  );\n\n  // Observe when this item enters the viewport\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsIntersecting(entry.isIntersecting);\n        if (entry.isIntersecting) {\n          // Only request processing if intersecting and not already requested *for this item*\n          if (!processedRequestedRef.current && targetWidth > 0 && targetHeight > 0) {\n            const processor = workerPool.getImageProcessor();\n            processor.requestImageProcessing(\n              {\n                id: image.id,\n                src: image.src,\n                width: targetWidth,\n                height: targetHeight,\n              },\n              handleProcessedImage\n            );\n            processedRequestedRef.current = true;\n          } else if (processedRequestedRef.current) {\n            // console.log(... processing already requested ...);\n          } else {\n            // console.log(... dimensions invalid ...);\n          }\n        }\n      },\n      {\n        root: null, // Use the viewport as the root\n        rootMargin: '300px', // Trigger when item is 300px away from viewport\n        threshold: 0, // Trigger as soon as any part is visible\n      }\n    );\n\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [image.id, image.src, workerPool, targetWidth, targetHeight, handleProcessedImage]);\n\n  // --- Effect to Revoke Blob URLs ---\n  useEffect(() => {\n    // Create local copies of the URLs to revoke in the cleanup function\n    // Need to access the state directly inside cleanup for correct values on unmount\n    // const lowUrl = processedUrls.low;\n    // const highUrl = processedUrls.high;\n\n    // Cleanup function: Revokes the URLs ONLY when the component unmounts\n    return () => {\n      // Access the latest state values directly from the state variable\n      const currentLowUrl = processedUrls.low;\n      const currentHighUrl = processedUrls.high;\n      if (currentLowUrl) {\n        console.log(\n          `[ImageItem ${image.id}] Revoking low-res blob URL on unmount: ${currentLowUrl}`\n        );\n        URL.revokeObjectURL(currentLowUrl);\n      }\n      if (currentHighUrl) {\n        console.log(\n          `[ImageItem ${image.id}] Revoking high-res blob URL on unmount: ${currentHighUrl}`\n        );\n        URL.revokeObjectURL(currentHighUrl);\n      }\n    };\n    // Empty dependency array ensures cleanup runs only on unmount\n  }, []); // REMOVED dependencies\n\n  // Determine which src to use\n  const currentSrc = useMemo(() => {\n    // Prioritize high-res processed if available\n    if (processedUrls.high) return processedUrls.high;\n    // Fallback to low-res processed if available\n    if (processedUrls.low) return processedUrls.low;\n    // Otherwise, use the original image src\n    return image.src;\n  }, [processedUrls.high, processedUrls.low, image.src]);\n\n  // Determine if ANY processed version is being used\n  const isUsingProcessed = !!(processedUrls.high || processedUrls.low);\n\n  // Check if we should render the image component at all\n  const shouldRenderImage = hasLowResProcessed || hasHighResProcessed || (!hasError && currentSrc);\n\n  // Callback for when the <ResponsiveImage> finishes loading the displayed src\n  const handleImageLoad = useCallback(() => {\n    // If the high-res processed URL exists OR if we are directly loading the original src\n    // and it successfully loads, mark high-res as loaded.\n    if (processedUrls.high || (!hasLowResProcessed && !hasHighResProcessed)) {\n      setIsHighResLoaded(true);\n    }\n    setHasError(false); // Clear error state on successful load\n  }, [processedUrls.high, hasLowResProcessed, hasHighResProcessed]);\n\n  const handleImageError = useCallback(() => {\n    setHasError(true);\n    onImageLoadError(image.id); // Notify parent\n    // Potentially try fallback or mark as permanently failed?\n  }, [image.id, onImageLoadError]);\n\n  // Title for Tooltip\n  const truncatedTitle = useMemo(\n    () => truncateImageTitle(image.alt || image.title || 'Untitled'),\n    [image.alt, image.title]\n  );\n\n  // Conditional Rendering based on error\n  if (hasError) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className={styles.imageItemContainer}\n      onClick={() => !hasError && onClick(image)} // Prevent click if errored\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      style={{\n        width: `${targetWidth}px`,\n        height: `${targetHeight}px`,\n        aspectRatio: aspectRatio,\n        position: 'relative', // Needed for absolute positioning of img\n        overflow: 'hidden', // Ensure image doesn't overflow container\n        cursor: hasError ? 'not-allowed' : 'pointer',\n        backgroundColor: placeholderColor, // Use determined placeholder color\n      }}\n    >\n      {/* Placeholder logic removed - background color handles it */}\n\n      {/* Render image only if we have a src and no error, or if low-res is processed */}\n      {shouldRenderImage && (\n        <ResponsiveImage\n          ref={imageRef}\n          key={currentSrc} // Change key to force potential re-render/animation on src change\n          src={currentSrc}\n          alt={image.alt || image.id}\n          width={targetWidth} // Pass target width for potential srcSet\n          isProcessed={isUsingProcessed}\n          onLoad={handleImageLoad}\n          onError={handleImageError}\n          className={styles.imageElement}\n        />\n      )}\n\n      {/* Display error indicator if needed */}\n      {hasError && (\n        <div className={styles.errorOverlay}>\n          <span>Error</span>\n        </div>\n      )}\n\n      {/* Simplified Title Overlay */}\n      <div className={styles.titleOverlay}>{truncateImageTitle(image.alt || image.id)}</div>\n\n      {/* Add group indicator if needed */}\n      {groupCount && groupCount > 1 && <div className={styles.groupIndicator}>{groupCount}</div>}\n    </div>\n  );\n};\n\nexport default memo(ImageItem);\n","import { motion, useAnimation, Variants } from 'framer-motion';\nimport React, { useRef } from 'react';\nimport styles from '../styles/ImageRow.module.scss';\nimport { ImageInfo } from '../types/index.js';\n// import { createImageProcessor } from '../workers/imageProcessor'; // No longer needed directly\nimport WorkerPool from '../workers/workerPool'; // Import WorkerPool type\nimport ImageItem, { ImageHoverData } from './ImageItem.js';\n\n// Define the props interface for the ImageRow component\ninterface ImageRowProps {\n  images: ImageInfo[];\n  imageWidths: number[];\n  onImageClick: (clickedImage: ImageInfo) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  groupedImages: { key: string; images: ImageInfo[]; isCarousel: boolean }[];\n  workerPool: WorkerPool;\n  gap: number;\n  containerWidth: number;\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n}\n\n// Define a smoother transition for layout animations using a soft spring\nconst smoothLayoutTransition = {\n  type: 'spring', // Back to spring for a more natural feel\n  stiffness: 120, // Lower stiffness for less aggression\n  damping: 30, // Higher damping to reduce oscillation\n  mass: 1, // Standard mass\n  // Removed tween-specific parameters\n};\n\n// Define variants for item entrance animation\nconst itemVariants: Variants = {\n  hidden: { opacity: 0, scale: 0.95 },\n  visible: (i: number) => ({\n    // Accept custom data (index)\n    opacity: 1,\n    scale: 1,\n    transition: {\n      delay: i * 0.03, // Stagger the animation based on index\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  }),\n};\n\n// Define the ImageRow component\nconst ImageRow: React.FC<ImageRowProps> = ({\n  images,\n  imageWidths,\n  onImageClick,\n  columns,\n  zoom,\n  isLastRow,\n  rowHeight,\n  groupedImages,\n  workerPool,\n  gap,\n  containerWidth,\n  onImageHover,\n  onImageLoadError,\n}) => {\n  const rowRef = useRef<HTMLDivElement>(null);\n  const controls = useAnimation();\n\n  if (\n    !images ||\n    images.length === 0 ||\n    !imageWidths ||\n    imageWidths.length !== images.length ||\n    rowHeight <= 0\n  ) {\n    return null;\n  }\n\n  return (\n    <motion.div\n      ref={rowRef}\n      className={styles.imageRow}\n      animate={controls}\n      initial={false}\n      style={{\n        display: 'flex',\n        flexWrap: 'nowrap',\n        overflow: 'hidden',\n        gap: `${gap}px`,\n        height: `${rowHeight}px`,\n        marginBottom: `${gap}px`,\n        position: 'relative',\n        willChange: 'transform',\n        width: '100%',\n        maxWidth: `${containerWidth}px`,\n        justifyContent: 'flex-start',\n        alignItems: 'stretch',\n      }}\n      layout\n      transition={smoothLayoutTransition}\n    >\n      {images.map((image, index) => {\n        const group = groupedImages.find(g => g.images.some(img => img.id === image.id));\n        const width = imageWidths[index];\n\n        if (width === undefined || width <= 0) {\n          console.warn(\n            `Invalid width (${width}) calculated for image ${image.id} at index ${index}`\n          );\n          return null;\n        }\n\n        return (\n          <motion.div\n            key={image.id}\n            className={styles.imageWrapper}\n            custom={index}\n            initial=\"hidden\"\n            animate=\"visible\"\n            variants={itemVariants}\n            style={{\n              width: `${width}px`,\n              height: `${rowHeight}px`,\n              flexShrink: 0,\n              flexGrow: 0,\n              position: 'relative',\n              overflow: 'hidden',\n            }}\n            layout\n            transition={smoothLayoutTransition}\n          >\n            <ImageItem\n              image={image}\n              onClick={() => onImageClick(image)}\n              containerWidth={width}\n              containerHeight={rowHeight}\n              width={width}\n              height={rowHeight}\n              zoom={zoom}\n              isCarousel={group?.isCarousel || false}\n              groupImages={group?.images || []}\n              workerPool={workerPool}\n              onImageHover={onImageHover}\n              onImageLoadError={onImageLoadError}\n            />\n          </motion.div>\n        );\n      })}\n    </motion.div>\n  );\n};\n\n// Export the memoized component\nexport default React.memo(ImageRow);\n","import React from 'react';\nimport styles from '../styles/ImageItem.module.scss';\n\ninterface ImageSkeletonProps {\n  containerWidth: number;\n  containerHeight: number;\n}\n\nconst ImageSkeleton: React.FC<ImageSkeletonProps> = ({ containerWidth, containerHeight }) => {\n  return (\n    <div\n      className={`${styles.imageItem} ${styles.imageSkeleton}`}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        maxWidth: '100%',\n        maxHeight: '100%',\n        aspectRatio: `${containerWidth} / ${containerHeight}`,\n      }}\n    >\n      <div className={styles.skeletonAnimation}></div>\n    </div>\n  );\n};\n\nexport default ImageSkeleton;\n","import axios from 'axios';\nimport { FolderInfo, ImageInfo } from '../types/index.js';\n\nconst api = axios.create({\n  baseURL: '/api', // Assuming your API routes are under /api\n});\n\n/**\n * Fetches the list of folders from the server.\n *\n * @returns {Promise<FolderInfo[]>} A promise that resolves to an array of folder information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getFolders(): Promise<FolderInfo[]> {\n  try {\n    const response = await api.get('/folders');\n    return response.data.map((folder: { name: string; path: string }) => ({\n      name: folder.name,\n      path: folder.path,\n    }));\n  } catch (error) {\n    console.error('Error in getFolders:', error);\n    throw new Error('Failed to fetch folders');\n  }\n}\n\n/**\n * Fetches the list of images for a specific folder from the server.\n *\n * @param {string} folder - The name of the folder to fetch images from.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getImages(folder: string): Promise<ImageInfo[]> {\n  if (!folder) {\n    throw new Error('Folder parameter is required');\n  }\n\n  try {\n    const response = await api.get(`/images?folder=${encodeURIComponent(folder)}`);\n\n    if (!Array.isArray(response.data)) {\n      console.error('Invalid response data:', response.data);\n      throw new Error('Invalid response format from server');\n    }\n\n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      const message = error.response.data?.error || error.response.statusText;\n      throw new Error(`Server error: ${message}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      throw new Error('No response from server');\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.error('Error in getImages:', error);\n      throw new Error(error.message || 'Failed to fetch images');\n    }\n  }\n}\n/**\n * Uploads files to a specified folder on the server.\n *\n * @param {string} folder - The name of the folder to upload files to.\n * @param {File[]} files - An array of File objects to be uploaded.\n * @param {function} onProgress - A callback function to report upload progress.\n * @returns {Promise<void>} A promise that resolves when the upload is complete.\n * @throws Will throw an error if the API request fails.\n */\nexport async function uploadFiles(\n  folder: string,\n  files: File[],\n  onProgress: (progress: number) => void\n): Promise<void> {\n  const formData = new FormData();\n  formData.append('folder', folder);\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    await api.post('/upload', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data',\n      },\n      onUploadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(percentCompleted);\n        }\n      },\n    });\n  } catch (error) {\n    console.error('Error in uploadFiles:', error);\n    throw new Error('Failed to upload files');\n  }\n}\n/**\n * Searches for images across all folders based on a query string.\n *\n * @param {string} query - The search query string.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information matching the search query.\n * @throws Will throw an error if the API request fails.\n */\nexport async function searchImages(query: string): Promise<ImageInfo[]> {\n  try {\n    const response = await api.get(`/search?q=${encodeURIComponent(query)}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error in searchImages:', error);\n    throw new Error('Failed to search images');\n  }\n}\n\n/**\n * Fetches the current main directory from the server.\n *\n * @returns {Promise<string>} A promise that resolves to the current main directory path.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getCurrentDirectory(): Promise<string> {\n  try {\n    const response = await api.get('/getCurrentDirectory');\n    return response.data.currentDirectory;\n  } catch (error) {\n    console.error('Error in getCurrentDirectory:', error);\n    throw new Error('Failed to get current directory');\n  }\n}\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getImages } from '../../lib/api';\r\nimport { ImageInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch images for a specific folder using React Query.\r\n *\r\n * @param {string} folder - The name of the folder to fetch images from.\r\n * @returns The result object from useQuery, containing image data, loading state, error state, etc.\r\n */\r\nexport function useFolderImages(folder: string) {\r\n  return useQuery<ImageInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Includes the folder name so data is cached per folder.\r\n    queryKey: ['images', folder],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: () => getImages(folder),\r\n    // Enabled option: prevents the query from running if the folder is falsy (e.g., empty string, null, undefined).\r\n    enabled: !!folder,\r\n    // Use placeholderData to keep displaying the previous data while the new data is loading.\r\n    placeholderData: previousData => previousData,\r\n  });\r\n}\r\n","import { DBSchema, IDBPDatabase, openDB } from 'idb';\r\n\r\nconst UI_STATE_DB_NAME = 'mediaFlowUIScrollDB';\r\nconst SCROLL_STATE_STORE_NAME = 'scrollPosition';\r\nconst DB_VERSION = 1;\r\n\r\n// Define the structure of the state we want to store - ONLY scrollTop\r\nexport interface ScrollState {\r\n  scrollTop: number;\r\n  timestamp: number;\r\n}\r\n\r\n// Define the database schema\r\ninterface ScrollStateDB extends DBSchema {\r\n  [SCROLL_STATE_STORE_NAME]: {\r\n    key: string; // folderPath\r\n    value: ScrollState;\r\n  };\r\n}\r\n\r\n// Singleton promise to ensure DB is opened only once\r\nlet dbPromise: Promise<IDBPDatabase<ScrollStateDB>> | null = null;\r\n\r\nfunction openScrollStateDB(): Promise<IDBPDatabase<ScrollStateDB>> {\r\n  if (!dbPromise) {\r\n    dbPromise = openDB<ScrollStateDB>(UI_STATE_DB_NAME, DB_VERSION, {\r\n      upgrade(db) {\r\n        // Create the object store if it doesn't exist\r\n        if (!db.objectStoreNames.contains(SCROLL_STATE_STORE_NAME)) {\r\n          db.createObjectStore(SCROLL_STATE_STORE_NAME);\r\n        }\r\n      },\r\n    });\r\n  }\r\n  return dbPromise;\r\n}\r\n\r\n/**\r\n * Saves the scroll top position for a specific folder path to IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @param scrollTop - The scroll position to save.\r\n */\r\nexport async function saveScrollState(folderPath: string, scrollTop: number): Promise<void> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const stateToSave: ScrollState = {\r\n      scrollTop: scrollTop,\r\n      timestamp: Date.now(),\r\n    };\r\n    await store.put(stateToSave, folderPath);\r\n    await tx.done;\r\n  } catch (error) {\r\n    console.error('Failed to save scroll state for path:', folderPath, error);\r\n  }\r\n}\r\n\r\n/**\r\n * Loads the scroll state for a specific folder path from IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @returns The saved ScrollState object (containing scrollTop and timestamp) or null.\r\n */\r\nexport async function loadScrollState(folderPath: string): Promise<ScrollState | null> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readonly');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const state = await store.get(folderPath);\r\n    await tx.done;\r\n    return state ?? null;\r\n  } catch (error) {\r\n    console.error('Failed to load scroll state for path:', folderPath, error);\r\n    return null;\r\n  }\r\n}\r\n","import { ImageInfo, ViewMode } from '../types/index.js';\n\n// Constants\nexport const MIN_IMAGE_WIDTH = 200;\nexport const MAX_COLUMNS = 7;\nexport const MIN_COLUMNS = 1;\nexport const BASE_GAP = 4;\nexport const MIN_GAP = 2;\nexport const MAX_GAP = 12;\nexport const MIN_ZOOM = 0.5;\nexport const MAX_ZOOM = 3;\n\n// Types\nexport interface LayoutConfig {\n  containerWidth: number;\n  zoom: number;\n  viewMode: ViewMode;\n  isGrouped: boolean;\n}\n\nexport interface RowConfig {\n  width: number;\n  height: number;\n  gap: number;\n  images: ImageInfo[];\n  imageWidths?: number[];\n  offset?: number;\n}\n\nexport interface ImageDimensions {\n  width: number;\n  height: number;\n  aspectRatio: number;\n}\n\n// Cache for aspect ratios and dimensions\nconst aspectRatioCache = new WeakMap<ImageInfo, number>();\nconst layoutCache = new Map<string, RowConfig[]>();\n\n// Example: Caching sorted order of images\nconst sortedImagesCache = new Map<string, ImageInfo[]>();\n\nconst getSortedImages = (images: ImageInfo[]): ImageInfo[] => {\n  // Generate an identifier for the current order; could be a hash of ids\n  const cacheKey = images.map(img => img.id).join(',');\n  if (sortedImagesCache.has(cacheKey)) {\n    return sortedImagesCache.get(cacheKey)!;\n  }\n  // Sort images by aspect ratio (or any other criteria)\n  const sorted = [...images].sort((a, b) => a.width / a.height - b.width / b.height);\n  sortedImagesCache.set(cacheKey, sorted);\n  return sorted;\n};\n\n// Enhanced cache key generation with size awareness\nconst generateCacheKey = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  viewMode: string\n): string => {\n  return `${containerWidth}-${zoom}-${viewMode}-${images.map(img => img.id).join(',')}`;\n};\n\n// Cache invalidation threshold (in pixels)\nconst CACHE_INVALIDATION_THRESHOLD = 8;\n\nclass SizeAwareCache<T> {\n  private cache: Map<string, { data: T; width: number }>;\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, width: number): void {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, { data: value, width });\n  }\n\n  get(key: string, currentWidth: number): T | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    // Invalidate cache if width difference exceeds threshold\n    if (Math.abs(entry.width - currentWidth) > CACHE_INVALIDATION_THRESHOLD) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Replace existing caches with size-aware versions\nconst rowLayoutCache = new SizeAwareCache<RowConfig>(100);\nconst dimensionsCache = new SizeAwareCache<ImageDimensions>(500);\n\n// Core calculation functions\nexport const calculateColumns = (containerWidth: number, zoom: number): number => {\n  const effectiveWidth = containerWidth / zoom;\n  const baseColumns = Math.floor(effectiveWidth / (MIN_IMAGE_WIDTH * zoom));\n  return Math.min(Math.max(baseColumns, MIN_COLUMNS), MAX_COLUMNS);\n};\n\n// Add smooth zoom transition helper\nexport const interpolateZoom = (\n  currentZoom: number,\n  targetZoom: number,\n  progress: number\n): number => {\n  return currentZoom + (targetZoom - currentZoom) * progress;\n};\n\nexport const calculateGapSize = (zoom: number): number => {\n  // Normalize zoom level\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  // Calculate base gap size with finer granularity\n  const zoomFactor = (normalizedZoom - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);\n  const baseGap = BASE_GAP * (1 + zoomFactor * 0.25);\n\n  // Round to nearest even number to ensure consistent spacing\n  const roundedGap = Math.round(baseGap * 2) / 2;\n\n  // Ensure gap stays within bounds\n  return Math.min(Math.max(roundedGap, MIN_GAP), MAX_GAP);\n};\n\n// Optimized aspect ratio calculation with caching\nconst getAspectRatio = (image: ImageInfo): number => {\n  let ratio = aspectRatioCache.get(image);\n  if (!ratio) {\n    ratio = image.width / image.height;\n    aspectRatioCache.set(image, ratio);\n  }\n  return ratio;\n};\n\n// Batch process aspect ratios\nconst batchProcessAspectRatios = (images: ImageInfo[]): number[] => {\n  return images.map(getAspectRatio);\n};\n\n// Optimized image dimensions calculation with caching\nexport const calculateImageDimensions = (\n  image: ImageInfo,\n  containerWidth: number,\n  zoom: number\n): ImageDimensions => {\n  const cacheKey = generateCacheKey([image], containerWidth, zoom, 'dimensions');\n  const cachedDimensions = dimensionsCache.get(cacheKey, containerWidth);\n\n  if (cachedDimensions) {\n    return cachedDimensions;\n  }\n\n  const aspectRatio = getAspectRatio(image);\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  const maxWidth = Math.min(containerWidth, MIN_IMAGE_WIDTH * MAX_COLUMNS);\n  const baseWidth = Math.min(\n    Math.max(MIN_IMAGE_WIDTH * normalizedZoom, containerWidth / MAX_COLUMNS),\n    maxWidth\n  );\n\n  const width = Math.round(baseWidth);\n  const height = Math.round(width / aspectRatio);\n\n  const dimensions = { width, height, aspectRatio };\n  dimensionsCache.set(cacheKey, dimensions, containerWidth);\n\n  return dimensions;\n};\n\nexport const detectOverflow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number\n): boolean => {\n  const gap = calculateGapSize(zoom);\n  const totalWidth = images.reduce((sum, image) => {\n    const { width } = calculateImageDimensions(image, containerWidth, zoom);\n    return sum + width + gap;\n  }, -gap); // Subtract last gap\n\n  return totalWidth > containerWidth;\n};\n\n// Add new helper function for calculating optimal row distribution\nconst calculateOptimalDistribution = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { idealHeight: number; widths: number[] } => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate ideal height that would make images fill the width perfectly\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate widths based on aspect ratios and ideal height\n  const widths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  return { idealHeight, widths };\n};\n\n// Enhanced checkRowFit function\nconst checkRowFit = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { fits: boolean; idealHeight: number; predictedWidths: number[] } => {\n  const { idealHeight, widths } = calculateOptimalDistribution(images, containerWidth, zoom, gap);\n  const minWidth = MIN_IMAGE_WIDTH * zoom;\n\n  // Check if any image would be too narrow based on aspect ratio\n  const allImagesWideEnough = widths.every(width => width >= minWidth);\n\n  // Calculate total width including gaps\n  const totalWidth = widths.reduce((sum, width) => sum + width, 0) + (images.length - 1) * gap;\n\n  return {\n    fits: allImagesWideEnough && totalWidth <= containerWidth,\n    idealHeight,\n    predictedWidths: widths,\n  };\n};\n\n// Update distributeImages function\nexport const distributeImages = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  targetRowHeight: number = 200\n): RowConfig[] => {\n  if (containerWidth <= 0 || images.length === 0) {\n    console.warn('Invalid input detected');\n    return [];\n  }\n\n  const sortedImages = getSortedImages(images);\n  const gap = calculateGapSize(zoom);\n  const rows: RowConfig[] = [];\n  let currentRow: ImageInfo[] = [];\n  let currentRowAspectRatio = 0;\n\n  for (let i = 0; i < sortedImages.length; i++) {\n    const testRow = [...currentRow, sortedImages[i]];\n    const { fits, idealHeight, predictedWidths } = checkRowFit(testRow, containerWidth, zoom, gap);\n\n    if (!fits && currentRow.length > 0) {\n      // --- Finalize the current row ---\n      const { idealHeight, widths: currentWidths } = calculateOptimalDistribution(\n        currentRow,\n        containerWidth,\n        zoom,\n        gap\n      );\n      const rowHeight = Math.floor(idealHeight);\n      // Adjust widths to fit exactly\n      const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n      let calculatedWidthSum = 0;\n      const adjustedWidths = currentRow.map((img, index) => {\n        const width = Math.floor(getAspectRatio(img) * rowHeight);\n        calculatedWidthSum += width;\n        return width;\n      });\n\n      // Distribute remainder/deficit due to flooring\n      const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n      if (discrepancy !== 0 && adjustedWidths.length > 0) {\n        // Add discrepancy to the last image for simplicity\n        adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n      }\n\n      rows.push({\n        width: containerWidth,\n        height: rowHeight,\n        gap,\n        images: currentRow,\n        imageWidths: adjustedWidths, // Use adjusted widths\n        offset: 0,\n      });\n      // --- End finalize current row ---\n\n      // Start new row with current image\n      currentRow = [sortedImages[i]];\n      currentRowAspectRatio = getAspectRatio(sortedImages[i]);\n    } else {\n      // Add image to current row\n      currentRow = testRow;\n      currentRowAspectRatio += getAspectRatio(sortedImages[i]);\n    }\n  }\n\n  // Handle last row\n  if (currentRow.length > 0) {\n    // --- Finalize the last row ---\n    const { idealHeight, widths: initialWidths } = calculateOptimalDistribution(\n      currentRow,\n      containerWidth,\n      zoom,\n      gap\n    );\n    const rowHeight = Math.floor(idealHeight);\n    // Adjust widths to fit exactly\n    const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n    let calculatedWidthSum = 0;\n    const adjustedWidths = currentRow.map((img, index) => {\n      const width = Math.floor(getAspectRatio(img) * rowHeight);\n      calculatedWidthSum += width;\n      return width;\n    });\n\n    // Distribute remainder/deficit due to flooring\n    const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n    if (discrepancy !== 0 && adjustedWidths.length > 0) {\n      // Add discrepancy to the last image for simplicity\n      adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n    }\n\n    rows.push({\n      width: containerWidth,\n      height: rowHeight,\n      gap,\n      images: currentRow,\n      imageWidths: adjustedWidths, // Use adjusted widths\n      offset: 0,\n    });\n    // --- End finalize last row ---\n  }\n\n  return rows;\n};\n\n// Helper function to create a centered row\nconst createCenteredRow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): RowConfig => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate row height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate image widths based on aspect ratios and available width\n  const imageWidths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  // Calculate actual total width including gaps\n  const totalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n\n  // Distribute any remaining pixels to prevent rounding issues\n  const remainingPixels = containerWidth - totalWidth;\n  if (remainingPixels > 0 && imageWidths.length > 0) {\n    // Add remaining pixels to the first image to maintain alignment\n    imageWidths[0] += remainingPixels;\n  }\n\n  // Calculate centering offset\n  const offset = Math.floor((containerWidth - totalWidth) / 2);\n\n  return {\n    width: containerWidth,\n    height: Math.floor(idealHeight),\n    gap,\n    images,\n    imageWidths,\n    offset,\n  };\n};\n\n// Optimized row layout calculation\nexport const optimizeRowLayout = (\n  row: RowConfig,\n  containerWidth: number,\n  zoom: number\n): RowConfig => {\n  if (containerWidth <= 0) {\n    console.warn('Invalid container width detected in optimizeRowLayout');\n    return row;\n  }\n\n  const cacheKey = generateCacheKey(row.images, containerWidth, zoom, 'row');\n  const cachedLayout = rowLayoutCache.get(cacheKey, containerWidth);\n  if (cachedLayout) {\n    return cachedLayout;\n  }\n\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n  const baseGap = calculateGapSize(normalizedZoom);\n\n  // Ensure integer gaps to prevent rounding issues\n  const gap = Math.round(baseGap);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (row.images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting all gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  const aspectRatios = batchProcessAspectRatios(row.images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate ideal height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n  const minRequiredHeight = (MIN_IMAGE_WIDTH * zoom) / Math.max(...aspectRatios);\n  const maxAllowedHeight = availableWidth / totalAspectRatio;\n  const rowHeight = Math.round(\n    Math.max(minRequiredHeight, Math.min(maxAllowedHeight, idealHeight))\n  );\n\n  // Calculate initial image widths based on aspect ratios\n  const imageWidths = aspectRatios.map(ratio => Math.floor(rowHeight * ratio));\n\n  // Calculate total width of all images\n  const totalImageWidth = imageWidths.reduce((sum, width) => sum + width, 0);\n\n  // Calculate the remaining width to distribute\n  const remainingWidth = availableWidth - totalImageWidth;\n\n  if (remainingWidth !== 0 && imageWidths.length > 0) {\n    // Distribute remaining width evenly among all images\n    const widthPerImage = Math.floor(remainingWidth / imageWidths.length);\n    const extraPixels = remainingWidth % imageWidths.length;\n\n    // Add base distribution to all images\n    imageWidths.forEach((_, index) => {\n      imageWidths[index] += widthPerImage;\n    });\n\n    // Add any extra pixels to the first few images\n    for (let i = 0; i < extraPixels; i++) {\n      imageWidths[i] += 1;\n    }\n  }\n\n  // Verify total width matches container width exactly\n  const finalTotalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n  if (finalTotalWidth !== containerWidth && imageWidths.length > 0) {\n    // Add any remaining pixels to the first image\n    const diff = containerWidth - finalTotalWidth;\n    imageWidths[0] += diff;\n  }\n\n  const optimizedRow = {\n    ...row,\n    width: containerWidth,\n    height: rowHeight,\n    gap,\n    imageWidths,\n  };\n\n  rowLayoutCache.set(cacheKey, optimizedRow, containerWidth);\n  return optimizedRow;\n};\n\n// Layout calculation for different view modes\nexport const calculateLayout = (config: LayoutConfig) => {\n  const { containerWidth, zoom, viewMode, isGrouped } = config;\n  const columns = calculateColumns(containerWidth, zoom);\n  const gap = calculateGapSize(zoom);\n\n  return {\n    columns,\n    gap,\n    minImageWidth: MIN_IMAGE_WIDTH * zoom,\n    maxImageWidth: containerWidth / columns - gap,\n  };\n};\n\n// Utility function for maintaining aspect ratio\nexport const maintainAspectRatio = (\n  image: ImageInfo,\n  containerWidth: number,\n  containerHeight: number\n): { width: number; height: number } => {\n  const aspectRatio = getAspectRatio(image);\n  const containerRatio = containerWidth / containerHeight;\n\n  if (aspectRatio > containerRatio) {\n    return {\n      width: containerWidth,\n      height: Math.round(containerWidth / aspectRatio),\n    };\n  }\n\n  return {\n    width: Math.round(containerHeight * aspectRatio),\n    height: containerHeight,\n  };\n};\n","import { IDBPDatabase, openDB } from 'idb';\n\n// Interface for the data stored in IndexedDB\ninterface CachedProcessedImage {\n  id: string;\n  width?: number; // Dimensions at the time of caching\n  height?: number;\n  low?: string; // Blob URL for low-res\n  high?: string; // Blob URL for high-res\n}\n\ninterface ImageProcessorMessage {\n  action: 'processImage' | 'processBatch' | 'imageProcessed' | 'cancel';\n  images?: { id: string; src: string; width: number; height: number }[];\n  id?: string;\n  processedImage?: string;\n  quality?: 'low' | 'high';\n  width?: number;\n  height?: number;\n  src?: string;\n}\n\ntype ProcessedImageCallback = (data: {\n  id: string;\n  quality: 'low' | 'high';\n  processedImage: string;\n}) => void;\n\n// Helper function (can be defined outside the class or as a private static method)\nconst areDimensionsDifferent = (\n  cachedWidth: number | undefined,\n  cachedHeight: number | undefined,\n  requestedWidth: number,\n  requestedHeight: number,\n  threshold = 0.25 // Allow 25% difference in either dimension\n): boolean => {\n  if (\n    cachedWidth === undefined ||\n    cachedHeight === undefined ||\n    requestedWidth <= 0 || // Avoid division by zero\n    requestedHeight <= 0\n  ) {\n    return true; // Treat as different if cache dimensions missing or request invalid\n  }\n  const widthDiff = Math.abs(cachedWidth - requestedWidth) / requestedWidth;\n  const heightDiff = Math.abs(cachedHeight - requestedHeight) / requestedHeight;\n\n  // console.log(`Dim Check (${cachedWidth}x${cachedHeight} vs ${requestedWidth}x${requestedHeight}): WDiff=${widthDiff.toFixed(2)}, HDiff=${heightDiff.toFixed(2)}`);\n\n  return widthDiff > threshold || heightDiff > threshold;\n};\n\nclass ImageProcessor {\n  private worker: Worker;\n  private db: IDBPDatabase<{\n    processedImages: { key: string; value: CachedProcessedImage };\n  }> | null = null;\n  private requestQueue: {\n    type: 'image' | 'batch';\n    payload: any;\n    callback?: ProcessedImageCallback;\n  }[] = [];\n  private isProcessing = false;\n  private isWorkerCancelled = false;\n  private callbacks: Map<string, ProcessedImageCallback[]> = new Map();\n\n  constructor() {\n    this.worker = new Worker(new URL('./imageProcessorWorker.ts', import.meta.url));\n    this.initDB();\n    this.worker.onmessage = this.handleWorkerMessage.bind(this);\n    this.worker.onerror = error => {\n      console.error('Error in ImageProcessorWorker:', error);\n      this.isProcessing = false;\n      this.processNextRequest();\n    };\n  }\n\n  private async initDB() {\n    try {\n      this.db = await openDB('imageCache', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('processedImages')) {\n            db.createObjectStore('processedImages', { keyPath: 'id' });\n          }\n        },\n      });\n\n      // --- Add Cache Invalidation Logic ---\n      if (this.db) {\n        console.log('ImageProcessor: Checking cache for stale blob URLs...');\n        const tx = this.db.transaction('processedImages', 'readwrite');\n        const store = tx.objectStore('processedImages');\n        let cursor = await store.openCursor();\n        let staleCount = 0;\n\n        while (cursor) {\n          const value = cursor.value;\n          // Check if low or high quality URLs are persisted blob URLs\n          const isLowStale = value.low?.startsWith('blob:');\n          const isHighStale = value.high?.startsWith('blob:');\n\n          if (isLowStale || isHighStale) {\n            // If any blob URL is found, delete the entire entry as it's stale\n            await cursor.delete();\n            staleCount++;\n            // console.log(`ImageProcessor: Deleted stale cache entry for ${value.id}`);\n          }\n          cursor = await cursor.continue();\n        }\n        await tx.done;\n        if (staleCount > 0) {\n          console.log(`ImageProcessor: Removed ${staleCount} stale cache entries.`);\n        } else {\n          console.log('ImageProcessor: No stale blob URLs found in cache.');\n        }\n      }\n      // --- End Cache Invalidation Logic ---\n    } catch (error) {\n      console.error('Failed to initialize IndexedDB for image cache:', error);\n      this.db = null;\n    }\n  }\n\n  private async getCachedImageData(id: string): Promise<CachedProcessedImage | null> {\n    if (!this.db) return null;\n    try {\n      return ((await this.db.get('processedImages', id)) as CachedProcessedImage | null) ?? null;\n    } catch (error) {\n      console.error(`Failed to get cached image data for ${id}:`, error);\n      return null;\n    }\n  }\n\n  private async cacheImageData(\n    id: string,\n    quality: 'low' | 'high',\n    imageDataUrl: string,\n    width: number,\n    height: number\n  ) {\n    if (!this.db) return;\n    try {\n      const tx = this.db.transaction('processedImages', 'readwrite');\n      const store = tx.objectStore('processedImages');\n      const existingData = await store.get(id);\n\n      const newData: CachedProcessedImage = {\n        ...(existingData || {}),\n        id: id,\n        width: width,\n        height: height,\n        [quality]: imageDataUrl,\n      };\n\n      await store.put(newData);\n      await tx.done;\n    } catch (error) {\n      console.error(`Failed to cache image data for ${id} (${quality}):`, error);\n    }\n  }\n\n  private async processNextRequest() {\n    if (this.isProcessing || this.requestQueue.length === 0) return;\n\n    this.isProcessing = true;\n    const request = this.requestQueue.shift()!;\n\n    if (this.isWorkerCancelled && request.type !== 'image' && request.type !== 'batch') {\n      console.log('ImageProcessor: Worker cancelled, skipping non-processing request.');\n      this.isProcessing = false;\n      this.processNextRequest();\n      return;\n    }\n\n    if (request.type === 'image') {\n      this.isWorkerCancelled = false;\n      await this.processImageRequest(request.payload, request.callback);\n    } else if (request.type === 'batch') {\n      this.isWorkerCancelled = false;\n      await this.processBatchRequest(request.payload, request.callback);\n    }\n\n    this.isProcessing = false;\n    setTimeout(() => this.processNextRequest(), 0);\n  }\n\n  private async processImageRequest(\n    image: { id: string; src: string; width: number; height: number },\n    callback?: ProcessedImageCallback\n  ) {\n    const { id, src, width: requestedWidth, height: requestedHeight } = image;\n\n    // 1. Check Cache\n    const cachedData = await this.getCachedImageData(id);\n\n    // 2. Determine if Cache is Usable\n    let needsProcessing = true;\n    let reason = 'No cache found';\n\n    if (cachedData) {\n      if (cachedData.high) {\n        // Check if dimensions match the current request\n        const dimensionsMatch = !areDimensionsDifferent(\n          cachedData.width, // Use optional chaining or ensure it exists\n          cachedData.height,\n          requestedWidth,\n          requestedHeight\n        );\n\n        if (dimensionsMatch) {\n          needsProcessing = false;\n          reason = 'Cache hit (matching dimensions)';\n          console.log(`ImageProcessor: Cache hit for ${id} with matching dimensions.`);\n\n          // Trigger callback immediately with cached data\n          if (callback) {\n            if (cachedData.low) {\n              callback({ id: id, quality: 'low', processedImage: cachedData.low });\n            }\n            callback({ id: id, quality: 'high', processedImage: cachedData.high });\n          }\n        } else {\n          needsProcessing = true;\n          reason = 'Cache found but dimensions mismatch';\n          console.log(\n            `ImageProcessor: Cache found for ${id} but dimensions mismatch. Requesting re-processing.`\n          );\n          // Don't use cached blobs, proceed to worker request\n        }\n      } else {\n        needsProcessing = true;\n        reason = 'Cache found but high-res missing';\n        console.log(\n          `ImageProcessor: Cache found for ${id} but high-res missing. Requesting processing.`\n        );\n        // Trigger callback with low-res if available, but still request full processing\n        if (cachedData.low && callback) {\n          callback({ id: id, quality: 'low', processedImage: cachedData.low });\n        }\n      }\n    }\n\n    // 3. Request Processing from Worker if Needed\n    if (needsProcessing) {\n      console.log(`ImageProcessor: Sending image ${id} to worker. Reason: ${reason}`);\n      // Register callback before sending to worker\n      if (callback) {\n        const existingCallbacks = this.callbacks.get(id) || [];\n        if (!existingCallbacks.includes(callback)) {\n          this.callbacks.set(id, [...existingCallbacks, callback]);\n        }\n      }\n      // Send request with current dimensions\n      this.worker.postMessage({\n        action: 'processImage',\n        id,\n        src,\n        width: requestedWidth,\n        height: requestedHeight,\n      });\n    }\n  }\n\n  private async processBatchRequest(\n    images: { id: string; src: string; width: number; height: number }[],\n    batchCallback?: ProcessedImageCallback\n  ) {\n    const imagesToSendToWorker = [];\n    const DIMENSION_THRESHOLD = 0.1; // Same threshold as single image\n\n    for (const image of images) {\n      const { id, src, width: requestedWidth, height: requestedHeight } = image;\n      const cachedData = await this.getCachedImageData(id);\n\n      let needsProcessing = true;\n      if (cachedData?.high) {\n        const dimensionsMatch = !areDimensionsDifferent(\n          cachedData.width,\n          cachedData.height,\n          requestedWidth,\n          requestedHeight,\n          DIMENSION_THRESHOLD\n        );\n        if (dimensionsMatch) {\n          needsProcessing = false;\n          // Trigger callback immediately with cached data if provided\n          if (batchCallback) {\n            if (cachedData.low)\n              batchCallback({ id: id, quality: 'low', processedImage: cachedData.low });\n            batchCallback({ id: id, quality: 'high', processedImage: cachedData.high });\n          }\n        } // else: dimensions mismatch, needs processing\n      } else if (cachedData?.low && batchCallback) {\n        // If only low-res cached, trigger callback for low-res but still process\n        batchCallback({ id: id, quality: 'low', processedImage: cachedData.low });\n      }\n\n      if (needsProcessing) {\n        imagesToSendToWorker.push(image); // Add to worker batch\n        // Register callback for this image\n        if (batchCallback) {\n          const existingCallbacks = this.callbacks.get(id) || [];\n          if (!existingCallbacks.includes(batchCallback)) {\n            this.callbacks.set(id, [...existingCallbacks, batchCallback]);\n          }\n        }\n      }\n    }\n\n    if (imagesToSendToWorker.length > 0) {\n      console.log(\n        `ImageProcessor: Sending batch of ${imagesToSendToWorker.length} images to worker (out of ${images.length}).`\n      );\n      this.worker.postMessage({ action: 'processBatch', images: imagesToSendToWorker });\n    } else {\n      console.log(\n        `ImageProcessor: All ${images.length} batch images were already fully cached with matching dimensions.`\n      );\n    }\n  }\n\n  private handleWorkerMessage(event: MessageEvent<ImageProcessorMessage>) {\n    if (\n      event.data.action === 'imageProcessed' &&\n      event.data.id &&\n      event.data.processedImage &&\n      event.data.quality &&\n      event.data.width !== undefined &&\n      event.data.height !== undefined\n    ) {\n      const { id, quality, processedImage, width, height } = event.data;\n\n      console.log(\n        `ImageProcessor received processed image: ${id}, quality: ${quality}, size: ${width}x${height}`\n      );\n\n      this.cacheImageData(id, quality, processedImage, width, height);\n\n      const imageCallbacks = this.callbacks.get(id);\n      if (imageCallbacks) {\n        imageCallbacks.forEach(cb => cb({ id, quality, processedImage }));\n        if (quality === 'high') {\n          this.callbacks.delete(id);\n        }\n      }\n    } else {\n      console.warn(\n        'ImageProcessor received incomplete or unexpected message from worker:',\n        event.data\n      );\n    }\n    this.isProcessing = false;\n    this.processNextRequest();\n  }\n\n  public requestImageProcessing(\n    image: { id: string; src: string; width: number; height: number },\n    callback?: ProcessedImageCallback\n  ) {\n    this.requestQueue.push({ type: 'image', payload: image, callback });\n    // Ensure the processing loop is triggered if not already running\n    if (!this.isProcessing) {\n      this.processNextRequest();\n    }\n  }\n\n  public requestBatchProcessing(\n    images: { id: string; src: string; width: number; height: number }[],\n    callback?: ProcessedImageCallback\n  ) {\n    this.requestQueue.push({ type: 'batch', payload: images, callback });\n    // Ensure the processing loop is triggered if not already running\n    if (!this.isProcessing) {\n      this.processNextRequest();\n    }\n  }\n\n  public cancel() {\n    console.log('ImageProcessor: Clearing request queue and sending cancel to worker.');\n    this.requestQueue = [];\n    this.callbacks.clear();\n    this.isWorkerCancelled = true;\n    this.worker.postMessage({ action: 'cancel' });\n    this.isProcessing = false;\n  }\n\n  public terminate() {\n    console.log('ImageProcessor: Terminating worker and closing DB.');\n    this.cancel();\n    this.worker.terminate();\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n}\n\nexport function createImageProcessor() {\n  return new ImageProcessor();\n}\n","import { createImageProcessor } from './imageProcessor.js';\n\n// Define the type for the processor instance more explicitly\ntype ImageProcessorInstance = ReturnType<typeof createImageProcessor>;\n\nclass WorkerPool {\n  private static instance: WorkerPool;\n  // Use the more specific type\n  private imageProcessor: ImageProcessorInstance | null = null;\n  private isInitialized = false;\n\n  private constructor() {}\n\n  public static getInstance(): WorkerPool {\n    if (!WorkerPool.instance) {\n      WorkerPool.instance = new WorkerPool();\n    }\n    return WorkerPool.instance;\n  }\n\n  // Use the more specific return type\n  public getImageProcessor(): ImageProcessorInstance {\n    if (!this.imageProcessor) {\n      console.log('WorkerPool: Initializing Image Processor...');\n      this.imageProcessor = createImageProcessor();\n      this.isInitialized = true;\n    } else {\n      // console.log('WorkerPool: Returning existing Image Processor.');\n    }\n    return this.imageProcessor;\n  }\n\n  // Add method to cancel pending tasks\n  public cancelPendingTasks() {\n    if (this.imageProcessor && this.isInitialized) {\n      console.log('WorkerPool: Cancelling pending image processing tasks...');\n      this.imageProcessor.cancel();\n    } else {\n      console.log('WorkerPool: No active image processor to cancel tasks for.');\n    }\n  }\n\n  public cleanup() {\n    if (this.imageProcessor && this.isInitialized) {\n      console.log('WorkerPool: Cleaning up Image Processor...');\n      // Call terminate which now includes cancel logic\n      this.imageProcessor.terminate();\n      this.imageProcessor = null;\n      this.isInitialized = false;\n    } else {\n      console.log('WorkerPool: No active image processor to clean up.');\n    }\n  }\n}\n\nexport default WorkerPool;\n","import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { ColorContext } from '../contexts/ColorContext'; // Import ColorContext\nimport styles from '../styles/ParticleBackground.module.scss'; // Reuse or create new styles\n\n// Convert hex color string to vec3 [r, g, b] (normalized 0-1)\nconst hexToVec3 = (hex: string): [number, number, number] => {\n  let r = 0,\n    g = 0,\n    b = 0;\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(hex[1] + hex[1], 16);\n    g = parseInt(hex[2] + hex[2], 16);\n    b = parseInt(hex[3] + hex[3], 16);\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(hex[1] + hex[2], 16);\n    g = parseInt(hex[3] + hex[4], 16);\n    b = parseInt(hex[5] + hex[6], 16);\n  }\n  return [r / 255, g / 255, b / 255];\n};\n\n// Linear interpolation function for arrays (like colors)\nconst lerpArray = (start: number[], end: number[], t: number): number[] => {\n  return start.map((val, i) => val + (end[i] - val) * t);\n};\n\n// Linear interpolation for single values\nconst lerp = (start: number, end: number, t: number): number => {\n  return start + (end - start) * t;\n};\n\n// --- WebGL Shaders (Refined for Aura Effect) ---\n\n// Vertex Shader (Remains the same - simple quad pass-through)\nconst vertexShaderSource = `\n  precision mediump float;\n  attribute vec2 a_position; // Vertex position (-1 to 1)\n  varying vec2 v_uv;         // Pass UV coordinates (0 to 1) to fragment shader\n\n  void main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_uv = (a_position + 1.0) * 0.5; // Convert clip space to UV space\n    v_uv.y = 1.0 - v_uv.y; // Flip Y for texture/canvas coordinate system\n  }\n`;\n\n// Fragment Shader: Updated with noise functions for a more organic background\nconst fragmentShaderSource = `\n  precision mediump float;\n  varying vec2 v_uv; // UV coordinates from vertex shader\n\n  uniform vec2 u_resolution;    // Canvas resolution\n  uniform float u_time;        // Time for animations\n  uniform vec3 u_colorTarget1;  // Base color 1\n  uniform vec3 u_colorTarget2;  // Base color 2\n  uniform float u_colorMixFactor; // Mix factor for base colors\n\n  // Hover state uniforms\n  uniform bool u_isHovering;\n  uniform vec2 u_hoverPos;      // Normalized hover position (0-1)\n  uniform vec3 u_hoverColor;    // Optional: Color associated with hover\n\n  // --- Noise Functions ---\n  // Simple pseudo-random number generator\n  float random (vec2 st) {\n      // Adjusted seed based on example, can be tweaked\n      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n  }\n\n  // Basic Value Noise function\n  float noise (vec2 st) {\n      vec2 i = floor(st); // Integer part\n      vec2 f = fract(st); // Fractional part\n\n      // Get random values for the 4 corners surrounding the point\n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n\n      // Smoothly interpolate between the corner values (smoothstep)\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      // Interpolate horizontally, then vertically\n      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n  }\n\n  // Fractional Brownian Motion (fBm) - layering noise\n  #define OCTAVES 4 // Number of noise layers (adjust for detail/performance)\n  float fbm (vec2 st) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 0.0;\n      // Loop through octaves, adding noise at different frequencies/amplitudes\n      for (int i = 0; i < OCTAVES; i++) {\n          value += amplitude * noise(st);\n          st *= 2.0; // Double frequency for next octave\n          amplitude *= 0.5; // Halve amplitude for next octave\n      }\n      return value;\n  }\n  // --- End Noise Functions ---\n\n  // Function to calculate distance from hover point (same as before)\n  float getHoverDist(vec2 pos) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    vec2 diff = pos - u_hoverPos;\n    diff.x *= aspectRatio;\n    return distance(vec2(0.0), diff);\n  }\n\n  void main() {\n    // --- Calculate Base Aura Color using Noise ---\n    // Scale UV and add time for animation. Adjust scale (e.g., * 3.0) for noise detail.\n    vec2 noisyCoord = v_uv * 2.5 + vec2(u_time * 0.02, u_time * 0.03); // Slow movement\n    float noisePattern = fbm(noisyCoord);\n\n    // Base color blend - mix between target colors\n    vec3 baseColor = mix(u_colorTarget1, u_colorTarget2, u_colorMixFactor);\n\n    // Modulate the base color blend using the noise pattern\n    // Mix based on noise value AND vertical position for variety\n    vec3 auraColor = mix(baseColor, mix(u_colorTarget1, u_colorTarget2, v_uv.y * 0.8 + 0.1), noisePattern * 0.6);\n    // Add subtle contrast/brightness variation based on noise\n    auraColor *= (0.9 + noisePattern * 0.2);\n\n    // --- Hover Effect (Applied on top of aura) ---\n    vec3 finalColor = auraColor;\n    if (u_isHovering) {\n      float dist = getHoverDist(v_uv);\n      // Ripple/glow effect - use smoothstep for soft edges\n      float hoverIntensity = smoothstep(0.20, 0.0, dist); // Increased radius slightly\n\n      // Make the glow slightly colored (e.g., whitish or based on u_hoverColor if available)\n      vec3 glowColor = vec3(0.8, 0.8, 0.9); // Whitish glow\n      // Optionally use u_hoverColor: mix(glowColor, u_hoverColor, 0.5)\n\n      // Additive blend for glow, stronger near center\n      finalColor += glowColor * hoverIntensity * 0.6; // Adjust intensity multiplier\n\n      // Optional: Slight displacement/warp effect (more complex)\n      // vec2 displacement = normalize(v_uv - u_hoverPos) * hoverIntensity * 0.01;\n      // Recalculate noise/color at v_uv - displacement ? (performance cost)\n    }\n\n    // Ensure color values stay within valid range\n    gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n  }\n`;\n\n// --- Component ---\nconst AuraBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const bufferRef = useRef<WebGLBuffer | null>(null); // Single buffer for a quad\n  const attribLocationsRef = useRef<{ [key: string]: number }>({});\n  const uniformLocationsRef = useRef<{ [key: string]: WebGLUniformLocation | null }>({});\n  const animationFrameRef = useRef<number>();\n  const { dominantColors, hoverState } = useContext(ColorContext);\n\n  // Refs for animated uniform values (colors and hover state)\n  const animatedColor1 = useRef(hexToVec3(dominantColors[0] || '#041024'));\n  const animatedColor2 = useRef(hexToVec3(dominantColors[1] || dominantColors[0] || '#041024'));\n  const animatedMixFactor = useRef(dominantColors.length > 1 ? 1.0 : 0.0);\n  const animatedHoverPos = useRef<[number, number] | null>(\n    hoverState.position ? [hoverState.position.x, hoverState.position.y] : null\n  );\n  const animatedIsHovering = useRef(hoverState.isHovering ? 1.0 : 0.0); // Use float for smooth transition\n\n  // --- WebGL Helper Functions ---\n  const createShader = useCallback(\n    (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\n          `Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`,\n          gl.getShaderInfoLog(shader)\n        );\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    },\n    []\n  );\n\n  const createProgram = useCallback(\n    (\n      gl: WebGLRenderingContext,\n      vertexShader: WebGLShader,\n      fragmentShader: WebGLShader\n    ): WebGLProgram | null => {\n      const program = gl.createProgram();\n      if (!program) return null;\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program link error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return null;\n      }\n      return program;\n    },\n    []\n  );\n\n  // --- Animation Loop ---\n  const renderLoop = useCallback(\n    (time: number) => {\n      const gl = glRef.current;\n      const program = programRef.current;\n      if (!gl || !program) {\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\n        return;\n      }\n      const timeSeconds = time / 1000.0;\n\n      // --- Smooth Animation Logic (Lerping) ---\n      const lerpSpeed = 0.08; // Adjust for desired transition speed\n\n      // Animate Colors\n      const targetColor1 = hexToVec3(dominantColors[0] || '#041024');\n      const targetColor2 = hexToVec3(dominantColors[1] || dominantColors[0] || '#041024');\n      const targetMix = dominantColors.length > 1 ? 1.0 : 0.0;\n      animatedColor1.current = lerpArray(animatedColor1.current, targetColor1, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedColor2.current = lerpArray(animatedColor2.current, targetColor2, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedMixFactor.current = lerp(animatedMixFactor.current, targetMix, lerpSpeed);\n\n      // Animate Hover State\n      const targetIsHovering = hoverState.isHovering ? 1.0 : 0.0;\n      animatedIsHovering.current = lerp(\n        animatedIsHovering.current,\n        targetIsHovering,\n        lerpSpeed * 2\n      ); // Faster hover transition\n\n      if (hoverState.isHovering && hoverState.position) {\n        const targetPos: [number, number] = [hoverState.position.x, hoverState.position.y];\n        if (!animatedHoverPos.current) {\n          animatedHoverPos.current = targetPos; // Snap if starting from null\n        } else {\n          animatedHoverPos.current = lerpArray(\n            animatedHoverPos.current,\n            targetPos,\n            lerpSpeed * 2\n          ) as [number, number];\n        }\n      } else {\n        // Optionally, let the hover position fade out or just keep the last known position\n        // For now, we'll just use the latest position when hovering is true\n      }\n\n      // --- WebGL Rendering ---\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      // No need to clear if drawing a full-screen quad that covers everything\n      // gl.clearColor(0, 0, 0, 0);\n      // gl.clear(gl.COLOR_BUFFER_BIT);\n\n      // Log context state and calculated animation values\n      // console.log('[AuraBackground Loop] Context HoverState:', hoverState);\n      // console.log('[AuraBackground Loop] Animated Hover:', { isHovering: animatedIsHovering.current, pos: animatedHoverPos.current });\n\n      gl.useProgram(program);\n\n      // Bind the quad buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n      const posLocation = attribLocationsRef.current.position;\n      if (posLocation !== -1) {\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(posLocation);\n      }\n\n      // Set Uniforms\n      gl.uniform2f(uniformLocationsRef.current.resolution, gl.canvas.width, gl.canvas.height);\n      gl.uniform1f(uniformLocationsRef.current.time, timeSeconds);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget1, animatedColor1.current);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget2, animatedColor2.current);\n      gl.uniform1f(uniformLocationsRef.current.colorMixFactor, animatedMixFactor.current);\n\n      // Hover Uniforms\n      gl.uniform1f(\n        uniformLocationsRef.current.isHovering,\n        animatedIsHovering.current > 0.01 ? 1.0 : 0.0\n      ); // Use threshold for bool\n      if (animatedHoverPos.current) {\n        gl.uniform2fv(uniformLocationsRef.current.hoverPos, animatedHoverPos.current);\n      }\n      // gl.uniform3fv(uniformLocationsRef.current.hoverColor, hoverState.color ? hexToVec3(hoverState.color) : [0,0,0]); // TODO: Add hover color logic\n\n      // Draw the quad (2 triangles)\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      animationFrameRef.current = requestAnimationFrame(renderLoop);\n    },\n    [dominantColors, hoverState]\n  ); // Dependencies for lerp targets\n\n  // --- Initialization Effect ---\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    if (!canvasElement) return;\n\n    const gl = canvasElement.getContext('webgl', { alpha: false, antialias: true }); // alpha: false maybe faster? antialias: true for smoother gradients\n    if (!gl) {\n      console.error('WebGL not supported or context creation failed.');\n      return;\n    }\n    glRef.current = gl;\n\n    // Compile shaders\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!vertexShader || !fragmentShader) return;\n\n    // Link program\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    if (!program) return;\n    programRef.current = program;\n\n    // Detach and delete shaders after linking\n    gl.detachShader(program, vertexShader);\n    gl.detachShader(program, fragmentShader);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    // --- Create Buffer for Fullscreen Quad ---\n    // Vertices for two triangles covering the screen (-1 to 1)\n    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n    bufferRef.current = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    // --- Look up locations ---\n    attribLocationsRef.current.position = gl.getAttribLocation(program, 'a_position');\n    uniformLocationsRef.current.resolution = gl.getUniformLocation(program, 'u_resolution');\n    uniformLocationsRef.current.time = gl.getUniformLocation(program, 'u_time');\n    uniformLocationsRef.current.colorTarget1 = gl.getUniformLocation(program, 'u_colorTarget1');\n    uniformLocationsRef.current.colorTarget2 = gl.getUniformLocation(program, 'u_colorTarget2');\n    uniformLocationsRef.current.colorMixFactor = gl.getUniformLocation(program, 'u_colorMixFactor');\n    uniformLocationsRef.current.isHovering = gl.getUniformLocation(program, 'u_isHovering');\n    uniformLocationsRef.current.hoverPos = gl.getUniformLocation(program, 'u_hoverPos');\n    uniformLocationsRef.current.hoverColor = gl.getUniformLocation(program, 'u_hoverColor');\n\n    // --- Resize Handling ---\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!entries || entries.length === 0) return;\n      const { width, height } = entries[0].contentRect;\n      if (glRef.current) {\n        glRef.current.canvas.width = width;\n        glRef.current.canvas.height = height;\n      }\n    });\n    resizeObserver.observe(canvasElement);\n\n    // Start render loop\n    animationFrameRef.current = requestAnimationFrame(renderLoop);\n\n    // --- Cleanup ---\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      resizeObserver.disconnect();\n\n      const currentGl = glRef.current;\n      if (currentGl) {\n        if (bufferRef.current) currentGl.deleteBuffer(bufferRef.current);\n        if (programRef.current) currentGl.deleteProgram(programRef.current);\n      }\n      glRef.current = null;\n      programRef.current = null;\n      bufferRef.current = null;\n    };\n    // Add renderLoop to dependencies if its definition relies on changing props/state from outside\n  }, [createShader, createProgram, renderLoop]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={styles.particleBackground} // Reuse style or create AuraBackground.module.scss\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        pointerEvents: 'none',\n        zIndex: -1, // Keep behind content\n        // backgroundColor: '#041024', // Optional fallback bg\n      }}\n    />\n  );\n};\n\nexport default React.memo(AuraBackground);\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport { motion } from 'framer-motion';\n\ninterface BannerViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst BannerView: React.FC<BannerViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  return (\n    <div className=\"banner-view space-y-4\">\n      {images.map((image, index) => (\n        <motion.div\n          key={image.id}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.5, delay: index * 0.1 }}\n          className=\"banner-item relative\"\n        >\n          <div\n            className=\"banner-image-container w-full h-[300px] rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-shadow duration-300\"\n            style={{ height: `${300 * zoom}px` }}\n          >\n            <img src={image.src} alt={image.alt} className=\"w-full h-full object-cover\" />\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n              <p className=\"text-white/80 text-sm\">\n                {image.width}  {image.height}\n              </p>\n            </div>\n          </div>\n        </motion.div>\n      ))}\n    </div>\n  );\n};\n\nexport default BannerView;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport Slider from 'react-slick';\nimport { motion } from 'framer-motion';\nimport { FaChevronLeft, FaChevronRight } from 'react-icons/fa';\n\ninterface CarouselViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst NextArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute right-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronRight />\n    </button>\n  );\n};\n\nconst PrevArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute left-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronLeft />\n    </button>\n  );\n};\n\nconst CarouselView: React.FC<CarouselViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  const settings = {\n    dots: true,\n    infinite: true,\n    speed: 500,\n    slidesToShow: 1,\n    slidesToScroll: 1,\n    nextArrow: <NextArrow />,\n    prevArrow: <PrevArrow />,\n    adaptiveHeight: true,\n    customPaging: (i: number) => (\n      <div className=\"w-3 h-3 mx-1 rounded-full bg-white/50 hover:bg-white/70 transition-colors duration-300\" />\n    ),\n  };\n\n  return (\n    <div className=\"carousel-view\">\n      <Slider {...settings}>\n        {images.map((image, index) => (\n          <motion.div\n            key={image.id}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ duration: 0.5 }}\n            className=\"outline-none\"\n          >\n            <div className=\"relative aspect-video\">\n              <img\n                src={image.src}\n                alt={image.alt}\n                className=\"w-full h-full object-contain\"\n                style={{\n                  maxHeight: `${600 * zoom}px`,\n                }}\n              />\n              <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n                <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n                <p className=\"text-white/80 text-sm\">\n                  {image.width}  {image.height}\n                </p>\n              </div>\n            </div>\n          </motion.div>\n        ))}\n      </Slider>\n    </div>\n  );\n};\n\nexport default CarouselView;\n","import React from 'react';\r\nimport { ImageInfo } from '../../types';\r\nimport Masonry from 'react-masonry-css';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface MasonryViewProps {\r\n  images: ImageInfo[];\r\n  zoom: number;\r\n}\r\n\r\nconst MasonryView: React.FC<MasonryViewProps> = ({ images, zoom }) => {\r\n  const breakpointColumns = {\r\n    default: 4,\r\n    1536: 4,\r\n    1280: 3,\r\n    1024: 3,\r\n    768: 2,\r\n    640: 1,\r\n  };\r\n\r\n  if (!images.length) {\r\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\r\n  }\r\n\r\n  return (\r\n    <Masonry\r\n      breakpointCols={breakpointColumns}\r\n      className=\"flex -ml-4 w-auto\"\r\n      columnClassName=\"pl-4 bg-clip-padding\"\r\n    >\r\n      {images.map((image, index) => (\r\n        <motion.div\r\n          key={image.id}\r\n          initial={{ opacity: 0, scale: 0.9 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          transition={{ duration: 0.5, delay: index * 0.1 }}\r\n          className=\"mb-4\"\r\n        >\r\n          <div className=\"relative group rounded-lg overflow-hidden shadow-md hover:shadow-xl transition-shadow duration-300\">\r\n            <img\r\n              src={image.src}\r\n              alt={image.alt}\r\n              className=\"w-full h-auto\"\r\n              style={{\r\n                maxHeight: `${400 * zoom}px`,\r\n                objectFit: 'cover',\r\n              }}\r\n            />\r\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4 transform translate-y-full group-hover:translate-y-0 transition-transform duration-300\">\r\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\r\n              <p className=\"text-white/80 text-sm\">\r\n                {image.width}  {image.height}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </motion.div>\r\n      ))}\r\n    </Masonry>\r\n  );\r\n};\r\n\r\nexport default MasonryView;\r\n","import { motion, useTransform, useViewportScroll } from 'framer-motion';\nimport React, {\n  CSSProperties,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport Lightbox from 'yet-another-react-lightbox';\nimport Captions from 'yet-another-react-lightbox/plugins/captions';\nimport 'yet-another-react-lightbox/plugins/captions.css';\nimport Counter from 'yet-another-react-lightbox/plugins/counter';\nimport 'yet-another-react-lightbox/plugins/counter.css';\nimport Thumbnails from 'yet-another-react-lightbox/plugins/thumbnails';\nimport 'yet-another-react-lightbox/plugins/thumbnails.css';\nimport Zoom from 'yet-another-react-lightbox/plugins/zoom';\nimport 'yet-another-react-lightbox/styles.css';\nimport styles from '../styles/ImageFeed.module.scss';\nimport { ImageInfo, ViewMode } from '../types/index.js';\nimport { truncateImageTitle } from '../utils/stringUtils.js';\nimport { ImageHoverData } from './ImageItem.js';\nimport ImageRow from './ImageRow.js';\nimport ImageSkeleton from './ImageSkeleton.js';\n// import Lottie from 'react-lottie';\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { FastAverageColor } from 'fast-average-color';\nimport { default as lodashDebounce } from 'lodash/debounce';\nimport { ColorContext } from '../contexts/ColorContext';\nimport { useFolderImages } from '../hooks/query/useFolderImages';\nimport useWindowSize from '../hooks/useWindowSize.js';\nimport { loadScrollState, saveScrollState, ScrollState } from '../lib/cache/feedStateCache';\nimport AnimationSystem from '../utils/AnimationSystem';\nimport {\n  calculateGapSize,\n  calculateLayout,\n  distributeImages,\n  LayoutConfig,\n  MIN_IMAGE_WIDTH,\n} from '../utils/layoutCalculator';\nimport WorkerPool from '../workers/workerPool';\nimport AuraBackground from './AuraBackground';\nimport { BannerView, CarouselView, MasonryView } from './views';\n\n// Simple throttle function\nfunction throttle<F extends (...args: any[]) => any>(func: F, limit: number) {\n  let inThrottle: boolean;\n  let lastResult: ReturnType<F>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const throttled = function (this: ThisParameterType<F>, ...args: Parameters<F>): void {\n    const context = this;\n    if (!inThrottle) {\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n      // Call the function but don't worry about returning its result for listener\n      func.apply(context, args);\n    }\n    // Explicitly return void for listener compatibility\n    // return lastResult; // Removed potentially problematic return\n  };\n\n  return throttled;\n}\n\n// Simple debounce function (with cancel)\nfunction debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = (...args: Parameters<F>) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => func(...args), waitFor);\n  };\n\n  // Add the cancel method\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null; // Clear the ID after cancelling\n    }\n  };\n\n  return debounced as F & { cancel: () => void };\n}\n\n// Define the props interface for ImageFeed component\ninterface ImageFeedProps {\n  folderPath: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: React.RefObject<HTMLElement>;\n}\n\ninterface CustomStyle extends CSSProperties {\n  '--energy-color'?: string;\n  '--ripple-x'?: string;\n  '--ripple-y'?: string;\n  '--ripple-strength'?: string;\n}\n\n// Define the ImageFeed component\nconst ImageFeed: React.FC<ImageFeedProps> = ({\n  folderPath,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  const {\n    data: originalImages,\n    isLoading,\n    isError,\n    error,\n    isPlaceholderData,\n  } = useFolderImages(folderPath);\n\n  const windowSize = useWindowSize();\n  const feedRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [columns, setColumns] = useState(4);\n  const [lightboxIndex, setLightboxIndex] = useState<number>(-1);\n  const [lightboxImages, setLightboxImages] = useState<ImageInfo[]>([]);\n  const [rowTransforms, setRowTransforms] = useState<number[]>([]);\n  const { scrollY } = useViewportScroll();\n  const y1 = useTransform(scrollY, [0, 300], [0, 200]);\n  const y2 = useTransform(scrollY, [0, 300], [0, -200]);\n  const animationSystem = useMemo(() => AnimationSystem.getInstance(), []);\n  const { setDominantColors, setHoverState } = useContext(ColorContext);\n  const facRef = useRef<FastAverageColor | null>(null);\n  const lastProcessedRowIndexRef = useRef<number | null>(null);\n  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const [restoredState, setRestoredState] = useState<ScrollState | null>(null);\n  const previousFolderPathRef = useRef<string | null>(null);\n  const rowHeightsRef = useRef<number[]>([]);\n  const isRestoringScrollRef = useRef(false);\n  const velocityEMARef = useRef(0); // For smoothing velocity readings\n  const OVERSCAN_BASE = 3; // Slightly reduced base\n  const OVERSCAN_MAX = 15; // Slightly reduced max\n  const EMA_ALPHA = 0.2; // More smoothing (lower alpha = more smoothing)\n  const OVERSCAN_FACTOR = 10; // Adjust mapping sensitivity\n  const workerPool = useMemo(() => WorkerPool.getInstance(), []);\n\n  // --- Add missing useState declaration --- >\n  const [dynamicOverscan, setDynamicOverscan] = useState(OVERSCAN_BASE);\n  // --- End missing useState declaration --- >\n\n  // State to track failed image IDs\n  const [failedImageIds, setFailedImageIds] = useState<Set<string>>(new Set());\n\n  // --- Debouncing Logic for isGrouped ---\n  const [debouncedIsGrouped, setDebouncedIsGrouped] = useState(isGrouped);\n\n  // Use the renamed lodashDebounce here\n  const updateDebouncedGrouped = useCallback(\n    lodashDebounce((newValue: boolean) => {\n      setDebouncedIsGrouped(newValue);\n      console.log('[ImageFeed] Applying debounced isGrouped:', newValue);\n    }, 300),\n    []\n  );\n\n  // Effect to call the debounced function when the raw prop changes\n  useEffect(() => {\n    updateDebouncedGrouped(isGrouped);\n\n    // Cleanup function to cancel any pending debounced call\n    return () => {\n      updateDebouncedGrouped.cancel();\n    };\n  }, [isGrouped, updateDebouncedGrouped]);\n  // --- End Debouncing Logic ---\n\n  // Callback to report image load errors\n  const handleImageLoadError = useCallback((imageId: string) => {\n    setFailedImageIds(prev => {\n      if (prev.has(imageId)) return prev; // Avoid unnecessary state updates\n      console.log(`ImageFeed: Registering error for image ${imageId}`);\n      const newSet = new Set(prev);\n      newSet.add(imageId);\n      return newSet;\n    });\n  }, []);\n\n  // --- Scroll Persistence Logic ---\n\n  // Debounced function to save scroll state during active scroll\n  const debouncedSaveScroll = useCallback(\n    debounce((path: string, scroll: number /*, heights: number[], width: number */) => {\n      if (path && !isRestoringScrollRef.current) {\n        // Only save scroll position\n        saveScrollState(path, scroll);\n        // saveFeedState(path, {\n        //   scrollTop: scroll,\n        //   rowHeights: heights, // REMOVED\n        //   containerWidth: width, // REMOVED\n        // });\n      }\n    }, 500),\n    []\n  );\n\n  // Load state on mount/folder change & Save state on unmount/folder change\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadAndSetState = async () => {\n      // Use loadScrollState\n      const loadedState = await loadScrollState(folderPath);\n      if (isMounted) {\n        // --- Remove width validation ---\n        // const widthDifference =\n        //   containerWidth > 0 && loadedState\n        //     ? Math.abs(loadedState.containerWidth - containerWidth)\n        //     : Infinity;\n        // const isValidWidth = widthDifference < 50;\n\n        // If state exists, restore it\n        if (loadedState /* && isValidWidth */) {\n          setRestoredState(loadedState);\n          isRestoringScrollRef.current = true;\n        } else {\n          // --- Remove width mismatch logging ---\n          // if (!isValidWidth && loadedState) {\n          //   console.warn(\n          //     `Invalidating cached state for ${folderPath} due to width mismatch. Cached: ${loadedState.containerWidth}, Current: ${containerWidth}`\n          //   );\n          // }\n          setRestoredState(null);\n          // Set scroll to top only if no state is being restored\n          if (scrollContainerRef.current) {\n            scrollContainerRef.current.scrollTop = 0;\n          }\n          isRestoringScrollRef.current = false;\n        }\n      }\n    };\n\n    // Load state immediately, don't wait for containerWidth\n    // if (containerWidth > 0) {\n    loadAndSetState();\n    // }\n\n    const currentPathForCleanup = folderPath;\n    previousFolderPathRef.current = currentPathForCleanup;\n\n    return () => {\n      isMounted = false;\n      const scrollElement = scrollContainerRef.current;\n      const folderToSave = previousFolderPathRef.current;\n\n      // Only save if layout seems ready (rowHeightsRef has items)\n      if (scrollElement && folderToSave && rowHeightsRef.current.length > 0) {\n        // --- Only save scrollTop --- >\n        // const currentState: Omit<FeedState, 'timestamp'> = {\n        //   scrollTop: scrollElement.scrollTop,\n        //   rowHeights: rowHeightsRef.current,\n        //   containerWidth: containerWidth,\n        // };\n        // saveFeedState(folderToSave, currentState);\n        saveScrollState(folderToSave, scrollElement.scrollTop);\n      }\n\n      debouncedSaveScroll.cancel?.();\n      // --- ADD CANCELLATION ON UNMOUNT --- >\n      console.log('ImageFeed: Unmounting, cancelling pending tasks.');\n      workerPool.cancelPendingTasks();\n    };\n    // Remove containerWidth from dependencies, load immediately\n  }, [folderPath, scrollContainerRef, debouncedSaveScroll, workerPool]);\n\n  // --- End Scroll Persistence Logic ---\n\n  // Calculate average aspect ratio for fallback estimation\n  const avgAspectRatio = useMemo(() => {\n    if (!originalImages || originalImages.length === 0) return 1; // Default aspect ratio\n\n    const validImages = originalImages.filter(img => img && img.width > 0 && img.height > 0);\n    if (validImages.length === 0) return 1;\n\n    const totalRatio = validImages.reduce((sum, img) => sum + img.width / img.height, 0);\n    return totalRatio / validImages.length;\n  }, [originalImages]);\n\n  // Calculate layout metrics (using helper function for clarity if needed)\n  const layoutMetrics = useMemo(() => {\n    const gapSize = calculateGapSize(zoom);\n    let estimatedRowHeightFallback = 200; // Default\n    // Potentially more complex calculation as in pasted version if needed\n    if (containerWidth > 0 && columns > 0 && avgAspectRatio > 0) {\n      const totalGapWidth = Math.max(0, columns - 1) * gapSize;\n      const availableWidthForImages = Math.max(0, containerWidth - totalGapWidth);\n      if (availableWidthForImages > 0) {\n        const estimatedAvgImageWidth = availableWidthForImages / columns;\n        estimatedRowHeightFallback = Math.max(\n          50,\n          Math.round(estimatedAvgImageWidth / avgAspectRatio)\n        );\n      }\n    }\n    return {\n      gapSize,\n      estimatedRowHeightFallback,\n    };\n  }, [containerWidth, columns, zoom, avgAspectRatio]);\n\n  // Reset states when folder or view mode changes\n  useEffect(() => {\n    setLightboxIndex(-1);\n    setLightboxImages([]);\n    lastProcessedRowIndexRef.current = null;\n    setDominantColors([]);\n    setFailedImageIds(new Set());\n    console.log(\n      `ImageFeed: ${folderPath ? 'Folder' : 'ViewMode/Group'} changed, cancelling pending tasks.`\n    );\n    workerPool.cancelPendingTasks();\n  }, [folderPath, viewMode, isGrouped, setDominantColors, workerPool]);\n\n  // --- ADD CANCELLATION ON ZOOM CHANGE --- >\n  useEffect(() => {\n    console.log('ImageFeed: Zoom changed, cancelling pending tasks.');\n    workerPool.cancelPendingTasks();\n  }, [zoom, workerPool]);\n\n  // Initialize FAC instance on mount\n  useEffect(() => {\n    facRef.current = new FastAverageColor();\n    return () => {\n      facRef.current?.destroy?.();\n    };\n  }, []);\n\n  // --- Container Width Management ---\n\n  // Shared function to update width and columns\n  const updateContainerWidth = useCallback(() => {\n    if (!feedRef.current) return;\n\n    const rect = feedRef.current.getBoundingClientRect();\n    const newWidth = Math.max(MIN_IMAGE_WIDTH, rect.width);\n\n    // Check if width actually changed before updating state\n    setContainerWidth(prevWidth => {\n      if (newWidth !== prevWidth) {\n        // Recalculate layout columns based on the new width\n        const config: LayoutConfig = {\n          containerWidth: newWidth,\n          zoom,\n          viewMode,\n          isGrouped: debouncedIsGrouped,\n        };\n        const layout = calculateLayout(config);\n        // Update columns directly here if needed, or rely on layoutMetrics memo\n        setColumns(layout.columns);\n        return newWidth;\n      }\n      return prevWidth; // Return previous width if no change\n    });\n  }, [zoom, viewMode, debouncedIsGrouped, updateDebouncedGrouped]); // Dependencies are things used *inside* the function\n\n  // Use useLayoutEffect for the *initial* measurement before paint\n  useLayoutEffect(() => {\n    updateContainerWidth();\n  }, [updateContainerWidth]); // Re-run if the function identity changes (due to its deps)\n\n  // Use useEffect for setting up listeners for *subsequent* updates\n  useEffect(() => {\n    // Add resize observer for more accurate width updates\n    const resizeObserver = new ResizeObserver(updateContainerWidth);\n    if (feedRef.current) {\n      resizeObserver.observe(feedRef.current);\n    }\n\n    // Use standard resize listener as a fallback or additional trigger\n    window.addEventListener('resize', updateContainerWidth);\n\n    // Cleanup listeners on unmount\n    return () => {\n      resizeObserver.disconnect();\n      window.removeEventListener('resize', updateContainerWidth);\n    };\n    // This effect only needs to run once to set up listeners\n    // updateContainerWidth is stable due to useCallback\n  }, [updateContainerWidth]);\n\n  // --- End Container Width Management ---\n\n  // Filter out images that failed to load *before* grouping/layout\n  const images = useMemo(() => {\n    if (!originalImages) return [];\n    return originalImages.filter(img => !failedImageIds.has(img.id));\n  }, [originalImages, failedImageIds]);\n\n  // Modified groupedImages calculation (uses filtered images)\n  const groupedImages = useMemo(() => {\n    console.time('groupedImages calculation'); // Start perf timer\n    if (!Array.isArray(images) || images.length === 0) {\n      console.timeEnd('groupedImages calculation');\n      return [];\n    }\n\n    const validImages = images.filter(\n      image =>\n        image &&\n        typeof image === 'object' &&\n        'width' in image &&\n        'height' in image &&\n        image.width > 0 &&\n        image.height > 0\n    );\n\n    if (!debouncedIsGrouped) {\n      const result = validImages.map(image => ({\n        key: image.id,\n        images: [image],\n        isCarousel: false,\n      }));\n      console.timeEnd('groupedImages calculation');\n      return result;\n    }\n\n    // --- Optimized Grouping Logic ---\n    // 1. Pre-compute processed titles\n    console.time('groupedImages - precompute titles');\n    const processedTitles = new Map<string, string>();\n    validImages.forEach(image => {\n      // Store by image.id -> processedTitle\n      processedTitles.set(image.id, truncateImageTitle(image.alt));\n    });\n    console.timeEnd('groupedImages - precompute titles');\n\n    // 2. Group using pre-computed titles\n    console.time('groupedImages - grouping loop');\n    const groups: { [key: string]: ImageInfo[] } = {};\n    validImages.forEach(image => {\n      const processedTitle = processedTitles.get(image.id) || 'Untitled'; // Get pre-computed title\n      if (!groups[processedTitle]) {\n        groups[processedTitle] = [];\n      }\n      groups[processedTitle].push(image);\n    });\n    console.timeEnd('groupedImages - grouping loop');\n\n    // 3. Convert groups object to array\n    console.time('groupedImages - convert to array');\n    const result = Object.entries(groups).map(([key, group]) => ({\n      key,\n      images: group,\n      isCarousel: group.length > 1,\n    }));\n    console.timeEnd('groupedImages - convert to array');\n    // --- End Optimized Grouping Logic ---\n\n    console.timeEnd('groupedImages calculation'); // End overall perf timer\n    return result;\n  }, [images, debouncedIsGrouped]); // Dependencies remain the same\n\n  // Enhanced groupedRows calculation (uses filtered images via groupedImages)\n  const groupedRows = useMemo(() => {\n    if (!containerWidth || groupedImages.length === 0 || viewMode !== ViewMode.GRID) return [];\n\n    const firstImages = groupedImages\n      .map(group => group.images[0])\n      .filter(image => image && image.width > 0 && image.height > 0);\n\n    if (firstImages.length === 0) return [];\n\n    return distributeImages(\n      firstImages,\n      containerWidth,\n      zoom,\n      layoutMetrics.estimatedRowHeightFallback\n    );\n  }, [groupedImages, zoom, containerWidth, viewMode, layoutMetrics.estimatedRowHeightFallback]); // Depends on groupedImages\n\n  // Define the useEffect that updates rowHeightsRef HERE, AFTER groupedRows\n  useEffect(() => {\n    if (viewMode === ViewMode.GRID && groupedRows && groupedRows.length > 0) {\n      rowHeightsRef.current = groupedRows.map(row => row.height);\n    } else {\n      rowHeightsRef.current = [];\n    }\n  }, [groupedRows, viewMode, folderPath]);\n\n  // Handle image overflow (wrapped in useCallback)\n  const handleImageOverflow = useCallback((image: ImageInfo) => {\n    console.warn('Image overflow detected:', image.id);\n    // Implement any necessary overflow handling logic here\n  }, []); // No dependencies needed if it only uses console\n\n  // Update handleImageClick to work with grouped images and set lightbox plugins (wrapped in useCallback)\n  const handleImageClick = useCallback(\n    (clickedImage: ImageInfo) => {\n      // Find the group the clicked image belongs to\n      const groupIndex = groupedImages.findIndex(group =>\n        group.images.some(img => img.id === clickedImage.id)\n      );\n\n      if (groupIndex !== -1) {\n        const group = groupedImages[groupIndex];\n        // Find the index of the clicked image WITHIN that group\n        const imageIndexInGroup = group.images.findIndex(img => img.id === clickedImage.id);\n\n        if (imageIndexInGroup !== -1) {\n          setLightboxImages(group.images); // Set the images for the lightbox\n          setLightboxIndex(imageIndexInGroup); // Set the index WITHIN the group\n        }\n      }\n    },\n    [groupedImages, setLightboxImages, setLightboxIndex] // Add state setters to dependencies\n  );\n\n  // --- Scroll Velocity and Dynamic Overscan --- >\n  const lastScrollTopRef = useRef(0);\n  const lastScrollTimeRef = useRef(performance.now());\n\n  const handleScroll = useCallback(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (!scrollElement) return;\n\n    const now = performance.now();\n    const scrollTop = scrollElement.scrollTop;\n    const timeDelta = now - lastScrollTimeRef.current;\n    const scrollDelta = scrollTop - lastScrollTopRef.current;\n\n    if (timeDelta > 10) {\n      // Avoid division by zero or tiny intervals\n      const velocity = Math.abs(scrollDelta) / timeDelta; // Pixels per millisecond\n      // Update EMA velocity\n      velocityEMARef.current = EMA_ALPHA * velocity + (1 - EMA_ALPHA) * velocityEMARef.current;\n\n      // Calculate dynamic overscan based on smoothed velocity\n      const calculatedOverscan =\n        OVERSCAN_BASE +\n        Math.min(velocityEMARef.current * OVERSCAN_FACTOR, OVERSCAN_MAX - OVERSCAN_BASE);\n      setDynamicOverscan(Math.round(calculatedOverscan));\n\n      // Update refs for next calculation\n      lastScrollTopRef.current = scrollTop;\n      lastScrollTimeRef.current = now;\n\n      // Trigger debounced save (if still needed)\n      debouncedSaveScroll(folderPath, scrollTop);\n    }\n  }, [scrollContainerRef, folderPath, debouncedSaveScroll]);\n\n  // Attach scroll listener\n  useEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (scrollElement) {\n      // Use throttle for the scroll handler to limit frequency\n      const throttledScrollHandler = throttle(handleScroll, 100); // Throttle to ~10fps\n      scrollElement.addEventListener('scroll', throttledScrollHandler);\n      return () => scrollElement.removeEventListener('scroll', throttledScrollHandler);\n    }\n  }, [scrollContainerRef, handleScroll]);\n  // --- End Scroll Velocity Logic --- >\n\n  // --- Virtualization Setup ---\n  const rowVirtualizer = useVirtualizer({\n    count: groupedRows.length,\n    getScrollElement: () => scrollContainerRef.current,\n    estimateSize: useCallback(\n      (index: number) => {\n        // Always fallback to calculated or estimated height\n        const rowHeight = groupedRows[index]?.height ?? layoutMetrics.estimatedRowHeightFallback;\n        return rowHeight + layoutMetrics.gapSize;\n      },\n      [groupedRows, layoutMetrics.estimatedRowHeightFallback, layoutMetrics.gapSize, viewMode]\n    ),\n    overscan: dynamicOverscan, // Use dynamic overscan state\n  });\n\n  // Remeasure rows whenever zoom, containerWidth, row count, row height fallback, gap size, view mode, or grouping changes\n  useLayoutEffect(() => {\n    rowVirtualizer.measure?.();\n  }, [\n    zoom,\n    containerWidth,\n    groupedRows.length,\n    layoutMetrics.estimatedRowHeightFallback,\n    layoutMetrics.gapSize,\n    viewMode,\n    debouncedIsGrouped,\n    folderPath,\n  ]);\n\n  // Get the virtual items to render\n  const virtualItems = rowVirtualizer.getVirtualItems();\n\n  // --- End Virtualization Setup ---\n\n  // --- Add Scroll Restoration Effect ---\n  useLayoutEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    // Try to restore scroll only after layout is stable\n    if (isRestoringScrollRef.current && restoredState && rowHeightsRef.current.length > 0) {\n      if (scrollElement) {\n        console.log(`Restoring scroll to: ${restoredState.scrollTop}`);\n        // Wrap scroll restoration in requestAnimationFrame for smoothness\n        requestAnimationFrame(() => {\n          scrollElement.scrollTop = restoredState.scrollTop;\n          // Reset the flag *after* applying the scroll\n          isRestoringScrollRef.current = false;\n        });\n      } else {\n        isRestoringScrollRef.current = false; // Reset if element not found\n      }\n    }\n  }, [restoredState, scrollContainerRef, virtualItems, folderPath]); // Depend on restored state, ref, virtual items, and folderPath\n  // --- End Scroll Restoration Effect ---\n\n  // Callback function for image hover - with delay logic\n  const handleImageHover = useCallback(\n    (data: ImageHoverData) => {\n      // Clear any existing timeout\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n        hoverTimeoutRef.current = null;\n      }\n\n      if (data.isHovering) {\n        // Set a timeout to activate hover state after a delay\n        hoverTimeoutRef.current = setTimeout(() => {\n          // Pass the relevant data to context\n          setHoverState({ isHovering: true, position: data.position, color: data.color });\n        }, 150); // 150ms delay\n      } else {\n        // If mouse leaves, immediately deactivate hover state\n        setHoverState({ isHovering: false, position: null, color: null });\n      }\n    },\n    [setHoverState] // Dependency remains setHoverState\n  );\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    // Clear timeout if component unmounts\n    return () => {\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, []); // Empty dependency array ensures this runs only on mount and unmount\n\n  // Callback function to get the correct image URL\n  const getImageUrl = useCallback((imagePath: string) => {\n    // 1. Replace backslashes with forward slashes\n    let path = imagePath.replace(/\\\\/g, '/');\n    // 2. Check if it already starts with '/api/image/' or just '/'. If so, use it directly.\n    if (path.startsWith('/api/image/') || path.startsWith('/')) {\n      // Assume it's already a usable path\n      return path;\n    }\n    // 3. Otherwise, prepend the API prefix\n    return `/api/image/${path}`;\n  }, []);\n\n  // Enhanced renderContent using virtualization for GRID view\n  const renderContent = () => {\n    const { gapSize } = layoutMetrics;\n    if (!containerWidth) return null;\n    const currentImages = images ?? [];\n    const MotionWrapper = motion.div;\n\n    // Determine if we should show skeletons (initial load)\n    const showSkeletons = isLoading && !isPlaceholderData;\n\n    // Handle non-GRID view modes\n    if (viewMode !== ViewMode.GRID) {\n      let ViewComponent;\n      switch (viewMode) {\n        case ViewMode.MASONRY:\n          ViewComponent = MasonryView;\n          break;\n        case ViewMode.BANNER:\n          ViewComponent = BannerView;\n          break;\n        case ViewMode.CAROUSEL:\n          ViewComponent = CarouselView;\n          break;\n        default:\n          return null;\n      }\n      // Placeholder: Add transitions/loading for non-grid views if needed\n      return <ViewComponent images={currentImages} zoom={zoom} />;\n    }\n\n    // --- GRID View Logic with Virtualization --- //\n\n    // Show skeletons only on initial load for GRID view\n    if (showSkeletons) {\n      // We might need a wrapper here if renderSkeletons doesn't provide one\n      // Use the calculated metrics for skeletons\n      return renderSkeletons();\n    }\n\n    // Render the virtualized list when data is ready\n    return (\n      <div // Outer container: Sets the total scrollable height\n        style={{\n          height: `${rowVirtualizer.getTotalSize()}px`,\n          width: '100%',\n          position: 'relative',\n        }}\n      >\n        <div // Inner container: Absolutely positioned items are placed here\n          style={{\n            width: '100%',\n            position: 'relative', // Often needed for absolute children\n          }}\n        >\n          {virtualItems.map(virtualItem => {\n            const row = groupedRows[virtualItem.index];\n            if (!row) return null; // Should not happen if count is correct\n\n            return (\n              <div // Wrapper for each virtual row with positioning\n                key={virtualItem.key}\n                data-index={virtualItem.index}\n                ref={rowVirtualizer.measureElement} // Optional: for dynamic height measurement\n                style={{\n                  position: 'absolute',\n                  top: 0,\n                  left: 0,\n                  width: '100%',\n                  height: `${virtualItem.size}px`,\n                  transform: `translateY(${virtualItem.start}px)`,\n                }}\n              >\n                <ImageRow\n                  // Pass necessary props down\n                  images={row.images}\n                  imageWidths={row.imageWidths ?? []}\n                  onImageClick={handleImageClick}\n                  columns={columns}\n                  zoom={zoom}\n                  isLastRow={virtualItem.index === groupedRows.length - 1}\n                  rowHeight={row.height}\n                  groupedImages={groupedImages}\n                  workerPool={workerPool}\n                  gap={gapSize} // Use calculated gapSize\n                  containerWidth={containerWidth}\n                  onImageHover={handleImageHover}\n                  onImageLoadError={handleImageLoadError}\n                />\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  // Lightbox configuration\n  const lightboxPlugins = useMemo(() => [Captions, Counter, Thumbnails, Zoom], []);\n\n  // Prepare the lightbox slide objects\n  const slides = useMemo(() => {\n    if (!lightboxImages.length) return [];\n    return lightboxImages.map(image => ({\n      src: getImageUrl(image.src),\n      alt: image.alt,\n      title: image.title,\n      width: image.width,\n      height: image.height,\n    }));\n  }, [lightboxImages, getImageUrl]);\n\n  // --- Color Extraction Logic ---\n\n  // Debounced function to update context\n  const debouncedSetContextColor = useCallback(\n    debounce(async (imageUrl: string | null) => {\n      if (!imageUrl || !facRef.current) return;\n      try {\n        // Ensure getImageUrl provides full path or handle relative paths\n        const color = await facRef.current.getColorAsync(imageUrl);\n        if (color.hex) {\n          setDominantColors([color.hex]); // Update context with the single dominant color\n        }\n      } catch (e) {\n        console.error('Error getting average color:', e);\n      }\n    }, 300), // Debounce delay (ms)\n    [setDominantColors, getImageUrl] // Added getImageUrl dependency\n  );\n\n  // Effect to set initial color on first load\n  useEffect(() => {\n    if (images && images.length > 0 && lastProcessedRowIndexRef.current === null) {\n      const firstImage = images[0];\n      if (firstImage?.src) {\n        const imageUrl = getImageUrl(firstImage.src); // Use helper\n        // Call directly without debounce for initial set\n        void (async () => {\n          if (!imageUrl || !facRef.current) return;\n          try {\n            const color = await facRef.current.getColorAsync(imageUrl);\n            if (color.hex) {\n              setDominantColors([color.hex]);\n              lastProcessedRowIndexRef.current = 0; // Mark first row as processed\n            }\n          } catch (e) {\n            console.error('Error getting initial average color:', e);\n          }\n        })();\n      }\n    }\n    // Run only when images are first loaded or getImageUrl changes\n  }, [images, getImageUrl, setDominantColors]);\n\n  // --- Render Skeletons --- (Copied from pasted version, uses layoutMetrics)\n  const renderSkeletons = useCallback(() => {\n    // Use pre-calculated metrics\n    const { gapSize } = layoutMetrics;\n    // Estimate width/height based on columns and aspect ratio - needs refinement if possible\n    const approxWidth =\n      containerWidth > 0 && columns > 0 ? containerWidth / columns - gapSize : 200;\n    const approxHeight = avgAspectRatio > 0 ? approxWidth / avgAspectRatio : 150;\n\n    const skeletonCount = columns * 5; // Estimate: 5 rows of skeletons\n\n    // Return null if dimensions are invalid\n    if (approxWidth <= 0 || approxHeight <= 0) {\n      return null;\n    }\n\n    return (\n      <motion.div\n        key=\"skeleton-grid\"\n        className={styles.gridContainer} // Use gridContainer for layout?\n        style={{\n          gap: `${gapSize}px`, // Apply gap for skeleton layout\n          // gridTemplateColumns: `repeat(${columns}, 1fr)` // Example if using CSS grid\n        }}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        transition={{ duration: 0.2 }}\n      >\n        {Array.from({ length: skeletonCount }).map((_, i) => (\n          <ImageSkeleton\n            key={`skeleton-${i}`}\n            containerWidth={Math.round(approxWidth)}\n            containerHeight={Math.round(approxHeight)}\n          />\n        ))}\n      </motion.div>\n    );\n  }, [columns, layoutMetrics, containerWidth, avgAspectRatio, styles.gridContainer]); // Dependencies\n\n  // Handle Error State\n  if (isError) {\n    return (\n      <div ref={feedRef} className={`${styles.container} ${styles.error}`}>\n        Error loading images: {error?.message || 'Unknown error'}\n      </div>\n    );\n  }\n\n  // Handle Loading State (show skeletons only on initial load, respect restored state)\n  // Now, restoredState only affects scroll, not initial render with skeletons\n  const showLoadingSkeletons = isLoading && !isPlaceholderData; // Simpler condition\n\n  if (showLoadingSkeletons) {\n    return (\n      <div ref={feedRef} className={styles.container}>\n        <div className={`${styles.feed} ${styles.loading}`}>\n          {/* Render skeletons based on estimated layout */}\n          {renderSkeletons()}\n        </div>\n      </div>\n    );\n  }\n\n  // Handle Empty State (after loading and no errors)\n  // Check images directly from useFolderImages result, not just processed/grouped ones\n  const hasNoImages = !isLoading && (!images || images.length === 0);\n\n  if (hasNoImages) {\n    return (\n      <div ref={feedRef} className={styles.container}>\n        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className={styles.noImages}>\n          No images found for this folder.\n        </motion.div>\n      </div>\n    );\n  }\n\n  // Main Render\n  return (\n    <div\n      ref={feedRef}\n      className={styles.container}\n      style={{\n        position: 'relative',\n      }}\n    >\n      <AuraBackground />\n      <div className={styles.feed}>{renderContent()}</div>\n\n      <Lightbox\n        open={lightboxIndex !== -1}\n        close={() => setLightboxIndex(-1)}\n        index={lightboxIndex}\n        slides={slides}\n        plugins={lightboxPlugins}\n      />\n    </div>\n  );\n};\n\nexport default React.memo(ImageFeed);\n","import { useCallback, useEffect, useState } from 'react';\n\n// Define the structure for the window size object\ninterface WindowSize {\n  width: number | undefined;\n  height: number | undefined;\n}\n\n// Debounce timeout in milliseconds\nconst DEBOUNCE_TIMEOUT = 150;\n\n// Custom hook to track and return the current window size\nfunction useWindowSize() {\n  // State to store the current window size\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Memoized resize handler\n  const handleResize = useCallback(() => {\n    const newWidth = window.innerWidth;\n    const newHeight = window.innerHeight;\n\n    // Only update if dimensions actually changed\n    if (newWidth !== windowSize.width || newHeight !== windowSize.height) {\n      // Use RAF for smooth updates\n      requestAnimationFrame(() => {\n        setWindowSize({\n          width: newWidth,\n          height: newHeight,\n        });\n      });\n    }\n  }, [windowSize.width, windowSize.height]);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // Debounced resize handler\n    function debouncedResize() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(handleResize, DEBOUNCE_TIMEOUT);\n    }\n\n    // Initial size calculation\n    handleResize();\n\n    // Add event listener with debouncing\n    window.addEventListener('resize', debouncedResize);\n\n    // Cleanup\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      window.removeEventListener('resize', debouncedResize);\n    };\n  }, [handleResize]);\n\n  return windowSize;\n}\n\nexport default useWindowSize;\n","import React, { RefObject } from 'react';\nimport styles from '../styles/ImageViewer.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport ImageFeed from './ImageFeed.js';\n\n// Define the props interface for the ImageViewer component\ninterface ImageViewerProps {\n  selectedFolder: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: RefObject<HTMLElement>;\n}\n\n// Define the ImageViewer component\nconst ImageViewer: React.FC<ImageViewerProps> = ({\n  selectedFolder,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  return (\n    // Main container with flex layout\n    <div className={`${styles.imageViewer} flex flex-col h-full bg-transparent`}>\n      {/* Content container with scrolling */}\n      <div className={`${styles.contentContainer} flex-1`}>\n        {/* Render ImageFeed directly, passing the folderPath and ref */}\n        {/* ImageFeed now handles its own loading, error, and empty states */}\n        <ImageFeed\n          folderPath={selectedFolder}\n          isGrouped={isGrouped}\n          zoom={zoom}\n          viewMode={viewMode}\n          scrollContainerRef={scrollContainerRef}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Export the ImageViewer component\nexport default ImageViewer;\n","import React from 'react';\r\nimport { ViewMode } from '../types/index.js';\r\nimport ImageViewer from './ImageViewer.js';\r\n\r\n// Define the props interface for the MainContent component\r\ninterface MainContentProps {\r\n  // images: ImageInfo[]; // Removed\r\n  selectedFolder: string;\r\n  searchQuery: string; // Kept for now, but its usage needs re-evaluation\r\n  // isLoading: boolean; // Removed\r\n  // error: string | null; // Removed\r\n  zoom: number;\r\n  isGrouped: boolean;\r\n  viewMode: ViewMode;\r\n  scrollContainerRef: React.RefObject<HTMLElement>;\r\n}\r\n\r\n// MainContent component that renders the primary content area of the application\r\nconst MainContent: React.FC<MainContentProps> = ({\r\n  // images, // Removed\r\n  selectedFolder,\r\n  searchQuery, // Kept for now\r\n  // isLoading, // Removed\r\n  // error, // Removed\r\n  zoom,\r\n  isGrouped,\r\n  viewMode,\r\n  scrollContainerRef,\r\n}) => {\r\n  // Removed the filtering logic for now. Search needs to be handled differently.\r\n  // const filteredImages = useMemo(() => {\r\n  //   if (!searchQuery) return images;\r\n  //   return images.filter(image => image.alt.toLowerCase().includes(searchQuery.toLowerCase()));\r\n  // }, [images, searchQuery]);\r\n\r\n  // Render the main content\r\n  return (\r\n    <>\r\n      {/* Render the ImageViewer component */}\r\n      <ImageViewer\r\n        // images={filteredImages} // Removed\r\n        // isLoading={isLoading} // Removed\r\n        // error={error} // Removed\r\n        selectedFolder={selectedFolder}\r\n        zoom={zoom}\r\n        isGrouped={isGrouped}\r\n        viewMode={viewMode}\r\n        scrollContainerRef={scrollContainerRef}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\n// Export the MainContent component\r\nexport default MainContent;\r\n","import { IconFolder } from '@tabler/icons-react';\r\nimport { motion } from 'framer-motion';\r\nimport React from 'react';\r\nimport { useCurrentDirectory } from '../hooks/query/useCurrentDirectory';\r\n\r\n/** Props for the CurrentDirectoryButton component. */\r\ninterface CurrentDirectoryButtonProps {\r\n  // currentDirectory: string; // Removed\r\n}\r\n\r\n/** CurrentDirectoryButton component that displays the current directory.*/\r\nconst CurrentDirectoryButton: React.FC<CurrentDirectoryButtonProps> = () => {\r\n  // Fetch the current directory using the hook\r\n  const { data: currentDirectory, isLoading, isError } = useCurrentDirectory();\r\n\r\n  // Determine button content based on loading/error state\r\n  let buttonContent = '...'; // Loading state\r\n  let buttonClass = 'bg-gray-600 text-gray-400 cursor-not-allowed';\r\n  let iconColor = 'text-gray-500';\r\n\r\n  if (isError) {\r\n    buttonContent = 'Error';\r\n    buttonClass = 'bg-red-800 text-red-200 cursor-not-allowed';\r\n    iconColor = 'text-red-400';\r\n  } else if (!isLoading && currentDirectory) {\r\n    buttonContent = currentDirectory;\r\n    buttonClass = 'bg-gray-700 text-peach hover:bg-gray-600'; // Original classes\r\n    iconColor = 'text-yellow-500'; // Original color\r\n  }\r\n\r\n  return (\r\n    <motion.button\r\n      className={`flex items-center px-3 py-1 rounded-md text-sm transition-all duration-300 ease-in-out ${buttonClass}`}\r\n      whileHover={!isLoading && !isError ? { scale: 1.05 } : {}}\r\n      whileTap={!isLoading && !isError ? { scale: 0.95 } : {}}\r\n      disabled={isLoading || isError}\r\n    >\r\n      {/* Folder icon */}\r\n      <IconFolder size={16} className={`mr-2 ${iconColor}`} />\r\n\r\n      {/* Current directory path or status */}\r\n      <motion.div\r\n        className=\"truncate max-w-xs\"\r\n        initial={{ opacity: 0 }}\r\n        animate={{ opacity: 1 }}\r\n        transition={{ duration: 0.3 }}\r\n      >\r\n        <span>{buttonContent}</span>\r\n      </motion.div>\r\n    </motion.button>\r\n  );\r\n};\r\n\r\nexport default CurrentDirectoryButton;\r\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentDirectory } from '../../lib/api';\r\n\r\n/**\r\n * Custom hook to fetch the current base directory from the server.\r\n *\r\n * @returns The result object from useQuery, containing the directory path string, loading state, error state, etc.\r\n */\r\nexport function useCurrentDirectory() {\r\n  return useQuery<string, Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    queryKey: ['currentDirectory'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getCurrentDirectory,\r\n    // Optional: Consider a longer staleTime as this might not change often\r\n    staleTime: 1000 * 60 * 30, // e.g., stays fresh for 30 minutes\r\n    refetchOnWindowFocus: false, // Likely doesn't need to refetch on focus\r\n  });\r\n}\r\n","import { motion, useAnimation } from 'framer-motion';\nimport { useState } from 'react';\nimport styles from '../styles/SearchBar.module.scss';\n\n// Define the props interface for the SearchBar component\ninterface SearchBarProps {\n  onSearch: (query: string) => void;\n}\n\n// Define the SearchBar component\nconst SearchBar: React.FC<SearchBarProps> = ({ onSearch }) => {\n  // State to manage the search query\n  const [query, setQuery] = useState('');\n  const controls = useAnimation();\n\n  // Handler for form submission\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSearch(query);\n  };\n\n  // Render the SearchBar component\n  return (\n    <motion.form\n      onSubmit={handleSubmit}\n      className={styles.searchBarContainer}\n      initial={{ width: '200px' }}\n      animate={{ width: query ? '300px' : '200px' }}\n      transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n    >\n      <motion.div\n        className={styles.searchBackground}\n        animate={{\n          background: query\n            ? 'linear-gradient(90deg, #4a00e0 0%, #8e2de2 100%)'\n            : 'rgba(255, 255, 255, 0.1)',\n        }}\n      />\n      <motion.input\n        type=\"text\"\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        className={styles.searchInput}\n        placeholder=\"Search the future...\"\n        whileFocus={{ scale: 1.05 }}\n        transition={{ type: 'spring', stiffness: 400, damping: 30 }}\n      />\n    </motion.form>\n  );\n};\n\n// Export the SearchBar component\nexport default SearchBar;\n","import { motion, useAnimation } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\n\n// Define the props interface for the ZoomSlider component\ninterface ZoomSliderProps {\n  zoom: number;\n  onZoomChange: (zoom: number) => void;\n}\n\n// ZoomSlider component for adjusting image zoom level\nconst ZoomSlider: React.FC<ZoomSliderProps> = ({ zoom, onZoomChange }) => {\n  const [isDragging, setIsDragging] = useState(false);\n  const controls = useAnimation();\n\n  // compute animated values manually for Framer Motion\n  const sliderWidth = `${((zoom - 0.5) / 1.5) * 100}%`;\n  const glowOpacity = isDragging ? 1 : 0.6;\n  const glowScale = isDragging ? 1.1 : 1;\n\n  useEffect(() => {\n    controls.start({\n      scale: isDragging ? 1.05 : 1,\n      transition: {\n        type: 'spring',\n        stiffness: 300,\n        damping: 20,\n      },\n    });\n  }, [isDragging, controls]);\n\n  return (\n    <motion.div\n      className=\"relative flex items-center bg-gray-800/80 backdrop-blur-md rounded-full p-3 overflow-hidden\"\n      style={{\n        boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n        width: '200px',\n      }}\n      animate={controls}\n    >\n      {/* Zoom out icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.max(0.5, zoom - 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 mr-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: -90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M11 8V14M8 11H14M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n\n      {/* Slider track */}\n      <div className=\"relative flex-1 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <motion.div\n          className=\"absolute top-0 left-0 h-full bg-blue-500 rounded-full\"\n          style={{ boxShadow: '0 0 10px rgba(59,130,246,0.5)' }}\n          animate={{ width: sliderWidth }}\n          transition={{ type: 'spring', stiffness: 300, damping: 10, precision: 0.01 }}\n        />\n        <input\n          type=\"range\"\n          min=\"0.5\"\n          max=\"2\"\n          step=\"0.1\"\n          value={zoom}\n          onChange={e => onZoomChange(parseFloat(e.target.value))}\n          onMouseDown={() => setIsDragging(true)}\n          onMouseUp={() => setIsDragging(false)}\n          onTouchStart={() => setIsDragging(true)}\n          onTouchEnd={() => setIsDragging(false)}\n          className=\"absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer\"\n        />\n      </div>\n\n      {/* Zoom in icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.min(2, zoom + 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 ml-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: 90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n    </motion.div>\n  );\n};\n\n// Export the ZoomSlider component\nexport default ZoomSlider;\n","import { motion } from 'framer-motion';\nimport React, { useEffect, useRef } from 'react';\nimport styles from '../styles/Navbar.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport CurrentDirectoryButton from './CurrentDirectoryButton';\nimport SearchBar from './SearchBar';\nimport ZoomSlider from './ZoomSlider';\n\n// Update the props interface for the Navbar component\ninterface NavbarProps {\n  // currentDirectory: string; // Removed: Fetched by CurrentDirectoryButton\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n}\n\n// Define the Navbar component\nconst Navbar: React.FC<NavbarProps> = ({\n  // currentDirectory, // Removed\n  onSearch,\n  zoom,\n  onZoomChange,\n  isGrouped,\n  onGroupToggle,\n  viewMode,\n  onViewModeChange,\n}) => {\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  useEffect(() => {\n    const svg = svgRef.current;\n    if (svg) {\n      const animate = () => {\n        const path = svg.querySelector('path');\n        if (path) {\n          const length = path.getTotalLength();\n          path.style.strokeDasharray = `${length} ${length}`;\n          path.style.strokeDashoffset = `${length}`;\n          path.getBoundingClientRect();\n          path.style.transition = 'stroke-dashoffset 2s ease-in-out';\n          path.style.strokeDashoffset = '0';\n        }\n      };\n      animate();\n    }\n  }, []);\n\n  // Render the Navbar component\n  return (\n    <motion.div\n      className={styles.navbar}\n      initial={{ opacity: 0, y: -50 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.5 }}\n    >\n      <svg ref={svgRef} className={styles.navbarBackground}>\n        <path d=\"M0,0 Q50,20 100,10 T200,30 T300,5 T400,25 V100 Q350,80 300,90 T200,70 T100,95 T0,75 Z\" />\n      </svg>\n      {/* Left section of the navbar */}\n      <div className={styles.leftSection}>\n        {/* Display the current directory */}\n        <CurrentDirectoryButton /> {/* No prop needed */}\n        {/* Search functionality */}\n        <SearchBar onSearch={onSearch} />\n      </div>\n      {/* Right section of the navbar */}\n      <div className={styles.rightSection}>\n        {/* View mode toggle buttons */}\n        <div className={styles.viewModeButtons}>\n          {Object.values(ViewMode).map(mode => (\n            <motion.button\n              key={mode}\n              onClick={() => onViewModeChange(mode)}\n              className={`${styles.viewModeButton} ${viewMode === mode ? styles.active : ''}`}\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n            >\n              {mode.charAt(0).toUpperCase() + mode.slice(1)}\n            </motion.button>\n          ))}\n        </div>\n        <motion.button\n          onClick={onGroupToggle}\n          className={styles.viewToggleButton}\n          whileHover={{ scale: 1.05 }}\n          whileTap={{ scale: 0.95 }}\n        >\n          {isGrouped ? 'Ungroup' : 'Group'}\n        </motion.button>\n        {/* Zoom control slider */}\n        <ZoomSlider zoom={zoom} onZoomChange={onZoomChange} />\n      </div>\n    </motion.div>\n  );\n};\n\n// Export the Navbar component\nexport default Navbar;\n","const HOME_DIRECTORY_KEY = 'loraFinderHomeDirectory';\r\n\r\n/**\r\n * Retrieves the stored home directory path from localStorage.\r\n * @returns The stored path string, or null if not set.\r\n */\r\nexport const getHomeDirectory = (): string | null => {\r\n  try {\r\n    return localStorage.getItem(HOME_DIRECTORY_KEY);\r\n  } catch (error) {\r\n    console.error('Error reading home directory from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores the given directory path as the home directory in localStorage.\r\n * @param folderPath - The path to store.\r\n */\r\nexport const setHomeDirectory = (folderPath: string): void => {\r\n  try {\r\n    localStorage.setItem(HOME_DIRECTORY_KEY, folderPath);\r\n  } catch (error) {\r\n    console.error('Error setting home directory in localStorage:', error);\r\n  }\r\n};\r\n","import { motion } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\nimport { FaHome } from 'react-icons/fa';\nimport { useFolders } from '../hooks/query/useFolders';\nimport styles from '../styles/Sidebar.module.scss';\nimport { getHomeDirectory, setHomeDirectory } from '../utils/settings';\n\n// Define the props interface for the Sidebar component\ninterface SidebarProps {\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n}\n\n// Define the Sidebar component\nconst Sidebar: React.FC<SidebarProps> = ({ selectedFolder, onFolderChange }) => {\n  // Call the hook to fetch folders\n  const { data: folders, isLoading, isError, error } = useFolders();\n  // State to track the current home directory for styling\n  const [currentHomeDir, setCurrentHomeDir] = useState<string | null>(null);\n\n  // Effect to load the home directory on mount\n  useEffect(() => {\n    setCurrentHomeDir(getHomeDirectory());\n  }, []);\n\n  // Handler to set a new home directory\n  const handleSetHome = (folderPath: string, event: React.MouseEvent) => {\n    event.stopPropagation(); // Prevent folder selection when clicking set home\n    setHomeDirectory(folderPath);\n    setCurrentHomeDir(folderPath);\n    console.log('Set home directory:', folderPath);\n  };\n\n  // Render loading state\n  if (isLoading) {\n    return (\n      <motion.div\n        initial={{ x: -300 }}\n        animate={{ x: 0 }}\n        transition={{ type: 'spring', stiffness: 120 }}\n        className={`${styles.sidebar} ${styles.loading}`}\n      >\n        Loading folders...\n      </motion.div>\n    );\n  }\n\n  // Render error state\n  if (isError) {\n    return (\n      <motion.div\n        initial={{ x: -300 }}\n        animate={{ x: 0 }}\n        transition={{ type: 'spring', stiffness: 120 }}\n        className={`${styles.sidebar} ${styles.error}`}\n      >\n        Error: {error?.message || 'Failed to load folders'}\n      </motion.div>\n    );\n  }\n\n  // Render the main sidebar\n  return (\n    // Main sidebar container\n    <motion.div\n      initial={{ x: -300 }}\n      animate={{ x: 0 }}\n      transition={{ type: 'spring', stiffness: 120 }}\n      className={styles.sidebar}\n    >\n      <div className={`${styles.sidebar} flex flex-col h-full`}>\n        {/* Logo section */}\n        <div className={styles.logo}>Lora Finder</div>\n        {/* Folder list */}\n        <ul className={`${styles.folderList} flex-grow overflow-y-auto`}>\n          {/* Map through folders (from hook) and create buttons for each */}\n          {(folders ?? []).map(folder => (\n            <li key={folder.name} className={`${styles.folderItem} group`}>\n              <button\n                onClick={() => {\n                  onFolderChange(folder.name);\n                }}\n                className={`${styles.folderButton} ${\n                  selectedFolder === folder.name ? styles.selectedFolder : ''\n                }`}\n              >\n                <span className={styles.folderName}>{folder.name}</span>\n                <button\n                  onClick={e => handleSetHome(folder.name, e)}\n                  className={`${styles.setHomeButton} ${folder.name === currentHomeDir ? styles.isHome : 'opacity-0 group-hover:opacity-100'}`}\n                  title={`Set ${folder.name} as home directory`}\n                >\n                  <FaHome />\n                </button>\n              </button>\n            </li>\n          ))}\n        </ul>\n        {/* Upload button */}\n        <div className=\"p-8 mt-auto\">\n          <button className={`${styles.uploadButton} w-full`}>Upload</button>\n        </div>\n      </div>\n    </motion.div>\n  );\n};\n\n// Export the Sidebar component\nexport default Sidebar;\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getFolders } from '../../lib/api';\r\nimport { FolderInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch the list of available folders using React Query.\r\n *\r\n * @returns The result object from useQuery, containing folder data, loading state, error state, etc.\r\n */\r\nexport function useFolders() {\r\n  return useQuery<FolderInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Stays constant as we expect the same folder list unless invalidated.\r\n    queryKey: ['folders'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getFolders,\r\n    // Optional: Configure staleTime and gcTime if different from defaults\r\n    // staleTime: 1000 * 60 * 10, // e.g., folders stay fresh for 10 mins\r\n  });\r\n}\r\n","// Cache Time-To-Live: Duration in milliseconds for which cached data remains valid\nexport const CACHE_TTL = 600000;\n\n// Maximum upload size: Limit for file uploads in bytes (default is ~1.5GB)\nexport const MAX_UPLOAD_SIZE = 1610612736;\n\n// Supported image formats: List of file extensions for allowed image uploads\nexport const SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif'];\n\n// API base URL: Root URL for API endpoints\nexport const API_BASE_URL = 'http://localhost:3000/api';\n\n// Server port: Port number on which the server will listen\nexport const PORT = 3000;\n\n// Host: Hostname or IP address on which the server will run\nexport const HOST = 'localhost';\n\n// Custom properties for dynamic styling\nexport const CUSTOM_PROPERTIES = {\n  SCROLL_Y: '--scroll-y',\n  MOUSE_X: '--mouse-x',\n  MOUSE_Y: '--mouse-y',\n};\n\n// Default values for custom properties\nexport const DEFAULT_CUSTOM_PROPERTY_VALUES = {\n  [CUSTOM_PROPERTIES.SCROLL_Y]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_X]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_Y]: '0px',\n};\n","import React, { useState } from 'react';\nimport { ViewMode } from '../types/index.js';\nimport MainContent from './MainContent.js';\nimport Navbar from './Navbar.js';\nimport Sidebar from './Sidebar.js';\n// import { getImages } from '../lib/api.js'; // Removed: Data fetching moved to hooks/ImageFeed\nimport gsap from 'gsap';\nimport { ScrollToPlugin } from 'gsap/ScrollToPlugin';\nimport { ColorProvider } from '../contexts/ColorContext';\nimport { useCustomProperties } from '../hooks/useCustomProperties';\n// Import the new AuraBackground\nimport AuraBackground from './AuraBackground.js';\n// Remove ParticleBackground import\n// import ParticleBackground from './ParticleBackground.js';\n\ngsap.registerPlugin(ScrollToPlugin);\n\n// Define the props interface for the Layout component\ninterface LayoutProps {\n  children: React.ReactNode;\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n  mainRef: React.RefObject<HTMLElement>;\n}\n\n// Define the Layout component\nconst Layout: React.FC<LayoutProps> = ({\n  children,\n  selectedFolder,\n  onFolderChange,\n  onSearch,\n  zoom,\n  onZoomChange,\n  isGrouped,\n  onGroupToggle,\n  viewMode,\n  onViewModeChange,\n  mainRef,\n}) => {\n  useCustomProperties();\n\n  // State variables for managing images, loading state, error, and search query\n  // const [images, setImages] = useState<ImageInfo[]>([]); // Removed: Managed by react-query in ImageFeed\n  // const [isLoading, setIsLoading] = useState(false); // Removed\n  // const [error, setError] = useState<string | null>(null); // Removed\n  const [searchQuery, setSearchQuery] = useState(''); // Kept for now, search logic needs update\n\n  // Effect hook to fetch images when the selected folder changes\n  // useEffect(() => {\n  //   const fetchImages = async () => {\n  //     setIsLoading(true);\n  //     setError(null);\n  //     try {\n  //       const fetchedImages = await getImages(selectedFolder);\n  //       setImages(fetchedImages || []); // Ensure we always set an array\n  //     } catch (err: any) {\n  //       const errorMessage = err.message || 'Failed to fetch images';\n  //       setError(errorMessage);\n  //       setImages([]); // Set empty array on error\n  //       console.error('Error fetching images:', err);\n  //     } finally {\n  //       setIsLoading(false);\n  //     }\n  //   };\n\n  //   if (selectedFolder) {\n  //     fetchImages();\n  //   } else {\n  //     setImages([]);\n  //     setError('No folder selected');\n  //   }\n  // }, [selectedFolder]); // Removed: Data fetching moved to hooks/ImageFeed\n\n  // Handler for search functionality\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    onSearch(query); // Propagate search up if needed\n  };\n\n  // Handler for when image upload is complete\n  // const handleUploadComplete = () => {\n  //   // Refetch images after upload\n  //   // This logic needs to be replaced with query invalidation\n  //   // e.g., using queryClient.invalidateQueries(['images', selectedFolder]);\n  //   const fetchImages = async () => {\n  //     setIsLoading(true);\n  //     setError(null);\n  //     try {\n  //       const fetchedImages = await getImages(selectedFolder);\n  //       setImages(fetchedImages);\n  //     } catch (err) {\n  //       setError('Failed to fetch images');\n  //       console.error(err);\n  //     } finally {\n  //       setIsLoading(false);\n  //     }\n  //   };\n\n  //   fetchImages();\n  // }; // Removed: Needs replacement with react-query invalidation\n\n  // Render the layout structure\n  return (\n    <div className=\"flex flex-col h-screen relative bg-transparent\">\n      <ColorProvider>\n        <div className=\"gradient-overlay\"></div>\n        {/* Use AuraBackground instead of ParticleBackground */}\n        <AuraBackground />\n        {/* <ParticleBackground /> */}\n        <Navbar\n          onSearch={handleSearch}\n          zoom={zoom}\n          onZoomChange={onZoomChange}\n          isGrouped={isGrouped}\n          onGroupToggle={onGroupToggle}\n          viewMode={viewMode}\n          onViewModeChange={onViewModeChange}\n        />\n        <div className=\"flex flex-1 overflow-hidden\">\n          <Sidebar selectedFolder={selectedFolder} onFolderChange={onFolderChange} />\n          <main ref={mainRef} className=\"flex-1 overflow-auto p-4 relative bg-transparent\">\n            <div className=\"relative z-10\">\n              <MainContent\n                // images={images} // Removed\n                selectedFolder={selectedFolder}\n                searchQuery={searchQuery}\n                // isLoading={isLoading} // Removed\n                // error={error} // Removed\n                zoom={zoom}\n                isGrouped={isGrouped}\n                viewMode={viewMode}\n                scrollContainerRef={mainRef}\n              />\n            </div>\n          </main>\n        </div>\n      </ColorProvider>\n    </div>\n  );\n};\n\nexport default Layout;\n","import { useEffect } from 'react';\nimport { CUSTOM_PROPERTIES, DEFAULT_CUSTOM_PROPERTY_VALUES } from '../utils/constants';\n\nexport function useCustomProperties() {\n  useEffect(() => {\n    function updateCustomProperties(e: MouseEvent) {\n      const mouseX = e.clientX;\n      const mouseY = e.clientY;\n\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_X, `${mouseX}px`);\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_Y, `${mouseY}px`);\n    }\n\n    function updateScrollProperty() {\n      const scrollY = window.scrollY;\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.SCROLL_Y, `${scrollY}px`);\n    }\n\n    // Set default values\n    Object.entries(DEFAULT_CUSTOM_PROPERTY_VALUES).forEach(([property, value]) => {\n      document.documentElement.style.setProperty(property, value);\n    });\n\n    window.addEventListener('scroll', updateScrollProperty);\n    document.addEventListener('mousemove', updateCustomProperties);\n    document.addEventListener('click', updateCustomProperties);\n\n    return () => {\n      window.removeEventListener('scroll', updateScrollProperty);\n      document.removeEventListener('mousemove', updateCustomProperties);\n      document.removeEventListener('click', updateCustomProperties);\n    };\n  }, []);\n}\n","import React, { useRef, useState } from 'react';\nimport Layout from '../components/Layout.js';\nimport MainContent from '../components/MainContent.js';\n// import { getFolders, getImages } from '../lib/api.js'; // getFolders no longer needed here\nimport { ViewMode } from '../types/index.js';\n// Import the settings utilities\nimport { getHomeDirectory } from '../utils/settings.js';\n\n/**\n * Home component - the main page of the application.\n * It manages the overall state and layout of the app.\n *\n * @component\n * @returns {JSX.Element} The main application page.\n */\nconst Home: React.FC = () => {\n  // State declarations for managing application data and UI\n  // const [folders, setFolders] = useState<FolderInfo[]>([]); // Removed: Managed by useFolders in Sidebar\n  const [selectedFolder, setSelectedFolder] = useState<string>(() => {\n    return getHomeDirectory() || '';\n  });\n  // const [images, setImages] = useState<ImageInfo[]>([]); // Removed\n  const [zoom, setZoom] = useState<number>(1);\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  // const [currentDirectory, setCurrentDirectory] = useState<string>(''); // Removed: Managed by useCurrentDirectory\n  // const [isLoading, setIsLoading] = useState<boolean>(false); // Removed\n  // const [error, setError] = useState<string | null>(null); // Removed\n  const [isGrouped, setIsGrouped] = useState<boolean>(true);\n  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.GRID);\n\n  // Create ref for the main scrollable element\n  const mainScrollRef = useRef<HTMLElement>(null);\n\n  /**\n   * Effect hook to fetch the list of folders when the component mounts.\n   * Sets the first folder as selected if available.\n   * Removed: This is now handled by Sidebar component via useFolders hook.\n   */\n  // useEffect(() => {\n  //   const fetchFolders = async () => {\n  //     try {\n  //       const folderList = await getFolders();\n  //       setFolders(folderList);\n  //       if (folderList.length > 0 && !selectedFolder) { // Only set initial folder if none selected\n  //         setSelectedFolder(folderList[0].name);\n  //       }\n  //     } catch (error) {\n  //       console.error('Error fetching folders:', error);\n  //       // setError('Failed to fetch folders'); // setError removed\n  //     }\n  //   };\n\n  //   fetchFolders();\n  // }, [selectedFolder]);\n\n  /**\n   * Effect hook to fetch images when the selected folder changes.\n   * Updates loading state and handles errors.\n   * Removed: This is now handled by ImageFeed component via useFolderImages hook.\n   */\n  // ... (Removed image fetching useEffect)\n\n  /**\n   * Handler for folder selection change.\n   * Updates the selected folder state.\n   * @param {string} folder - The newly selected folder.\n   */\n  const handleFolderChange = (folder: string) => {\n    setSelectedFolder(folder);\n    // No need to fetch images here manually anymore\n  };\n\n  /**\n   * Handler for zoom level change.\n   * Updates the zoom state.\n   * @param {number} newZoom - The new zoom level.\n   */\n  const handleZoomChange = (newZoom: number) => {\n    setZoom(newZoom);\n  };\n\n  /**\n   * Handler for search query change.\n   * Updates the search query state.\n   * @param {string} query - The new search query.\n   */\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    // Search result display needs to be handled\n  };\n\n  /**\n   * Handler for file upload completion.\n   * Refreshes the images in the current folder.\n   * TODO: Replace with query invalidation using queryClient\n   */\n  const handleUploadComplete = () => {\n    // Example: queryClient.invalidateQueries(['images', selectedFolder]);\n    console.log('TODO: Invalidate query for folder:', selectedFolder);\n  };\n\n  /**\n   * Handler for grouping toggle.\n   * Toggles the grouping state.\n   */\n  const handleGroupToggle = () => {\n    setIsGrouped(prevState => !prevState);\n  };\n\n  const handleViewModeChange = (newMode: ViewMode) => {\n    setViewMode(newMode);\n  };\n\n  // Render the main layout with all necessary props\n  // Note: 'folders' & 'currentDirectory' props are removed from Layout\n  return (\n    <Layout\n      // folders={folders} // Removed\n      selectedFolder={selectedFolder}\n      onFolderChange={handleFolderChange}\n      // currentDirectory={selectedFolder} // Removed\n      onSearch={handleSearch}\n      zoom={zoom}\n      onZoomChange={handleZoomChange}\n      isGrouped={isGrouped}\n      onGroupToggle={handleGroupToggle}\n      viewMode={viewMode}\n      onViewModeChange={handleViewModeChange}\n      mainRef={mainScrollRef}\n    >\n      {/* Pass relevant state down to MainContent */}\n      {/* MainContent no longer needs images, isLoading, error */}\n      <MainContent\n        // images={images} // Removed\n        zoom={zoom}\n        searchQuery={searchQuery}\n        // isLoading={isLoading} // Removed\n        // error={error} // Removed\n        selectedFolder={selectedFolder}\n        isGrouped={isGrouped}\n        viewMode={viewMode}\n        scrollContainerRef={mainScrollRef}\n      />\n    </Layout>\n  );\n};\n\nexport default Home;\n","import Home from './pages/Home.js';\nimport './styles/views.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Home />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App.js';\n\nexport function render() {\n  const html = ReactDOMServer.renderToString(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n  return { html };\n}\n"],"names":["ViewMode","truncateImageTitle","title","formattedTitle","replace","split","map","word","match","charAt","toUpperCase","slice","toLowerCase","join","trim","length","substring","initialDefaultColor","initialHoverState","isHovering","position","color","ColorContext","createContext","dominantColors","setDominantColors","hoverState","setHoverState","ColorProvider","children","setDominantColorsState","useState","setHoverStateInternal","useCallback","newState","prevState","contextValue","useMemo","Provider","value","gsap","registerPlugin","ScrollTrigger","_ScrollTriggerManager","constructor","__publicField","this","Map","timeline","paused","smoothChildTiming","mainTrigger","create","trigger","document","body","start","end","onUpdate","self","progress","markers","getInstance","instance","addAnimation","id","element","animationProps","animation","to","add","targets","set","removeAnimation","target","get","remove","delete","cleanup","forEach","kill","clear","getAll","ScrollTriggerManager","CustomEase","_AnimationSystem","initializeCustomEases","scrollTriggerManager","getAnimationProperties","itemId","duration","ease","transformOrigin","scale","rotation","createHoverAnimation","force3D","createMorphAnimation","borderRadius","boxShadow","createScrollAnimation","AnimationSystem","ResponsiveImage","React","forwardRef","src","alt","width","isProcessed","onLoad","onError","className","style","ref","isInternallyLoaded","setIsInternallyLoaded","useEffect","handleLoad","handleError","useSrcSet","startsWith","srcSet","Math","round","sizes","jsx","motion","img","loading","display","height","objectFit","top","left","initial","opacity","animate","transition","displayName","ImageItem$1","memo","image","onClick","containerWidth","containerHeight","zoom","groupCount","workerPool","onResize","isCarousel","groupImages","onImageHover","onImageLoadError","imageRef","useRef","containerRef","isHighResLoaded","setIsHighResLoaded","processedUrls","setProcessedUrls","useContext","isIntersecting","setIsIntersecting","processedRequestedRef","hasError","setHasError","hasLowResProcessed","setHasLowResProcessed","hasHighResProcessed","setHasHighResProcessed","placeholderColor","targetWidth","targetHeight","aspectRatio","handleMouseEnter","current","rect","getBoundingClientRect","centerX","centerY","normalizedX","window","innerWidth","normalizedY","innerHeight","x","y","imageId","handleMouseLeave","console","log","handleProcessedImage","data","prev","quality","processedImage","observer","IntersectionObserver","entry","getImageProcessor","requestImageProcessing","root","rootMargin","threshold","currentRef","observe","unobserve","currentLowUrl","low","currentHighUrl","high","URL","revokeObjectURL","currentSrc","isUsingProcessed","shouldRenderImage","handleImageLoad","handleImageError","jsxs","styles","imageItemContainer","onMouseEnter","onMouseLeave","overflow","cursor","backgroundColor","imageElement","errorOverlay","titleOverlay","groupIndicator","smoothLayoutTransition","type","stiffness","damping","mass","itemVariants","hidden","visible","i","delay","ImageRow$1","images","imageWidths","onImageClick","columns","isLastRow","rowHeight","groupedImages","gap","rowRef","controls","useAnimation","div","flexWrap","marginBottom","willChange","maxWidth","justifyContent","alignItems","layout","index","group","find","g","some","warn","custom","variants","flexShrink","flexGrow","ImageItem","ImageSkeleton","imageItem","imageSkeleton","maxHeight","skeletonAnimation","api","axios","baseURL","async","getFolders","folder","name","path","error","Error","getCurrentDirectory","currentDirectory","useFolderImages","useQuery","queryKey","queryFn","response","encodeURIComponent","Array","isArray","message","_a","statusText","request","getImages","enabled","placeholderData","previousData","SCROLL_STATE_STORE_NAME","dbPromise","openScrollStateDB","openDB","upgrade","db","objectStoreNames","contains","createObjectStore","saveScrollState","folderPath","scrollTop","tx","transaction","store","objectStore","stateToSave","timestamp","Date","now","put","done","MIN_IMAGE_WIDTH","aspectRatioCache","WeakMap","sortedImagesCache","calculateGapSize","baseGap","max","min","roundedGap","getAspectRatio","ratio","calculateOptimalDistribution","aspectRatios","batchProcessAspectRatios","totalAspectRatio","reduce","sum","totalGapWidth","idealHeight","widths","floor","checkRowFit","minWidth","allImagesWideEnough","every","totalWidth","fits","predictedWidths","distributeImages","targetRowHeight","sortedImages","cacheKey","has","sorted","sort","a","b","getSortedImages","rows","currentRow","currentRowAspectRatio","testRow","currentWidths","calculatedWidthSum","adjustedWidths","discrepancy","push","offset","initialWidths","calculateLayout","config","viewMode","isGrouped","effectiveWidth","baseColumns","calculateColumns","minImageWidth","maxImageWidth","areDimensionsDifferent","cachedWidth","cachedHeight","requestedWidth","requestedHeight","widthDiff","abs","heightDiff","ImageProcessor","worker","Worker","url","initDB","onmessage","handleWorkerMessage","bind","onerror","isProcessing","processNextRequest","keyPath","openCursor","staleCount","isLowStale","isHighStale","_b","continue","getCachedImageData","cacheImageData","imageDataUrl","newData","requestQueue","shift","isWorkerCancelled","processImageRequest","payload","callback","processBatchRequest","setTimeout","cachedData","needsProcessing","reason","existingCallbacks","callbacks","includes","postMessage","action","batchCallback","imagesToSendToWorker","event","imageCallbacks","cb","requestBatchProcessing","cancel","terminate","close","_WorkerPool","imageProcessor","isInitialized","cancelPendingTasks","WorkerPool","hexToVec3","hex","r","parseInt","lerpArray","t","val","lerp","AuraBackground$1","canvasRef","glRef","programRef","bufferRef","attribLocationsRef","uniformLocationsRef","animationFrameRef","animatedColor1","animatedColor2","animatedMixFactor","animatedHoverPos","animatedIsHovering","createShader","gl","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","VERTEX_SHADER","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","renderLoop","time","requestAnimationFrame","timeSeconds","lerpSpeed","targetColor1","targetColor2","targetMix","targetIsHovering","targetPos","viewport","canvas","useProgram","bindBuffer","ARRAY_BUFFER","posLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","uniform2f","resolution","uniform1f","uniform3fv","colorTarget1","colorTarget2","colorMixFactor","uniform2fv","hoverPos","drawArrays","TRIANGLES","canvasElement","getContext","alpha","antialias","FRAGMENT_SHADER","detachShader","positions","Float32Array","createBuffer","bufferData","STATIC_DRAW","getAttribLocation","getUniformLocation","hoverColor","resizeObserver","ResizeObserver","entries","contentRect","cancelAnimationFrame","disconnect","currentGl","deleteBuffer","pointerEvents","zIndex","BannerView","NextArrow","props","FaChevronRight","PrevArrow","FaChevronLeft","CarouselView","Slider","dots","infinite","speed","slidesToShow","slidesToScroll","nextArrow","prevArrow","adaptiveHeight","customPaging","MasonryView","Masonry","breakpointCols","default","columnClassName","debounce","func","waitFor","timeoutId","debounced","args","clearTimeout","ImageFeed$1","scrollContainerRef","originalImages","isLoading","isError","isPlaceholderData","windowSize","setWindowSize","handleResize","newWidth","newHeight","debouncedResize","addEventListener","removeEventListener","useWindowSize","feedRef","setContainerWidth","setColumns","lightboxIndex","setLightboxIndex","lightboxImages","setLightboxImages","scrollY","useViewportScroll","useTransform","facRef","lastProcessedRowIndexRef","hoverTimeoutRef","restoredState","setRestoredState","previousFolderPathRef","rowHeightsRef","isRestoringScrollRef","velocityEMARef","dynamicOverscan","setDynamicOverscan","failedImageIds","setFailedImageIds","Set","debouncedIsGrouped","setDebouncedIsGrouped","updateDebouncedGrouped","lodashDebounce","newValue","handleImageLoadError","newSet","debouncedSaveScroll","scroll","isMounted","loadedState","state","loadScrollState","loadAndSetState","currentPathForCleanup","scrollElement","folderToSave","call","avgAspectRatio","validImages","filter","layoutMetrics","gapSize","estimatedRowHeightFallback","availableWidthForImages","estimatedAvgImageWidth","FastAverageColor","destroy","updateContainerWidth","prevWidth","useLayoutEffect","timeEnd","result","key","processedTitles","groups","processedTitle","Object","groupedRows","GRID","firstImages","row","handleImageClick","clickedImage","groupIndex","findIndex","imageIndexInGroup","lastScrollTopRef","lastScrollTimeRef","performance","handleScroll","timeDelta","scrollDelta","velocity","calculatedOverscan","OVERSCAN_MAX","throttledScrollHandler","limit","inThrottle","context","apply","throttle","rowVirtualizer","useVirtualizer","count","getScrollElement","estimateSize","overscan","measure","virtualItems","getVirtualItems","handleImageHover","getImageUrl","imagePath","lightboxPlugins","Captions","Counter","Thumbnails","Zoom","slides","imageUrl","getColorAsync","e","firstImage","renderSkeletons","approxWidth","approxHeight","skeletonCount","gridContainer","exit","from","_","container","feed","noImages","AuraBackground","currentImages","showSkeletons","ViewComponent","MASONRY","BANNER","CAROUSEL","getTotalSize","virtualItem","measureElement","size","transform","ImageRow","Lightbox","open","plugins","ImageViewer","selectedFolder","ImageFeed","MainContent","searchQuery","Fragment","CurrentDirectoryButton","staleTime","refetchOnWindowFocus","buttonContent","buttonClass","iconColor","button","whileHover","whileTap","disabled","IconFolder","SearchBar","onSearch","query","setQuery","form","onSubmit","preventDefault","background","input","onChange","placeholder","whileFocus","ZoomSlider","onZoomChange","isDragging","setIsDragging","sliderWidth","glowOpacity","glowScale","svg","viewBox","fill","xmlns","rotate","d","stroke","strokeWidth","strokeLinecap","strokeLinejoin","precision","step","parseFloat","onMouseDown","onMouseUp","onTouchStart","onTouchEnd","Navbar","onGroupToggle","onViewModeChange","svgRef","querySelector","getTotalLength","strokeDasharray","strokeDashoffset","values","mode","HOME_DIRECTORY_KEY","getHomeDirectory","localStorage","getItem","Sidebar","onFolderChange","folders","currentHomeDir","setCurrentHomeDir","handleSetHome","stopPropagation","setItem","setHomeDirectory","sidebar","logo","folderList","folderItem","folderButton","folderName","setHomeButton","isHome","FaHome","uploadButton","CUSTOM_PROPERTIES","DEFAULT_CUSTOM_PROPERTY_VALUES","CUSTOM_PROPERTIES_SCROLL_Y","CUSTOM_PROPERTIES_MOUSE_X","CUSTOM_PROPERTIES_MOUSE_Y","ScrollToPlugin","Layout","mainRef","updateCustomProperties","mouseX","clientX","mouseY","clientY","documentElement","setProperty","updateScrollProperty","property","setSearchQuery","Home","setSelectedFolder","setZoom","setIsGrouped","setViewMode","mainScrollRef","newZoom","newMode","App","render","html","ReactDOMServer","renderToString","StrictMode"],"mappings":"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"}