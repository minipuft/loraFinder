{"version":3,"file":"entry-server.js","sources":["../../src/contexts/AnimationControllerContext.tsx","../../src/contexts/ColorContext.tsx","../../src/contexts/ImageProcessingContext.tsx","../../src/types/index.ts","../../src/lib/api.ts","../../src/components/CurrentDirectoryButton.tsx","../../src/hooks/query/useCurrentDirectory.ts","../../src/components/SearchBar.tsx","../../src/components/ZoomSlider.tsx","../../src/components/Navbar.tsx","../../src/utils/settings.ts","../../src/components/Sidebar.tsx","../../src/hooks/query/useFolders.ts","../../src/utils/constants.ts","../../src/components/AuraBackground.tsx","../../src/components/Layout.tsx","../../src/hooks/useCustomProperties.ts","../../src/hooks/query/useFolderImages.ts","../../src/workers/imageProcessor.ts","../../src/workers/workerPool.ts","../../src/lib/cache/feedStateCache.ts","../../src/utils/ScrollTriggerManager.ts","../../src/utils/AnimationSystem.ts","../../src/utils/layoutCalculator.ts","../../src/animations/motionPresets.ts","../../src/animations/MotionPreset.tsx","../../src/components/ImageItem.tsx","../../src/utils/stringUtils.ts","../../src/components/ImageRow.tsx","../../src/components/ImageSkeleton.tsx","../../src/components/views/BannerView.tsx","../../src/components/views/CarouselView.tsx","../../src/components/views/MasonryView.tsx","../../src/components/ImageFeed.tsx","../../src/hooks/useWindowSize.ts","../../src/hooks/usePrefetchManager.ts","../../src/components/ImageViewer.tsx","../../src/components/MainContent.tsx","../../src/animations/AnimationPipeline.ts","../../src/pages/Home.tsx","../../src/hooks/useAnimationPipeline.ts","../../src/App.tsx","../../src/entry-server.tsx"],"sourcesContent":["import React, { createContext, useCallback, useContext, useMemo, useRef } from 'react';\r\nimport { AnimationPipeline } from '../animations/AnimationPipeline';\r\n\r\n// Define the structure for a registered pipeline\r\ninterface RegisteredPipeline {\r\n  id: string;\r\n  pipeline: AnimationPipeline;\r\n  triggerEvents: string[]; // Events that should trigger this pipeline\r\n  playOnTrigger?: boolean; // If true, plays; if false (or undefined), restarts\r\n}\r\n\r\n// Define the shape of the context value\r\ninterface AnimationControllerContextValue {\r\n  /**\r\n   * Triggers a specific event, potentially starting registered pipelines.\r\n   * @param eventName The name of the event to trigger (e.g., 'routeEnter', 'dataLoaded').\r\n   */\r\n  trigger: (eventName: string) => void;\r\n\r\n  /**\r\n   * Registers an AnimationPipeline instance to be triggered by specific events.\r\n   * Returns a function to unregister the pipeline.\r\n   *\r\n   * @param id A unique identifier for the pipeline.\r\n   * @param pipeline The AnimationPipeline instance.\r\n   * @param triggerEvents An array of event names that should trigger this pipeline.\r\n   * @param playOnTrigger If true, calls play(); otherwise calls restart(). Defaults to false (restart).\r\n   * @returns A function to call for unregistering the pipeline.\r\n   */\r\n  registerPipeline: (\r\n    id: string,\r\n    pipeline: AnimationPipeline,\r\n    triggerEvents: string[],\r\n    playOnTrigger?: boolean\r\n  ) => () => void; // Returns unregister function\r\n}\r\n\r\n// Create the context with a default value (or null)\r\nconst AnimationControllerContext = createContext<AnimationControllerContextValue | null>(null);\r\n\r\n// Define props for the provider\r\ninterface AnimationControllerProviderProps {\r\n  children: React.ReactNode;\r\n}\r\n\r\n// Implement the Provider component\r\nexport const AnimationControllerProvider: React.FC<AnimationControllerProviderProps> = ({\r\n  children,\r\n}) => {\r\n  // Use useRef to store pipelines to avoid re-renders on registration/unregistration\r\n  const pipelinesRef = useRef<Map<string, RegisteredPipeline>>(new Map());\r\n  // Optional: State to track the last triggered event if needed elsewhere\r\n  // const [lastEvent, setLastEvent] = useState<string | null>(null);\r\n\r\n  // --- Trigger Function --- >\r\n  const trigger = useCallback((eventName: string) => {\r\n    console.log(`[AnimationController] Triggering event: \"${eventName}\"`);\r\n    // setLastEvent(eventName); // Update last event state if needed\r\n\r\n    pipelinesRef.current.forEach(registered => {\r\n      if (registered.triggerEvents.includes(eventName)) {\r\n        console.log(\r\n          `[AnimationController] Running pipeline \"${registered.id}\" for event \"${eventName}\"`\r\n        );\r\n        if (registered.playOnTrigger) {\r\n          registered.pipeline.play().catch(err => {\r\n            console.error(`Error playing pipeline ${registered.id}:`, err);\r\n          });\r\n        } else {\r\n          registered.pipeline.restart().catch(err => {\r\n            console.error(`Error restarting pipeline ${registered.id}:`, err);\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  // --- Register Function --- >\r\n  const registerPipeline = useCallback(\r\n    (\r\n      id: string,\r\n      pipeline: AnimationPipeline,\r\n      triggerEvents: string[],\r\n      playOnTrigger: boolean = false // Default to restart\r\n    ): (() => void) => {\r\n      if (pipelinesRef.current.has(id)) {\r\n        console.warn(\r\n          `[AnimationController] Pipeline with ID \"${id}\" already registered. Overwriting.`\r\n        );\r\n      }\r\n      console.log(`[AnimationController] Registering pipeline \"${id}\" for events:`, triggerEvents);\r\n      pipelinesRef.current.set(id, { id, pipeline, triggerEvents, playOnTrigger });\r\n\r\n      // Return the unregister function\r\n      return () => {\r\n        console.log(`[AnimationController] Unregistering pipeline \"${id}\"`);\r\n        pipelinesRef.current.delete(id);\r\n        // Note: The pipeline itself should be killed by the component that created it\r\n        // using the useAnimationPipeline hook's cleanup.\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  // --- Context Value --- >\r\n  const contextValue: AnimationControllerContextValue = useMemo(\r\n    () => ({ trigger, registerPipeline }),\r\n    [trigger, registerPipeline]\r\n  );\r\n\r\n  return (\r\n    <AnimationControllerContext.Provider value={contextValue}>\r\n      {children}\r\n    </AnimationControllerContext.Provider>\r\n  );\r\n};\r\n\r\n// --- Consumer Hook --- >\r\nexport const useAnimationController = (): AnimationControllerContextValue => {\r\n  const context = useContext(AnimationControllerContext);\r\n  if (!context) {\r\n    throw new Error('useAnimationController must be used within an AnimationControllerProvider');\r\n  }\r\n  return context;\r\n};\r\n","import React, { createContext, ReactNode, useCallback, useMemo, useState } from 'react';\n\n// Define hover state structure\ninterface HoverState {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates [0, 1] relative to background\n  color: string | null; // Optional: Dominant color of hovered item\n}\n\n// Define the shape of the context data\ninterface ColorContextProps {\n  // Store maybe 1 or 2 dominant colors. Using string[] for flexibility.\n  dominantColors: string[];\n  setDominantColors: (colors: string[]) => void;\n  // Add hover state\n  hoverState: HoverState;\n  setHoverState: (newState: Partial<HoverState>) => void; // Allow partial updates\n}\n\n// Default initial background color (dark blueish)\nconst initialDefaultColor = '#041024';\n\n// Initial hover state\nconst initialHoverState: HoverState = {\n  isHovering: false,\n  position: null,\n  color: null,\n};\n\n// Create the context with a default value\nexport const ColorContext = createContext<ColorContextProps>({\n  dominantColors: [initialDefaultColor],\n  setDominantColors: () => {}, // No-op function as default\n  hoverState: initialHoverState,\n  setHoverState: () => {}, // No-op\n});\n\n// Create the provider component\ninterface ColorProviderProps {\n  children: ReactNode;\n}\n\nexport const ColorProvider: React.FC<ColorProviderProps> = ({ children }) => {\n  const [dominantColors, setDominantColorsState] = useState<string[]>([initialDefaultColor]);\n  const [hoverState, setHoverStateInternal] = useState<HoverState>(initialHoverState);\n\n  // Create a stable setter function that allows partial updates\n  const setHoverState = useCallback((newState: Partial<HoverState>) => {\n    setHoverStateInternal(prevState => ({ ...prevState, ...newState }));\n  }, []);\n\n  // Avoid re-creating the context value object on every render\n  const contextValue = useMemo(\n    () => ({\n      dominantColors,\n      setDominantColors: setDominantColorsState,\n      hoverState,\n      setHoverState, // Provide the stable setter\n    }),\n    [dominantColors, hoverState, setHoverState] // Add dependencies\n  );\n\n  return <ColorContext.Provider value={contextValue}>{children}</ColorContext.Provider>;\n};\n","import React, { createContext, ReactNode, useCallback, useContext, useMemo } from 'react';\r\n\r\n// Type for the data sent when an image is processed\r\nexport interface ProcessedImageUpdate {\r\n  id: string;\r\n  quality: 'low' | 'high';\r\n  imageUrl: string;\r\n  // Include dimensions if available and needed by ImageItem\r\n  width?: number;\r\n  height?: number;\r\n}\r\n\r\n// Type for the callback function used by subscribers\r\ntype ImageUpdateCallback = (data: ProcessedImageUpdate) => void;\r\n\r\n// Type for the context value\r\ninterface ImageProcessingContextType {\r\n  subscribeToImageUpdates: (imageId: string, callback: ImageUpdateCallback) => () => void; // Returns unsubscribe function\r\n  publishImageUpdate: (data: ProcessedImageUpdate) => void;\r\n}\r\n\r\n// Create the context with a default value (can be null or a dummy implementation)\r\nconst ImageProcessingContext = createContext<ImageProcessingContextType | null>(null);\r\n\r\n// Provider component props\r\ninterface ImageProcessingProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n// Keep track of subscriptions outside the component state if preferred\r\n// This avoids re-rendering the provider on every subscription change\r\nconst subscriptions = new Map<string, Set<ImageUpdateCallback>>();\r\n\r\n// Provider component implementation\r\nexport const ImageProcessingProvider: React.FC<ImageProcessingProviderProps> = ({ children }) => {\r\n  const subscribeToImageUpdates = useCallback(\r\n    (imageId: string, callback: ImageUpdateCallback): (() => void) => {\r\n      if (!subscriptions.has(imageId)) {\r\n        subscriptions.set(imageId, new Set());\r\n      }\r\n      const imageSubscriptions = subscriptions.get(imageId)!;\r\n      imageSubscriptions.add(callback);\r\n\r\n      // Return unsubscribe function\r\n      return () => {\r\n        if (subscriptions.has(imageId)) {\r\n          subscriptions.get(imageId)!.delete(callback);\r\n          // Optional: Clean up Set/Map entry if no subscribers left\r\n          if (subscriptions.get(imageId)!.size === 0) {\r\n            subscriptions.delete(imageId);\r\n          }\r\n        }\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  const publishImageUpdate = useCallback((data: ProcessedImageUpdate) => {\r\n    if (subscriptions.has(data.id)) {\r\n      const imageSubscriptions = subscriptions.get(data.id)!;\r\n      // Notify all subscribers for this image ID\r\n      imageSubscriptions.forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`Error in image update callback for ID ${data.id}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  // Memoize the context value\r\n  const contextValue = useMemo(\r\n    () => ({\r\n      subscribeToImageUpdates,\r\n      publishImageUpdate,\r\n    }),\r\n    [subscribeToImageUpdates, publishImageUpdate]\r\n  );\r\n\r\n  return (\r\n    <ImageProcessingContext.Provider value={contextValue}>\r\n      {children}\r\n    </ImageProcessingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook for easy context consumption\r\nexport const useImageProcessing = (): ImageProcessingContextType => {\r\n  const context = useContext(ImageProcessingContext);\r\n  if (!context) {\r\n    throw new Error('useImageProcessing must be used within an ImageProcessingProvider');\r\n  }\r\n  return context;\r\n};\r\n","import { createImageProcessor } from '../workers/imageProcessor.js';\n\nexport interface ImageInfo {\n  id: string;\n  src: string;\n  alt: string;\n  title: string;\n  width: number;\n  height: number;\n  group?: {\n    key: string;\n    images: ImageInfo[];\n    isCarousel: boolean;\n  };\n}\n\nexport interface FolderInfo {\n  name: string;\n  path: string;\n}\n\nexport interface UploadProps {\n  selectedFolder: string;\n  onUploadComplete: () => void;\n}\n\nexport interface SearchProps {\n  onSearch: (query: string) => void;\n}\n\nexport interface ImageFeedProps {\n  images: ImageInfo[];\n  isLoading: boolean;\n}\n\nexport interface ImageRowProps {\n  images: ImageInfo[];\n  onImageClick: (image: ImageInfo, groupImages: ImageInfo[]) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  imageProcessor: ReturnType<typeof createImageProcessor>;\n}\n\nexport interface LayoutProps {\n  children: React.ReactNode;\n  folders: FolderInfo[];\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface NavbarProps {\n  currentDirectory: string;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n}\n\nexport interface GroupedImageInfo {\n  id: string;\n  title: string;\n  images: ImageInfo[];\n}\n\nexport enum ViewMode {\n  GRID = 'grid',\n  BANNER = 'banner',\n  MASONRY = 'masonry',\n  CAROUSEL = 'carousel',\n}\n\n// Interface for the data stored in IndexedDB for cached images\nexport interface ProcessedImageCacheEntry {\n  id: string;\n  lowResUrl?: string; // Blob URL for low-res\n  lowResWidth?: number;\n  lowResHeight?: number;\n  highResUrl?: string; // Blob URL for high-res\n  width?: number; // Original requested width\n  height?: number; // Original requested height\n  timestamp?: number; // When it was cached\n}\n\n// Interface for the Comlink-exposed worker API\nexport interface ImageProcessorWorkerAPI {\n  processImage(data: {\n    id: string;\n    // Accept ImageBitmap directly\n    imageBitmap: ImageBitmap;\n    width: number;\n    height: number;\n    signal?: AbortSignal;\n  }): Promise<{ lowResUrl?: string; highResUrl?: string }>; // Return URLs\n\n  processBatch(data: {\n    // Batch expects bitmaps now\n    images: Array<{ id: string; imageBitmap: ImageBitmap; width: number; height: number }>;\n    signal?: AbortSignal;\n    // Add callback for progress? Comlink supports callbacks\n    // onProgress?: (processed: { id: string; lowResUrl?: string; highResUrl?: string }) => void;\n  }): Promise<Array<{ id: string; lowResUrl?: string; highResUrl?: string }>>; // Return array of results\n}\n","import axios from 'axios';\nimport { FolderInfo, ImageInfo } from '../types/index.js';\n\nconst api = axios.create({\n  baseURL: '/api', // Assuming your API routes are under /api\n});\n\n/**\n * Fetches the list of folders from the server.\n *\n * @returns {Promise<FolderInfo[]>} A promise that resolves to an array of folder information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getFolders(): Promise<FolderInfo[]> {\n  try {\n    const response = await api.get('/folders');\n    return response.data.map((folder: { name: string; path: string }) => ({\n      name: folder.name,\n      path: folder.path,\n    }));\n  } catch (error) {\n    console.error('Error in getFolders:', error);\n    throw new Error('Failed to fetch folders');\n  }\n}\n\n/**\n * Fetches the list of images for a specific folder from the server.\n *\n * @param {string} folder - The name of the folder to fetch images from.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getImages(folder: string): Promise<ImageInfo[]> {\n  if (!folder) {\n    throw new Error('Folder parameter is required');\n  }\n\n  try {\n    const response = await api.get(`/images?folder=${encodeURIComponent(folder)}`);\n\n    if (!Array.isArray(response.data)) {\n      console.error('Invalid response data:', response.data);\n      throw new Error('Invalid response format from server');\n    }\n\n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      const message = error.response.data?.error || error.response.statusText;\n      throw new Error(`Server error: ${message}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      throw new Error('No response from server');\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.error('Error in getImages:', error);\n      throw new Error(error.message || 'Failed to fetch images');\n    }\n  }\n}\n/**\n * Uploads files to a specified folder on the server.\n *\n * @param {string} folder - The name of the folder to upload files to.\n * @param {File[]} files - An array of File objects to be uploaded.\n * @param {function} onProgress - A callback function to report upload progress.\n * @returns {Promise<void>} A promise that resolves when the upload is complete.\n * @throws Will throw an error if the API request fails.\n */\nexport async function uploadFiles(\n  folder: string,\n  files: File[],\n  onProgress: (progress: number) => void\n): Promise<void> {\n  const formData = new FormData();\n  formData.append('folder', folder);\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    await api.post('/upload', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data',\n      },\n      onUploadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(percentCompleted);\n        }\n      },\n    });\n  } catch (error) {\n    console.error('Error in uploadFiles:', error);\n    throw new Error('Failed to upload files');\n  }\n}\n/**\n * Searches for images across all folders based on a query string.\n *\n * @param {string} query - The search query string.\n * @returns {Promise<ImageInfo[]>} A promise that resolves to an array of image information matching the search query.\n * @throws Will throw an error if the API request fails.\n */\nexport async function searchImages(query: string): Promise<ImageInfo[]> {\n  try {\n    const response = await api.get(`/search?q=${encodeURIComponent(query)}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error in searchImages:', error);\n    throw new Error('Failed to search images');\n  }\n}\n\n/**\n * Fetches the current main directory from the server.\n *\n * @returns {Promise<string>} A promise that resolves to the current main directory path.\n * @throws Will throw an error if the API request fails.\n */\nexport async function getCurrentDirectory(): Promise<string> {\n  try {\n    const response = await api.get('/getCurrentDirectory');\n    return response.data.currentDirectory;\n  } catch (error) {\n    console.error('Error in getCurrentDirectory:', error);\n    throw new Error('Failed to get current directory');\n  }\n}\n","import { IconFolder } from '@tabler/icons-react';\r\nimport { motion } from 'framer-motion';\r\nimport React from 'react';\r\nimport { useCurrentDirectory } from '../hooks/query/useCurrentDirectory';\r\n\r\n/** Props for the CurrentDirectoryButton component. */\r\ninterface CurrentDirectoryButtonProps {\r\n  // currentDirectory: string; // Removed\r\n}\r\n\r\n/** CurrentDirectoryButton component that displays the current directory.*/\r\nconst CurrentDirectoryButton: React.FC<CurrentDirectoryButtonProps> = () => {\r\n  // Fetch the current directory using the hook\r\n  const { data: currentDirectory, isLoading, isError } = useCurrentDirectory();\r\n\r\n  // Determine button content based on loading/error state\r\n  let buttonContent = '...'; // Loading state\r\n  let buttonClass = 'bg-gray-600 text-gray-400 cursor-not-allowed';\r\n  let iconColor = 'text-gray-500';\r\n\r\n  if (isError) {\r\n    buttonContent = 'Error';\r\n    buttonClass = 'bg-red-800 text-red-200 cursor-not-allowed';\r\n    iconColor = 'text-red-400';\r\n  } else if (!isLoading && currentDirectory) {\r\n    buttonContent = currentDirectory;\r\n    buttonClass = 'bg-gray-700 text-peach hover:bg-gray-600'; // Original classes\r\n    iconColor = 'text-yellow-500'; // Original color\r\n  }\r\n\r\n  return (\r\n    <motion.button\r\n      className={`flex items-center px-3 py-1 rounded-md text-sm transition-all duration-300 ease-in-out ${buttonClass}`}\r\n      whileHover={!isLoading && !isError ? { scale: 1.05 } : {}}\r\n      whileTap={!isLoading && !isError ? { scale: 0.95 } : {}}\r\n      disabled={isLoading || isError}\r\n    >\r\n      {/* Folder icon */}\r\n      <IconFolder size={16} className={`mr-2 ${iconColor}`} />\r\n\r\n      {/* Current directory path or status */}\r\n      <motion.div\r\n        className=\"truncate max-w-xs\"\r\n        initial={{ opacity: 0 }}\r\n        animate={{ opacity: 1 }}\r\n        transition={{ duration: 0.3 }}\r\n      >\r\n        <span>{buttonContent}</span>\r\n      </motion.div>\r\n    </motion.button>\r\n  );\r\n};\r\n\r\nexport default CurrentDirectoryButton;\r\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentDirectory } from '../../lib/api';\r\n\r\n/**\r\n * Custom hook to fetch the current base directory from the server.\r\n *\r\n * @returns The result object from useQuery, containing the directory path string, loading state, error state, etc.\r\n */\r\nexport function useCurrentDirectory() {\r\n  return useQuery<string, Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    queryKey: ['currentDirectory'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getCurrentDirectory,\r\n    // Optional: Consider a longer staleTime as this might not change often\r\n    staleTime: 1000 * 60 * 30, // e.g., stays fresh for 30 minutes\r\n    refetchOnWindowFocus: false, // Likely doesn't need to refetch on focus\r\n  });\r\n}\r\n","import { motion, useAnimation } from 'framer-motion';\nimport { useState } from 'react';\nimport styles from '../styles/SearchBar.module.scss';\n\n// Define the props interface for the SearchBar component\ninterface SearchBarProps {\n  onSearch: (query: string) => void;\n}\n\n// Define the SearchBar component\nconst SearchBar: React.FC<SearchBarProps> = ({ onSearch }) => {\n  // State to manage the search query\n  const [query, setQuery] = useState('');\n  const controls = useAnimation();\n\n  // Handler for form submission\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSearch(query);\n  };\n\n  // Render the SearchBar component\n  return (\n    <motion.form\n      onSubmit={handleSubmit}\n      className={styles.searchBarContainer}\n      initial={{ width: '200px' }}\n      animate={{ width: query ? '300px' : '200px' }}\n      transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n    >\n      <motion.div\n        className={styles.searchBackground}\n        animate={{\n          background: query\n            ? 'linear-gradient(90deg, #4a00e0 0%, #8e2de2 100%)'\n            : 'rgba(255, 255, 255, 0.1)',\n        }}\n      />\n      <motion.input\n        type=\"text\"\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        className={styles.searchInput}\n        placeholder=\"Search the future...\"\n        whileFocus={{ scale: 1.05 }}\n        transition={{ type: 'spring', stiffness: 400, damping: 30 }}\n      />\n    </motion.form>\n  );\n};\n\n// Export the SearchBar component\nexport default SearchBar;\n","import { motion, useAnimation } from 'framer-motion';\nimport React, { useEffect, useState } from 'react';\n\n// Define the props interface for the ZoomSlider component\ninterface ZoomSliderProps {\n  zoom: number;\n  onZoomChange: (zoom: number) => void;\n}\n\n// ZoomSlider component for adjusting image zoom level\nconst ZoomSlider: React.FC<ZoomSliderProps> = ({ zoom, onZoomChange }) => {\n  const [isDragging, setIsDragging] = useState(false);\n  const controls = useAnimation();\n\n  // compute animated values manually for Framer Motion\n  const sliderWidth = `${((zoom - 0.5) / 1.5) * 100}%`;\n  const glowOpacity = isDragging ? 1 : 0.6;\n  const glowScale = isDragging ? 1.1 : 1;\n\n  useEffect(() => {\n    controls.start({\n      scale: isDragging ? 1.05 : 1,\n      transition: {\n        type: 'spring',\n        stiffness: 300,\n        damping: 20,\n      },\n    });\n  }, [isDragging, controls]);\n\n  return (\n    <motion.div\n      className=\"relative flex items-center bg-gray-800/80 backdrop-blur-md rounded-full p-3 overflow-hidden\"\n      style={{\n        boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n        width: '200px',\n      }}\n      animate={controls}\n    >\n      {/* Zoom out icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.max(0.5, zoom - 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 mr-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: -90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M11 8V14M8 11H14M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n\n      {/* Slider track */}\n      <div className=\"relative flex-1 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <motion.div\n          className=\"absolute top-0 left-0 h-full bg-blue-500 rounded-full\"\n          style={{ boxShadow: '0 0 10px rgba(59,130,246,0.5)' }}\n          animate={{ width: sliderWidth }}\n          transition={{ type: 'spring', stiffness: 300, damping: 10, precision: 0.01 }}\n        />\n        <input\n          type=\"range\"\n          min=\"0.5\"\n          max=\"2\"\n          step=\"0.1\"\n          value={zoom}\n          onChange={e => onZoomChange(parseFloat(e.target.value))}\n          onMouseDown={() => setIsDragging(true)}\n          onMouseUp={() => setIsDragging(false)}\n          onTouchStart={() => setIsDragging(true)}\n          onTouchEnd={() => setIsDragging(false)}\n          className=\"absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer\"\n        />\n      </div>\n\n      {/* Zoom in icon */}\n      <motion.div\n        className=\"relative\"\n        whileHover={{ scale: 1.2 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={() => onZoomChange(Math.min(2, zoom + 0.1))}\n      >\n        <motion.svg\n          className=\"text-gray-200 ml-3 cursor-pointer\"\n          width=\"20\"\n          height=\"20\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          whileHover={{ rotate: 90 }}\n          transition={{ duration: 0.3 }}\n        >\n          <path\n            d=\"M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        </motion.svg>\n        <motion.div\n          style={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            width: '30px',\n            height: '30px',\n            background: 'radial-gradient(circle, rgba(59,130,246,0.2) 0%, rgba(59,130,246,0) 70%)',\n            transform: 'translate(-50%, -50%)',\n            pointerEvents: 'none',\n          }}\n          animate={{ opacity: glowOpacity, scale: glowScale }}\n          transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n        />\n      </motion.div>\n    </motion.div>\n  );\n};\n\n// Export the ZoomSlider component\nexport default ZoomSlider;\n","import { motion } from 'framer-motion';\nimport { forwardRef, useEffect, useRef } from 'react';\nimport styles from '../styles/Navbar.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport CurrentDirectoryButton from './CurrentDirectoryButton';\nimport SearchBar from './SearchBar';\nimport ZoomSlider from './ZoomSlider';\n\n// Update the props interface for the Navbar component\ninterface NavbarProps {\n  // currentDirectory: string; // Removed: Fetched by CurrentDirectoryButton\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n}\n\n// Use forwardRef to allow passing ref to the underlying motion.div\nconst Navbar = forwardRef<HTMLDivElement, NavbarProps>(\n  (\n    {\n      // currentDirectory, // Removed\n      onSearch,\n      zoom,\n      onZoomChange,\n      isGrouped,\n      onGroupToggle,\n      viewMode,\n      onViewModeChange,\n    },\n    ref // Receive the ref\n  ) => {\n    const svgRef = useRef<SVGSVGElement>(null);\n\n    useEffect(() => {\n      const svg = svgRef.current;\n      if (svg) {\n        const animate = () => {\n          const path = svg.querySelector('path');\n          if (path) {\n            const length = path.getTotalLength();\n            path.style.strokeDasharray = `${length} ${length}`;\n            path.style.strokeDashoffset = `${length}`;\n            path.getBoundingClientRect();\n            path.style.transition = 'stroke-dashoffset 2s ease-in-out';\n            path.style.strokeDashoffset = '0';\n          }\n        };\n        animate();\n      }\n    }, []);\n\n    // Render the Navbar component\n    return (\n      <motion.div\n        ref={ref} // Apply the forwarded ref here\n        className={styles.navbar}\n        initial={{ opacity: 0, y: -50 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ duration: 0.5 }}\n      >\n        <svg ref={svgRef} className={styles.navbarBackground}>\n          <path d=\"M0,0 Q50,20 100,10 T200,30 T300,5 T400,25 V100 Q350,80 300,90 T200,70 T100,95 T0,75 Z\" />\n        </svg>\n        {/* Left section of the navbar */}\n        <div className={styles.leftSection}>\n          {/* Display the current directory */}\n          <CurrentDirectoryButton /> {/* No prop needed */}\n          {/* Search functionality */}\n          <SearchBar onSearch={onSearch} />\n        </div>\n        {/* Right section of the navbar */}\n        <div className={styles.rightSection}>\n          {/* View mode toggle buttons */}\n          <div className={styles.viewModeButtons}>\n            {Object.values(ViewMode).map(mode => (\n              <motion.button\n                key={mode}\n                onClick={() => onViewModeChange(mode)}\n                className={`${styles.viewModeButton} ${viewMode === mode ? styles.active : ''}`}\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n              >\n                {mode.charAt(0).toUpperCase() + mode.slice(1)}\n              </motion.button>\n            ))}\n          </div>\n          <motion.button\n            onClick={onGroupToggle}\n            className={styles.viewToggleButton}\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n          >\n            {isGrouped ? 'Ungroup' : 'Group'}\n          </motion.button>\n          {/* Zoom control slider */}\n          <ZoomSlider zoom={zoom} onZoomChange={onZoomChange} />\n        </div>\n      </motion.div>\n    );\n  }\n);\n\nNavbar.displayName = 'Navbar'; // Add display name for DevTools\n\n// Export the Navbar component\nexport default Navbar;\n","const HOME_DIRECTORY_KEY = 'loraFinderHomeDirectory';\r\n\r\n/**\r\n * Retrieves the stored home directory path from localStorage.\r\n * @returns The stored path string, or null if not set.\r\n */\r\nexport const getHomeDirectory = (): string | null => {\r\n  try {\r\n    return localStorage.getItem(HOME_DIRECTORY_KEY);\r\n  } catch (error) {\r\n    console.error('Error reading home directory from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores the given directory path as the home directory in localStorage.\r\n * @param folderPath - The path to store.\r\n */\r\nexport const setHomeDirectory = (folderPath: string): void => {\r\n  try {\r\n    localStorage.setItem(HOME_DIRECTORY_KEY, folderPath);\r\n  } catch (error) {\r\n    console.error('Error setting home directory in localStorage:', error);\r\n  }\r\n};\r\n","import { motion } from 'framer-motion';\nimport React, { forwardRef, useEffect, useState } from 'react';\nimport { FaHome } from 'react-icons/fa';\nimport { useFolders } from '../hooks/query/useFolders';\nimport styles from '../styles/Sidebar.module.scss';\nimport { getHomeDirectory, setHomeDirectory } from '../utils/settings';\n\n// Define the props interface for the Sidebar component\ninterface SidebarProps {\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n}\n\n// Use forwardRef to allow passing ref to the underlying motion.div\nconst Sidebar = forwardRef<HTMLDivElement, SidebarProps>(\n  (\n    { selectedFolder, onFolderChange },\n    ref // Receive the ref\n  ) => {\n    // Call the hook to fetch folders\n    const { data: folders, isLoading, isError, error } = useFolders();\n    // State to track the current home directory for styling\n    const [currentHomeDir, setCurrentHomeDir] = useState<string | null>(null);\n\n    // Effect to load the home directory on mount\n    useEffect(() => {\n      setCurrentHomeDir(getHomeDirectory());\n    }, []);\n\n    // Handler to set a new home directory\n    const handleSetHome = (folderPath: string, event: React.MouseEvent) => {\n      event.stopPropagation(); // Prevent folder selection when clicking set home\n      setHomeDirectory(folderPath);\n      setCurrentHomeDir(folderPath);\n      console.log('Set home directory:', folderPath);\n    };\n\n    // Render loading state\n    if (isLoading) {\n      return (\n        <motion.div\n          ref={ref} // Apply the ref here\n          initial={{ x: -300 }}\n          animate={{ x: 0 }}\n          transition={{ type: 'spring', stiffness: 120 }}\n          className={`${styles.sidebar} ${styles.loading}`}\n        >\n          Loading folders...\n        </motion.div>\n      );\n    }\n\n    // Render error state\n    if (isError) {\n      return (\n        <motion.div\n          ref={ref} // Apply the ref here\n          initial={{ x: -300 }}\n          animate={{ x: 0 }}\n          transition={{ type: 'spring', stiffness: 120 }}\n          className={`${styles.sidebar} ${styles.error}`}\n        >\n          Error: {error?.message || 'Failed to load folders'}\n        </motion.div>\n      );\n    }\n\n    // Render the main sidebar\n    return (\n      // Main sidebar container\n      <motion.div\n        ref={ref} // Apply the ref here\n        initial={{ x: -300 }}\n        animate={{ x: 0 }}\n        transition={{ type: 'spring', stiffness: 120 }}\n        className={styles.sidebar}\n      >\n        <div className={`${styles.sidebarInner} flex flex-col h-full`}>\n          {/* Logo section */}\n          <div className={styles.logo}>Lora Finder</div>\n          {/* Folder list */}\n          <ul className={`${styles.folderList} flex-grow overflow-y-auto`}>\n            {/* Map through folders (from hook) and create buttons for each */}\n            {(folders ?? []).map(folder => (\n              <li key={folder.name} className={`${styles.folderItem} group`}>\n                <button\n                  onClick={() => {\n                    onFolderChange(folder.name);\n                  }}\n                  className={`${styles.folderButton} ${\n                    selectedFolder === folder.name ? styles.selectedFolder : ''\n                  }`}\n                >\n                  <span className={styles.folderName}>{folder.name}</span>\n                  <button\n                    onClick={e => handleSetHome(folder.name, e)}\n                    className={`${styles.setHomeButton} ${\n                      folder.name === currentHomeDir\n                        ? styles.isHome\n                        : 'opacity-0 group-hover:opacity-100'\n                    }`}\n                    title={`Set ${folder.name} as home directory`}\n                  >\n                    <FaHome />\n                  </button>\n                </button>\n              </li>\n            ))}\n          </ul>\n          {/* Upload button */}\n          <div className=\"p-8 mt-auto\">\n            <button className={`${styles.uploadButton} w-full`}>Upload</button>\n          </div>\n        </div>\n      </motion.div>\n    );\n  }\n);\n\nSidebar.displayName = 'Sidebar'; // Add display name for DevTools\n\n// Export the Sidebar component\nexport default Sidebar;\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getFolders } from '../../lib/api';\r\nimport { FolderInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch the list of available folders using React Query.\r\n *\r\n * @returns The result object from useQuery, containing folder data, loading state, error state, etc.\r\n */\r\nexport function useFolders() {\r\n  return useQuery<FolderInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Stays constant as we expect the same folder list unless invalidated.\r\n    queryKey: ['folders'],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: getFolders,\r\n    // Optional: Configure staleTime and gcTime if different from defaults\r\n    // staleTime: 1000 * 60 * 10, // e.g., folders stay fresh for 10 mins\r\n  });\r\n}\r\n","// Cache Time-To-Live: Duration in milliseconds for which cached data remains valid\nexport const CACHE_TTL = 600000;\n\n// Maximum upload size: Limit for file uploads in bytes (default is ~1.5GB)\nexport const MAX_UPLOAD_SIZE = 1610612736;\n\n// Supported image formats: List of file extensions for allowed image uploads\nexport const SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif'];\n\n// API base URL: Root URL for API endpoints\nexport const API_BASE_URL = 'http://localhost:3000/api';\n\n// Server port: Port number on which the server will listen\nexport const PORT = 3000;\n\n// Host: Hostname or IP address on which the server will run\nexport const HOST = 'localhost';\n\n// Custom properties for dynamic styling\nexport const CUSTOM_PROPERTIES = {\n  SCROLL_Y: '--scroll-y',\n  MOUSE_X: '--mouse-x',\n  MOUSE_Y: '--mouse-y',\n};\n\n// Default values for custom properties\nexport const DEFAULT_CUSTOM_PROPERTY_VALUES = {\n  [CUSTOM_PROPERTIES.SCROLL_Y]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_X]: '0px',\n  [CUSTOM_PROPERTIES.MOUSE_Y]: '0px',\n};\n","import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { ColorContext } from '../contexts/ColorContext'; // Import ColorContext\nimport styles from '../styles/ParticleBackground.module.scss'; // Reuse or create new styles\n\n// Convert hex color string to vec3 [r, g, b] (normalized 0-1)\nconst hexToVec3 = (hex: string): [number, number, number] => {\n  let r = 0,\n    g = 0,\n    b = 0;\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(hex[1] + hex[1], 16);\n    g = parseInt(hex[2] + hex[2], 16);\n    b = parseInt(hex[3] + hex[3], 16);\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(hex[1] + hex[2], 16);\n    g = parseInt(hex[3] + hex[4], 16);\n    b = parseInt(hex[5] + hex[6], 16);\n  }\n  return [r / 255, g / 255, b / 255];\n};\n\n// Linear interpolation function for arrays (like colors)\nconst lerpArray = (start: number[], end: number[], t: number): number[] => {\n  return start.map((val, i) => val + (end[i] - val) * t);\n};\n\n// Linear interpolation for single values\nconst lerp = (start: number, end: number, t: number): number => {\n  return start + (end - start) * t;\n};\n\n// --- WebGL Shaders (Refined for Aura Effect) ---\n\n// Vertex Shader (Remains the same - simple quad pass-through)\nconst vertexShaderSource = `\n  precision mediump float;\n  attribute vec2 a_position; // Vertex position (-1 to 1)\n  varying vec2 v_uv;         // Pass UV coordinates (0 to 1) to fragment shader\n\n  void main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_uv = (a_position + 1.0) * 0.5; // Convert clip space to UV space\n    v_uv.y = 1.0 - v_uv.y; // Flip Y for texture/canvas coordinate system\n  }\n`;\n\n// Fragment Shader: Updated with noise functions for a more organic background\nconst fragmentShaderSource = `\n  precision mediump float;\n  varying vec2 v_uv; // UV coordinates from vertex shader\n\n  uniform vec2 u_resolution;    // Canvas resolution\n  uniform float u_time;        // Time for animations\n  uniform vec3 u_colorTarget1;  // Base color 1\n  uniform vec3 u_colorTarget2;  // Base color 2\n  uniform float u_colorMixFactor; // Mix factor for base colors\n\n  // Hover state uniforms\n  uniform bool u_isHovering;\n  uniform vec2 u_hoverPos;      // Normalized hover position (0-1)\n  uniform vec3 u_hoverColor;    // Optional: Color associated with hover\n\n  // --- Noise Functions ---\n  // Simple pseudo-random number generator\n  float random (vec2 st) {\n      // Adjusted seed based on example, can be tweaked\n      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n  }\n\n  // Basic Value Noise function\n  float noise (vec2 st) {\n      vec2 i = floor(st); // Integer part\n      vec2 f = fract(st); // Fractional part\n\n      // Get random values for the 4 corners surrounding the point\n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n\n      // Smoothly interpolate between the corner values (smoothstep)\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      // Interpolate horizontally, then vertically\n      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n  }\n\n  // Fractional Brownian Motion (fBm) - layering noise\n  #define OCTAVES 4 // Number of noise layers (adjust for detail/performance)\n  float fbm (vec2 st) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 0.0;\n      // Loop through octaves, adding noise at different frequencies/amplitudes\n      for (int i = 0; i < OCTAVES; i++) {\n          value += amplitude * noise(st);\n          st *= 2.0; // Double frequency for next octave\n          amplitude *= 0.5; // Halve amplitude for next octave\n      }\n      return value;\n  }\n  // --- End Noise Functions ---\n\n  // Function to calculate distance from hover point (same as before)\n  float getHoverDist(vec2 pos) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    vec2 diff = pos - u_hoverPos;\n    diff.x *= aspectRatio;\n    return distance(vec2(0.0), diff);\n  }\n\n  void main() {\n    // --- Calculate Base Aura Color using Noise ---\n    // Scale UV and add time for animation. Adjust scale (e.g., * 3.0) for noise detail.\n    vec2 noisyCoord = v_uv * 2.5 + vec2(u_time * 0.02, u_time * 0.03); // Slow movement\n    float noisePattern = fbm(noisyCoord);\n\n    // Base color blend - mix between target colors\n    vec3 baseColor = mix(u_colorTarget1, u_colorTarget2, u_colorMixFactor);\n\n    // Modulate the base color blend using the noise pattern\n    // Mix based on noise value AND vertical position for variety\n    vec3 auraColor = mix(baseColor, mix(u_colorTarget1, u_colorTarget2, v_uv.y * 0.8 + 0.1), noisePattern * 0.6);\n    // Add subtle contrast/brightness variation based on noise\n    auraColor *= (0.9 + noisePattern * 0.2);\n\n    // --- Hover Effect (Applied on top of aura) ---\n    vec3 finalColor = auraColor;\n    if (u_isHovering) {\n      float dist = getHoverDist(v_uv);\n      // Ripple/glow effect - use smoothstep for soft edges\n      float hoverIntensity = smoothstep(0.20, 0.0, dist); // Increased radius slightly\n\n      // Make the glow slightly colored (e.g., whitish or based on u_hoverColor if available)\n      vec3 glowColor = vec3(0.8, 0.8, 0.9); // Whitish glow\n      // Optionally use u_hoverColor: mix(glowColor, u_hoverColor, 0.5)\n\n      // Additive blend for glow, stronger near center\n      finalColor += glowColor * hoverIntensity * 0.6; // Adjust intensity multiplier\n\n      // Optional: Slight displacement/warp effect (more complex)\n      // vec2 displacement = normalize(v_uv - u_hoverPos) * hoverIntensity * 0.01;\n      // Recalculate noise/color at v_uv - displacement ? (performance cost)\n    }\n\n    // Ensure color values stay within valid range\n    gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n  }\n`;\n\n// --- Component ---\nconst AuraBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const bufferRef = useRef<WebGLBuffer | null>(null); // Single buffer for a quad\n  const attribLocationsRef = useRef<{ [key: string]: number }>({});\n  const uniformLocationsRef = useRef<{ [key: string]: WebGLUniformLocation | null }>({});\n  const animationFrameRef = useRef<number>();\n  const { dominantColors, hoverState } = useContext(ColorContext);\n\n  // Refs for animated uniform values (colors and hover state)\n  const animatedColor1 = useRef(hexToVec3(dominantColors[0] || '#041024'));\n  const animatedColor2 = useRef(hexToVec3(dominantColors[1] || dominantColors[0] || '#041024'));\n  const animatedMixFactor = useRef(dominantColors.length > 1 ? 1.0 : 0.0);\n  const animatedHoverPos = useRef<[number, number] | null>(\n    hoverState.position ? [hoverState.position.x, hoverState.position.y] : null\n  );\n  const animatedIsHovering = useRef(hoverState.isHovering ? 1.0 : 0.0); // Use float for smooth transition\n\n  // --- WebGL Helper Functions ---\n  const createShader = useCallback(\n    (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\n          `Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`,\n          gl.getShaderInfoLog(shader)\n        );\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    },\n    []\n  );\n\n  const createProgram = useCallback(\n    (\n      gl: WebGLRenderingContext,\n      vertexShader: WebGLShader,\n      fragmentShader: WebGLShader\n    ): WebGLProgram | null => {\n      const program = gl.createProgram();\n      if (!program) return null;\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program link error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return null;\n      }\n      return program;\n    },\n    []\n  );\n\n  // --- Animation Loop ---\n  const renderLoop = useCallback(\n    (time: number) => {\n      const gl = glRef.current;\n      const program = programRef.current;\n      if (!gl || !program) {\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\n        return;\n      }\n      const timeSeconds = time / 1000.0;\n\n      // --- Smooth Animation Logic (Lerping) ---\n      const lerpSpeed = 0.08; // Adjust for desired transition speed\n\n      // Animate Colors\n      const targetColor1 = hexToVec3(dominantColors[0] || '#041024');\n      const targetColor2 = hexToVec3(dominantColors[1] || dominantColors[0] || '#041024');\n      const targetMix = dominantColors.length > 1 ? 1.0 : 0.0;\n      animatedColor1.current = lerpArray(animatedColor1.current, targetColor1, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedColor2.current = lerpArray(animatedColor2.current, targetColor2, lerpSpeed) as [\n        number,\n        number,\n        number,\n      ];\n      animatedMixFactor.current = lerp(animatedMixFactor.current, targetMix, lerpSpeed);\n\n      // Animate Hover State\n      const targetIsHovering = hoverState.isHovering ? 1.0 : 0.0;\n      animatedIsHovering.current = lerp(\n        animatedIsHovering.current,\n        targetIsHovering,\n        lerpSpeed * 2\n      ); // Faster hover transition\n\n      if (hoverState.isHovering && hoverState.position) {\n        const targetPos: [number, number] = [hoverState.position.x, hoverState.position.y];\n        if (!animatedHoverPos.current) {\n          animatedHoverPos.current = targetPos; // Snap if starting from null\n        } else {\n          animatedHoverPos.current = lerpArray(\n            animatedHoverPos.current,\n            targetPos,\n            lerpSpeed * 2\n          ) as [number, number];\n        }\n      } else {\n        // Optionally, let the hover position fade out or just keep the last known position\n        // For now, we'll just use the latest position when hovering is true\n      }\n\n      // --- WebGL Rendering ---\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      // No need to clear if drawing a full-screen quad that covers everything\n      // gl.clearColor(0, 0, 0, 0);\n      // gl.clear(gl.COLOR_BUFFER_BIT);\n\n      // Log context state and calculated animation values\n      // console.log('[AuraBackground Loop] Context HoverState:', hoverState);\n      // console.log('[AuraBackground Loop] Animated Hover:', { isHovering: animatedIsHovering.current, pos: animatedHoverPos.current });\n\n      gl.useProgram(program);\n\n      // Bind the quad buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n      const posLocation = attribLocationsRef.current.position;\n      if (posLocation !== -1) {\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(posLocation);\n      }\n\n      // Set Uniforms\n      gl.uniform2f(uniformLocationsRef.current.resolution, gl.canvas.width, gl.canvas.height);\n      gl.uniform1f(uniformLocationsRef.current.time, timeSeconds);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget1, animatedColor1.current);\n      gl.uniform3fv(uniformLocationsRef.current.colorTarget2, animatedColor2.current);\n      gl.uniform1f(uniformLocationsRef.current.colorMixFactor, animatedMixFactor.current);\n\n      // Hover Uniforms\n      gl.uniform1f(\n        uniformLocationsRef.current.isHovering,\n        animatedIsHovering.current > 0.01 ? 1.0 : 0.0\n      ); // Use threshold for bool\n      if (animatedHoverPos.current) {\n        gl.uniform2fv(uniformLocationsRef.current.hoverPos, animatedHoverPos.current);\n      }\n      // gl.uniform3fv(uniformLocationsRef.current.hoverColor, hoverState.color ? hexToVec3(hoverState.color) : [0,0,0]); // TODO: Add hover color logic\n\n      // Draw the quad (2 triangles)\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      animationFrameRef.current = requestAnimationFrame(renderLoop);\n    },\n    [dominantColors, hoverState]\n  ); // Dependencies for lerp targets\n\n  // --- Initialization Effect ---\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    if (!canvasElement) return;\n\n    const gl = canvasElement.getContext('webgl', { alpha: false, antialias: true }); // alpha: false maybe faster? antialias: true for smoother gradients\n    if (!gl) {\n      console.error('WebGL not supported or context creation failed.');\n      return;\n    }\n    glRef.current = gl;\n\n    // Compile shaders\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!vertexShader || !fragmentShader) return;\n\n    // Link program\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    if (!program) return;\n    programRef.current = program;\n\n    // Detach and delete shaders after linking\n    gl.detachShader(program, vertexShader);\n    gl.detachShader(program, fragmentShader);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    // --- Create Buffer for Fullscreen Quad ---\n    // Vertices for two triangles covering the screen (-1 to 1)\n    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n    bufferRef.current = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, bufferRef.current);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    // --- Look up locations ---\n    attribLocationsRef.current.position = gl.getAttribLocation(program, 'a_position');\n    uniformLocationsRef.current.resolution = gl.getUniformLocation(program, 'u_resolution');\n    uniformLocationsRef.current.time = gl.getUniformLocation(program, 'u_time');\n    uniformLocationsRef.current.colorTarget1 = gl.getUniformLocation(program, 'u_colorTarget1');\n    uniformLocationsRef.current.colorTarget2 = gl.getUniformLocation(program, 'u_colorTarget2');\n    uniformLocationsRef.current.colorMixFactor = gl.getUniformLocation(program, 'u_colorMixFactor');\n    uniformLocationsRef.current.isHovering = gl.getUniformLocation(program, 'u_isHovering');\n    uniformLocationsRef.current.hoverPos = gl.getUniformLocation(program, 'u_hoverPos');\n    uniformLocationsRef.current.hoverColor = gl.getUniformLocation(program, 'u_hoverColor');\n\n    // --- Resize Handling ---\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!entries || entries.length === 0) return;\n      const { width, height } = entries[0].contentRect;\n      if (glRef.current) {\n        glRef.current.canvas.width = width;\n        glRef.current.canvas.height = height;\n      }\n    });\n    resizeObserver.observe(canvasElement);\n\n    // Start render loop\n    animationFrameRef.current = requestAnimationFrame(renderLoop);\n\n    // --- Cleanup ---\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      resizeObserver.disconnect();\n\n      const currentGl = glRef.current;\n      if (currentGl) {\n        if (bufferRef.current) currentGl.deleteBuffer(bufferRef.current);\n        if (programRef.current) currentGl.deleteProgram(programRef.current);\n      }\n      glRef.current = null;\n      programRef.current = null;\n      bufferRef.current = null;\n    };\n    // Add renderLoop to dependencies if its definition relies on changing props/state from outside\n  }, [createShader, createProgram, renderLoop]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={styles.particleBackground} // Reuse style or create AuraBackground.module.scss\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        pointerEvents: 'none',\n        zIndex: -1, // Keep behind content\n        // backgroundColor: '#041024', // Optional fallback bg\n      }}\n    />\n  );\n};\n\nexport default React.memo(AuraBackground);\n","import React, { forwardRef } from 'react';\nimport { ViewMode } from '../types/index.js';\nimport Navbar from './Navbar.js';\nimport Sidebar from './Sidebar.js';\n// import { getImages } from '../lib/api.js'; // Removed: Data fetching moved to hooks/ImageFeed\nimport gsap from 'gsap';\nimport { ScrollToPlugin } from 'gsap/ScrollToPlugin';\nimport { ColorProvider } from '../contexts/ColorContext';\nimport { useCustomProperties } from '../hooks/useCustomProperties';\n// Import the new AuraBackground\nimport AuraBackground from './AuraBackground.js';\n// Remove ParticleBackground import\n// import ParticleBackground from './ParticleBackground.js';\n\ngsap.registerPlugin(ScrollToPlugin);\n\n// Define the props interface for the Layout component\ninterface LayoutProps {\n  children: React.ReactNode;\n  selectedFolder: string;\n  onFolderChange: (folder: string) => void;\n  onSearch: (query: string) => void;\n  zoom: number;\n  onZoomChange: (newZoom: number) => void;\n  isGrouped: boolean;\n  onGroupToggle: () => void;\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n  mainRef: React.RefObject<HTMLElement>;\n  navbarRef?: React.Ref<HTMLDivElement>;\n  sidebarRef?: React.Ref<HTMLDivElement>;\n  contentAreaRef?: React.Ref<HTMLDivElement>;\n}\n\n// Define the Layout component\nconst Layout = forwardRef<HTMLDivElement, LayoutProps>(\n  (\n    {\n      children,\n      selectedFolder,\n      onFolderChange,\n      onSearch,\n      zoom,\n      onZoomChange,\n      isGrouped,\n      onGroupToggle,\n      viewMode,\n      onViewModeChange,\n      mainRef,\n      navbarRef,\n      sidebarRef,\n      contentAreaRef,\n    },\n    ref\n  ) => {\n    useCustomProperties();\n\n    // State variables for managing images, loading state, error, and search query\n    // const [images, setImages] = useState<ImageInfo[]>([]); // Removed: Managed by react-query in ImageFeed\n    // const [isLoading, setIsLoading] = useState(false); // Removed\n    // const [error, setError] = useState<string | null>(null); // Removed\n    // const [searchQuery, setSearchQuery] = useState(''); // Kept for now, search logic needs update\n\n    // Effect hook to fetch images when the selected folder changes\n    // useEffect(() => {\n    //   const fetchImages = async () => {\n    //     setIsLoading(true);\n    //     setError(null);\n    //     try {\n    //       const fetchedImages = await getImages(selectedFolder);\n    //       setImages(fetchedImages || []); // Ensure we always set an array\n    //     } catch (err: any) {\n    //       const errorMessage = err.message || 'Failed to fetch images';\n    //       setError(errorMessage);\n    //       setImages([]); // Set empty array on error\n    //       console.error('Error fetching images:', err);\n    //     } finally {\n    //       setIsLoading(false);\n    //     }\n    //   };\n\n    //   if (selectedFolder) {\n    //     fetchImages();\n    //   } else {\n    //     setImages([]);\n    //     setError('No folder selected');\n    //   }\n    // }, [selectedFolder]); // Removed: Data fetching moved to hooks/ImageFeed\n\n    // Handler for search functionality\n    const handleSearch = (query: string) => {\n      // setSearchQuery(query);\n      onSearch(query); // Propagate search up if needed\n    };\n\n    // Handler for when image upload is complete\n    // const handleUploadComplete = () => {\n    //   // Refetch images after upload\n    //   // This logic needs to be replaced with query invalidation\n    //   // e.g., using queryClient.invalidateQueries(['images', selectedFolder]);\n    //   const fetchImages = async () => {\n    //     setIsLoading(true);\n    //     setError(null);\n    //     try {\n    //       const fetchedImages = await getImages(selectedFolder);\n    //       setImages(fetchedImages);\n    //     } catch (err) {\n    //       setError('Failed to fetch images');\n    //       console.error(err);\n    //     } finally {\n    //       setIsLoading(false);\n    //     }\n    //   };\n\n    //   fetchImages();\n    // }; // Removed: Needs replacement with react-query invalidation\n\n    // Render the layout structure\n    return (\n      <div ref={ref} className=\"flex flex-col h-screen relative bg-transparent\">\n        <ColorProvider>\n          <div className=\"gradient-overlay\"></div>\n          {/* Use AuraBackground instead of ParticleBackground */}\n          <AuraBackground />\n          {/* <ParticleBackground /> */}\n          <Navbar\n            ref={navbarRef}\n            onSearch={handleSearch}\n            zoom={zoom}\n            onZoomChange={onZoomChange}\n            isGrouped={isGrouped}\n            onGroupToggle={onGroupToggle}\n            viewMode={viewMode}\n            onViewModeChange={onViewModeChange}\n          />\n          <div className=\"flex flex-1 overflow-hidden\">\n            <Sidebar\n              ref={sidebarRef}\n              selectedFolder={selectedFolder}\n              onFolderChange={onFolderChange}\n            />\n            <main ref={mainRef} className=\"flex-1 overflow-auto p-4 relative bg-transparent\">\n              {contentAreaRef ? (\n                <div ref={contentAreaRef} className=\"relative z-10\">\n                  {children}\n                </div>\n              ) : (\n                <div className=\"relative z-10\">{children}</div>\n              )}\n            </main>\n          </div>\n        </ColorProvider>\n      </div>\n    );\n  }\n);\n\nLayout.displayName = 'Layout';\n\nexport default Layout;\n","import { useEffect } from 'react';\nimport { CUSTOM_PROPERTIES, DEFAULT_CUSTOM_PROPERTY_VALUES } from '../utils/constants';\n\nexport function useCustomProperties() {\n  useEffect(() => {\n    function updateCustomProperties(e: MouseEvent) {\n      const mouseX = e.clientX;\n      const mouseY = e.clientY;\n\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_X, `${mouseX}px`);\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.MOUSE_Y, `${mouseY}px`);\n    }\n\n    function updateScrollProperty() {\n      const scrollY = window.scrollY;\n      document.documentElement.style.setProperty(CUSTOM_PROPERTIES.SCROLL_Y, `${scrollY}px`);\n    }\n\n    // Set default values\n    Object.entries(DEFAULT_CUSTOM_PROPERTY_VALUES).forEach(([property, value]) => {\n      document.documentElement.style.setProperty(property, value);\n    });\n\n    window.addEventListener('scroll', updateScrollProperty);\n    document.addEventListener('mousemove', updateCustomProperties);\n    document.addEventListener('click', updateCustomProperties);\n\n    return () => {\n      window.removeEventListener('scroll', updateScrollProperty);\n      document.removeEventListener('mousemove', updateCustomProperties);\n      document.removeEventListener('click', updateCustomProperties);\n    };\n  }, []);\n}\n","import { useQuery } from '@tanstack/react-query';\r\nimport { getImages } from '../../lib/api';\r\nimport { ImageInfo } from '../../types';\r\n\r\n/**\r\n * Custom hook to fetch images for a specific folder using React Query.\r\n *\r\n * @param {string} folder - The name of the folder to fetch images from.\r\n * @returns The result object from useQuery, containing image data, loading state, error state, etc.\r\n */\r\nexport function useFolderImages(folder: string) {\r\n  return useQuery<ImageInfo[], Error>({\r\n    // Query key: uniquely identifies this query data.\r\n    // Includes the folder name so data is cached per folder.\r\n    queryKey: ['images', folder],\r\n    // Query function: the async function that fetches the data.\r\n    queryFn: () => getImages(folder),\r\n    // Enabled option: prevents the query from running if the folder is falsy (e.g., empty string, null, undefined).\r\n    enabled: !!folder,\r\n    // Use placeholderData to keep displaying the previous data while the new data is loading.\r\n    placeholderData: previousData => previousData,\r\n  });\r\n}\r\n","import * as Comlink from 'comlink'; // Import Comlink namespace for releaseProxy\nimport { Remote, wrap } from 'comlink'; // Import wrap, Remote, and releaseProxy\nimport { IDBPDatabase, openDB } from 'idb';\nimport PQueue from 'p-queue'; // Import p-queue\nimport { ImageInfo, ImageProcessorWorkerAPI, ProcessedImageCacheEntry } from '../types/index.js'; // Import the API type\n// Import the context update type\nimport { ProcessedImageUpdate } from '../contexts/ImageProcessingContext';\n\n// Remove the message interface - no longer needed\n// interface ImageProcessorMessage { ... }\n\nconst DB_NAME = 'image-processor-cache';\nconst STORE_NAME = 'processed-images';\nconst DB_VERSION = 1;\n\ninterface ImageProcessorOptions {\n  onImageProcessed?: (\n    id: string,\n    quality: 'low' | 'high',\n    imageUrl: string,\n    width: number,\n    height: number\n  ) => void;\n  onError?: (id: string, error: string) => void;\n  concurrency?: number; // Allow overriding concurrency\n}\n\n// --- Cache Management ---\nlet dbPromise: Promise<IDBPDatabase> | null = null;\n\nconst getDb = (): Promise<IDBPDatabase> => {\n  if (!dbPromise) {\n    dbPromise = openDB(DB_NAME, DB_VERSION, {\n      upgrade(db) {\n        if (!db.objectStoreNames.contains(STORE_NAME)) {\n          db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n        }\n      },\n    });\n  }\n  return dbPromise;\n};\n\nclass ImageProcessor {\n  private worker: Worker;\n  private proxy: Remote<ImageProcessorWorkerAPI>; // Store the Comlink proxy\n  private queue: PQueue; // Add queue instance\n  private onError?: (id: string, error: string) => void;\n  // Store AbortControllers for active requests\n  private activeRequests = new Map<string, AbortController>();\n  // Add property to hold the publisher function\n  private publisher: ((data: ProcessedImageUpdate) => void) | null = null;\n\n  constructor(options?: ImageProcessorOptions) {\n    this.onError = options?.onError;\n\n    // Initialize the queue\n    const concurrency =\n      options?.concurrency ?? Math.max(1, (navigator.hardwareConcurrency || 4) - 1);\n    this.queue = new PQueue({ concurrency });\n    console.log(`ImageProcessor: Initialized queue with concurrency ${concurrency}`);\n\n    // Initialize the worker and wrap it with Comlink\n    this.worker = new Worker(new URL('./imageProcessorWorker.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n    this.proxy = wrap<ImageProcessorWorkerAPI>(this.worker);\n\n    // Remove the onmessage handler - results come via promise\n    // this.worker.onmessage = (event: MessageEvent<ImageProcessorMessage>) => {\n    //   this.handleWorkerMessage(event);\n    // };\n\n    this.worker.onerror = error => {\n      console.error('Unhandled error in ImageProcessorWorker:', error);\n      // This usually indicates a setup or non-recoverable worker error\n      // Consider notifying the UI about a general failure\n      this.onError?.('WORKER_FATAL', error.message || 'Worker failed');\n    };\n\n    this.initializeCacheCheck();\n  }\n\n  private async initializeCacheCheck() {\n    try {\n      await this.checkCacheForStaleBlobs();\n    } catch (error) {\n      console.error('Failed initial cache check:', error);\n    }\n  }\n\n  // Method to set the publisher function after initialization\n  public setPublisher(publisher: (data: ProcessedImageUpdate) => void) {\n    console.log('[ImageProcessor] Publisher function set.');\n    this.publisher = publisher;\n  }\n\n  // --- Cache Management Methods ---\n  private async getCacheEntry(id: string): Promise<ProcessedImageCacheEntry | undefined> {\n    const db = await getDb();\n    return db.get(STORE_NAME, id);\n  }\n\n  private async setCacheEntry(entry: ProcessedImageCacheEntry): Promise<void> {\n    const db = await getDb();\n    await db.put(STORE_NAME, entry);\n  }\n\n  private async deleteCacheEntry(id: string): Promise<void> {\n    const db = await getDb();\n    await db.delete(STORE_NAME, id);\n  }\n\n  private async checkCacheForStaleBlobs() {\n    console.log('ImageProcessor: Checking cache for stale blob URLs...');\n    const db = await getDb();\n    const allEntries = await db.getAll(STORE_NAME);\n    let staleCount = 0;\n\n    for (const entry of allEntries) {\n      let shouldDelete = false;\n      try {\n        // Check low-res blob\n        if (entry.lowResUrl && entry.lowResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.lowResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale low-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true; // Mark for deletion if blob is invalid\n          }\n        }\n        // Check high-res blob\n        if (entry.highResUrl && entry.highResUrl.startsWith('blob:')) {\n          const response = await fetch(entry.highResUrl).catch(() => null);\n          if (!response || !response.ok) {\n            console.warn(`Stale high-res blob URL found for ${entry.id}. Removing.`);\n            shouldDelete = true;\n          }\n        }\n      } catch (e) {\n        console.warn(`Error checking blob URL for ${entry.id}. Assuming stale.`, e);\n        shouldDelete = true;\n      }\n\n      if (shouldDelete) {\n        await this.deleteCacheEntry(entry.id);\n        staleCount++;\n        // console.log(`ImageProcessor: Deleted stale cache entry for ${entry.id}`);\n      }\n    }\n\n    if (staleCount > 0) {\n      console.log(`ImageProcessor: Removed ${staleCount} stale cache entries.`);\n    } else {\n      console.log('ImageProcessor: No stale blob URLs found in cache.');\n    }\n  }\n\n  // --- Public Processing Methods (using Comlink) ---\n\n  async processImage(image: ImageInfo): Promise<void> {\n    const { id, src, width, height } = image;\n\n    if (!id || !src || !width || !height) {\n      console.error('Invalid image data provided to processImage:', image);\n      this.onError?.(id || 'unknown', 'Invalid image data');\n      return;\n    }\n\n    // Check cache immediately before queueing\n    try {\n      const cachedEntry = await this.getCacheEntry(id);\n      const lowResMatches =\n        cachedEntry?.lowResWidth === Math.round(width / 4) &&\n        cachedEntry?.lowResHeight === Math.round(height / 4);\n      const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n      if (cachedEntry?.lowResUrl && cachedEntry?.highResUrl && lowResMatches && highResMatches) {\n        console.log(`ImageProcessor: Cache hit for ${id} (pre-queue). Skipping queue.`);\n        // Publish low-res from cache\n        this.publisher?.({\n          id,\n          quality: 'low',\n          imageUrl: cachedEntry.lowResUrl,\n          width: cachedEntry.lowResWidth!,\n          height: cachedEntry.lowResHeight!,\n        });\n        // Publish high-res from cache\n        this.publisher?.({\n          id,\n          quality: 'high',\n          imageUrl: cachedEntry.highResUrl,\n          width: cachedEntry.width!,\n          height: cachedEntry.height!,\n        });\n        return; // Already cached, no need to queue\n      }\n    } catch (cacheError) {\n      console.error(`ImageProcessor: Error checking cache pre-queue for ${id}:`, cacheError);\n      // Proceed to queue anyway?\n    }\n\n    // Check if already actively being processed or queued\n    if (this.activeRequests.has(id)) {\n      console.log(`ImageProcessor: Request for ${id} is already active/queued. Skipping.`);\n      return;\n    }\n\n    // Create controller and add to active requests *before* queueing\n    const controller = new AbortController();\n    this.activeRequests.set(id, controller);\n\n    // Add the processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued task for ${id}. Queue size: ${this.queue.size}`\n        );\n        let createdBitmap: ImageBitmap | null = null;\n        try {\n          // Re-check cache inside queue in case it was populated while waiting\n          const cachedEntry = await this.getCacheEntry(id);\n          const lowResMatches =\n            cachedEntry?.lowResWidth === Math.round(width / 4) &&\n            cachedEntry?.lowResHeight === Math.round(height / 4);\n          const highResMatches = cachedEntry?.width === width && cachedEntry?.height === height;\n\n          if (\n            cachedEntry?.lowResUrl &&\n            cachedEntry?.highResUrl &&\n            lowResMatches &&\n            highResMatches\n          ) {\n            console.log(`ImageProcessor: Cache hit for ${id} (in-queue). Skipping processing.`);\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n            // Publish high-res from cache\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: cachedEntry.highResUrl,\n              width: cachedEntry.width!,\n              height: cachedEntry.height!,\n            });\n            return; // Exit queued task\n          }\n\n          // Check signal before potentially long operations\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before processing', 'AbortError');\n\n          // --- Prepare / Fetch Bitmap (same logic as before) ---\n          let reason = 'No cache entry';\n          let needsProcessing = true;\n\n          if (cachedEntry && (!lowResMatches || !highResMatches)) {\n            reason = `Cache found for ${id} but dimensions mismatch. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          } else if (cachedEntry?.lowResUrl && lowResMatches) {\n            reason = `Low-res cache hit for ${id}, processing for high-res.`;\n            // Publish low-res from cache\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: cachedEntry.lowResUrl,\n              width: cachedEntry.lowResWidth!,\n              height: cachedEntry.lowResHeight!,\n            });\n          } else if (cachedEntry) {\n            reason = `Inconsistent cache state for ${id}. Requesting re-processing.`;\n            await this.deleteCacheEntry(id);\n          }\n\n          console.log(`ImageProcessor: Fetching image ${id} to create ImageBitmap (queued).`);\n          try {\n            const response = await fetch(src, { signal: controller.signal });\n            if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);\n            const blob = await response.blob();\n            if (controller.signal.aborted) throw new DOMException('Aborted', 'AbortError');\n            createdBitmap = await createImageBitmap(blob);\n          } catch (fetchError: any) {\n            if (fetchError.name !== 'AbortError') {\n              console.error(\n                `ImageProcessor: Error fetching/creating bitmap for ${id} (queued):`,\n                fetchError\n              );\n              this.onError?.(id, fetchError.message || 'Failed to load image data');\n            }\n            // Rethrow to be caught by outer try/catch\n            throw fetchError;\n          }\n\n          // --- Call Worker ---\n          if (controller.signal.aborted)\n            throw new DOMException('Aborted before worker call', 'AbortError');\n          console.log(\n            `ImageProcessor: Sending image ${id} to worker via Comlink (queued). Reason: ${reason}`\n          );\n          const result = await this.proxy.processImage(\n            Comlink.transfer(\n              { id, imageBitmap: createdBitmap, width, height /* signal: controller.signal */ },\n              [createdBitmap]\n            )\n          );\n          createdBitmap = null; // Nullify after transfer\n\n          // --- Process Result ---\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Processing for ${id} aborted after worker call (queued).`);\n            if (result.lowResUrl) URL.revokeObjectURL(result.lowResUrl);\n            if (result.highResUrl) URL.revokeObjectURL(result.highResUrl);\n            return;\n          }\n\n          console.log(`ImageProcessor: Received results for ${id} from worker (queued).`);\n          const finalEntry: ProcessedImageCacheEntry = {\n            ...((await this.getCacheEntry(id)) || { id }),\n            id,\n            lowResUrl: result.lowResUrl ?? cachedEntry?.lowResUrl,\n            lowResWidth: result.lowResUrl ? Math.round(width / 4) : cachedEntry?.lowResWidth,\n            lowResHeight: result.lowResUrl ? Math.round(height / 4) : cachedEntry?.lowResHeight,\n            highResUrl: result.highResUrl,\n            width: result.highResUrl ? width : cachedEntry?.width,\n            height: result.highResUrl ? height : cachedEntry?.height,\n            timestamp: Date.now(),\n          };\n\n          await this.setCacheEntry(finalEntry);\n\n          // Publish results using the publisher function\n          if (result.lowResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'low',\n              imageUrl: finalEntry.lowResUrl!,\n              width: finalEntry.lowResWidth!,\n              height: finalEntry.lowResHeight!,\n            });\n          }\n          if (result.highResUrl) {\n            this.publisher?.({\n              id,\n              quality: 'high',\n              imageUrl: finalEntry.highResUrl!,\n              width: finalEntry.width!,\n              height: finalEntry.height!,\n            });\n          }\n        } catch (error: any) {\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued task for ${id} aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error during queued processing for ${id}:`, error);\n            this.onError?.(id, error.message || 'Queued processing failed');\n          }\n        } finally {\n          if (createdBitmap) {\n            try {\n              createdBitmap.close();\n            } catch (e) {\n              console.warn(`Error closing untransferred bitmap for ${id} (queued):`, e);\n            }\n          }\n          // Remove from active requests only when the queued task finishes/errors/aborts\n          this.activeRequests.delete(id);\n          console.log(\n            `ImageProcessor: Finished queued task for ${id}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself (rare)\n        console.error(`ImageProcessor: Error adding task to queue for ${id}:`, error);\n        this.activeRequests.delete(id); // Ensure cleanup if add fails\n        this.onError?.(id, error.message || 'Failed to queue task');\n      });\n  }\n\n  async processBatch(images: ImageInfo[]): Promise<void> {\n    const batchId = `batch-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\n    // Check if a batch request is already active/queued (using a placeholder ID structure)\n    // This simple check might not be sufficient if overlapping batches are possible\n    if (this.activeRequests.has(batchId)) {\n      // Use generated batchId for tracking\n      console.log(\n        `ImageProcessor: Batch request ${batchId} appears to be already active/queued. Skipping.`\n      );\n      return;\n    }\n\n    const controller = new AbortController();\n    this.activeRequests.set(batchId, controller);\n\n    // Add batch processing logic to the queue\n    this.queue\n      .add(async () => {\n        console.log(\n          `ImageProcessor: Starting queued batch task ${batchId}. Queue size: ${this.queue.size}`\n        );\n        const imagesToProcess: Array<{\n          id: string;\n          imageBitmap: ImageBitmap;\n          width: number;\n          height: number;\n        }> = [];\n        const transferList: ImageBitmap[] = [];\n        const preCheckPromises: Promise<void>[] = [];\n        const createdBitmaps: ImageBitmap[] = [];\n        let batchError: Error | null = null; // Track error within the queued task\n\n        try {\n          console.log(\n            `ImageProcessor: Starting batch preparation for ${images.length} images (queued). Batch ID: ${batchId}`\n          );\n\n          // --- Pre-check Cache and Fetch Bitmaps (inside queue task) ---\n          for (const image of images) {\n            const { id, src, width, height } = image;\n            if (!id || !src || !width || !height) {\n              console.error('Invalid image data in batch (queued):', image);\n              this.onError?.(id || 'unknown-batch', 'Invalid image data in batch');\n              continue;\n            }\n\n            preCheckPromises.push(\n              (async () => {\n                if (controller.signal.aborted) return;\n                let localBitmap: ImageBitmap | null = null;\n                try {\n                  const cachedEntry = await this.getCacheEntry(id);\n                  const lowResMatches =\n                    cachedEntry?.lowResWidth === Math.round(width / 4) &&\n                    cachedEntry?.lowResHeight === Math.round(height / 4);\n                  const highResMatches =\n                    cachedEntry?.width === width && cachedEntry?.height === height;\n\n                  if (\n                    cachedEntry?.lowResUrl &&\n                    cachedEntry?.highResUrl &&\n                    lowResMatches &&\n                    highResMatches\n                  ) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                    // Publish high-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'high',\n                      imageUrl: cachedEntry.highResUrl,\n                      width: cachedEntry.width!,\n                      height: cachedEntry.height!,\n                    });\n                    return;\n                  }\n\n                  if (cachedEntry && (!lowResMatches || !highResMatches)) {\n                    if (controller.signal.aborted) return;\n                    console.log(\n                      `ImageProcessor: Clearing mismatched cache for batch item ${id} (queued)`\n                    );\n                    await this.deleteCacheEntry(id);\n                  }\n\n                  if (controller.signal.aborted) return;\n                  console.log(`ImageProcessor: Fetching batch item ${id} (queued)`);\n                  const response = await fetch(src, { signal: controller.signal });\n                  if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);\n                  const blob = await response.blob();\n                  if (controller.signal.aborted) return;\n                  localBitmap = await createImageBitmap(blob);\n                  createdBitmaps.push(localBitmap);\n\n                  imagesToProcess.push({ id, imageBitmap: localBitmap, width, height });\n                  transferList.push(localBitmap);\n\n                  if (cachedEntry?.lowResUrl && lowResMatches) {\n                    if (controller.signal.aborted) return;\n                    // Publish low-res from cache\n                    this.publisher?.({\n                      id,\n                      quality: 'low',\n                      imageUrl: cachedEntry.lowResUrl,\n                      width: cachedEntry.lowResWidth!,\n                      height: cachedEntry.lowResHeight!,\n                    });\n                  }\n                } catch (error: any) {\n                  if (localBitmap) {\n                    try {\n                      localBitmap.close();\n                    } catch {}\n                    const index = createdBitmaps.indexOf(localBitmap);\n                    if (index > -1) createdBitmaps.splice(index, 1);\n                  }\n                  if (error.name !== 'AbortError') {\n                    console.error(\n                      `ImageProcessor: Error preparing batch item ${id} (queued):`,\n                      error\n                    );\n                    this.onError?.(id, error.message || 'Batch item preparation failed');\n                  } else {\n                    // Re-throw abort error to stop Promise.all\n                    throw error;\n                  }\n                }\n              })()\n            );\n          }\n\n          // Wait for preparation inside the queue task\n          await Promise.all(preCheckPromises);\n\n          if (controller.signal.aborted) {\n            console.log(`ImageProcessor: Batch ${batchId} aborted during preparation (queued).`);\n            throw new DOMException('Batch preparation aborted', 'AbortError');\n          }\n\n          // --- Call Worker ---\n          if (imagesToProcess.length > 0) {\n            console.log(\n              `ImageProcessor: Sending batch ${batchId} of ${imagesToProcess.length} images to worker via Comlink (queued).`\n            );\n            const batchResults = await this.proxy.processBatch(\n              Comlink.transfer(\n                { images: imagesToProcess /* signal: controller.signal */ },\n                transferList\n              )\n            );\n\n            // --- Process Results ---\n            if (controller.signal.aborted) {\n              console.log(\n                `ImageProcessor: Batch ${batchId} aborted after worker completed (queued).`\n              );\n              batchResults.forEach(r => {\n                if (r.lowResUrl) URL.revokeObjectURL(r.lowResUrl);\n                if (r.highResUrl) URL.revokeObjectURL(r.highResUrl);\n              });\n              // Still need to throw abort error to trigger finally cleanup correctly\n              throw new DOMException('Batch aborted post-worker', 'AbortError');\n            }\n\n            console.log(\n              `ImageProcessor: Received ${batchResults.length} results for batch ${batchId} (queued).`\n            );\n            const cacheUpdatePromises: Promise<void>[] = [];\n            for (const result of batchResults) {\n              const { id: resultId, lowResUrl, highResUrl } = result;\n              const originalItem = imagesToProcess.find(item => item.id === resultId);\n              const originalWidth = originalItem?.width;\n              const originalHeight = originalItem?.height;\n\n              if (!originalWidth || !originalHeight) continue;\n              const existingEntry = await this.getCacheEntry(resultId);\n              const finalEntry: ProcessedImageCacheEntry = {\n                id: resultId,\n                lowResUrl: result.lowResUrl ?? existingEntry?.lowResUrl,\n                lowResWidth: result.lowResUrl\n                  ? Math.round(originalWidth / 4)\n                  : existingEntry?.lowResWidth,\n                lowResHeight: result.lowResUrl\n                  ? Math.round(originalHeight / 4)\n                  : existingEntry?.lowResHeight,\n                highResUrl: result.highResUrl ?? existingEntry?.highResUrl,\n                width: result.highResUrl ? originalWidth : existingEntry?.width,\n                height: result.highResUrl ? originalHeight : existingEntry?.height,\n                timestamp: Date.now(),\n              };\n              cacheUpdatePromises.push(this.setCacheEntry(finalEntry));\n              // Publish results using the publisher function\n              if (result.lowResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'low',\n                  imageUrl: finalEntry.lowResUrl!,\n                  width: finalEntry.lowResWidth!,\n                  height: finalEntry.lowResHeight!,\n                });\n              }\n              if (result.highResUrl) {\n                this.publisher?.({\n                  id: resultId,\n                  quality: 'high',\n                  imageUrl: finalEntry.highResUrl!,\n                  width: finalEntry.width!,\n                  height: finalEntry.height!,\n                });\n              }\n            }\n            await Promise.all(cacheUpdatePromises);\n          } else {\n            console.log(\n              `ImageProcessor: No images needed processing for batch ${batchId} (queued).`\n            );\n          }\n        } catch (error: any) {\n          batchError = error; // Store error to handle in finally\n          if (error.name === 'AbortError') {\n            console.log(`ImageProcessor: Queued batch ${batchId} processing aborted.`);\n          } else {\n            console.error(`ImageProcessor: Error processing queued batch ${batchId}:`, error);\n            this.onError?.(batchId, error.message || 'Queued batch processing failed');\n          }\n        } finally {\n          // Ensure bitmaps not transferred are closed if aborted/errored during prep\n          // Also close bitmaps if a non-abort error occurred after prep\n          if (batchError?.name === 'AbortError' || batchError) {\n            createdBitmaps.forEach(bitmap => {\n              // Check if it was actually transferred before trying to close\n              if (!transferList.includes(bitmap)) {\n                try {\n                  bitmap.close();\n                } catch {}\n              }\n            });\n          }\n          // Worker handles closing transferred bitmaps\n          this.activeRequests.delete(batchId);\n          console.log(\n            `ImageProcessor: Finished queued batch task ${batchId}. Queue size: ${this.queue.size}`\n          );\n        }\n      })\n      .catch(error => {\n        // Catch errors from queue.add itself\n        console.error(`ImageProcessor: Error adding batch task to queue ${batchId}:`, error);\n        this.activeRequests.delete(batchId); // Ensure cleanup\n        this.onError?.(batchId, error.message || 'Failed to queue batch task');\n      });\n  }\n\n  // --- Control Methods ---\n  cancel(id?: string) {\n    if (id) {\n      const controller = this.activeRequests.get(id);\n      if (controller) {\n        console.log(`ImageProcessor: Aborting request ${id}.`);\n        controller.abort();\n        // Don't delete immediately, let the queued task handle cleanup in finally\n        // this.activeRequests.delete(id);\n      } else {\n        console.log(`ImageProcessor: No active request found for ID ${id} to cancel.`);\n      }\n    } else {\n      console.log(\n        `ImageProcessor: Aborting all ${this.activeRequests.size} active requests and clearing queue.`\n      );\n      // Abort all active controllers\n      this.activeRequests.forEach(controller => controller.abort());\n      // Clear pending tasks from the queue\n      this.queue.clear();\n      // Clear the tracking map\n      this.activeRequests.clear();\n    }\n  }\n\n  cancelAll() {\n    this.cancel(); // cancel() without id now handles clearing everything\n  }\n\n  terminate() {\n    console.log(\n      'ImageProcessor: Terminating worker, cancelling active requests, clearing queue, and closing DB.'\n    );\n    this.cancelAll(); // Abort ongoing and clear pending\n    // Add a small delay to allow abort signals to propagate potentially?\n    // setTimeout(() => {...\n    try {\n      this.proxy[Comlink.releaseProxy]();\n    } catch (e) {\n      console.warn('ImageProcessor: Error releasing Comlink proxy:', e);\n    }\n    this.worker.terminate();\n    if (dbPromise) {\n      getDb().then(db => db.close());\n      dbPromise = null;\n    }\n    // }, 50); // Example delay\n  }\n}\n\nexport function createImageProcessor(options?: Omit<ImageProcessorOptions, 'onImageProcessed'>) {\n  return new ImageProcessor(options);\n}\n","import { createImageProcessor } from './imageProcessor.js';\n// Import the actual worker type for type safety\nimport LayoutWorker from './layoutWorker.worker.ts?worker'; // Vite worker import syntax\n// Import the new color extractor worker\nimport ColorExtractorWorker from './colorExtractor.worker.ts?worker';\n// Import the new grouping worker\nimport PQueue from 'p-queue'; // Import p-queue\nimport { v4 as uuidv4 } from 'uuid'; // Use UUID for unique request IDs\nimport GroupingWorker from './groupingWorker.worker.ts?worker';\n\n// Define the type for the processor instance more explicitly\ntype ImageProcessorInstance = ReturnType<typeof createImageProcessor>;\n// Define the type for the layout worker instance\ntype LayoutWorkerInstance = Worker;\n// Define the type for the color extractor worker instance\ntype ColorExtractorWorkerInstance = Worker;\n// Define the type for the grouping worker instance\ntype GroupingWorkerInstance = Worker;\ntype WorkerInstance = LayoutWorkerInstance | ColorExtractorWorkerInstance | GroupingWorkerInstance;\ntype WorkerType = 'layout' | 'color' | 'grouping';\n\n// Interface for messages sent TO workers (includes requestId)\ninterface WorkerRequestMessage<T = any> {\n  type: string; // Original message type\n  payload: T;\n  requestId: string;\n}\n\n// Interface for messages received FROM workers (includes requestId)\ninterface WorkerResponseMessage<T = any> {\n  type: string; // e.g., 'layoutResult', 'colorResult', 'groupingResult', 'error'\n  payload: T;\n  requestId: string;\n}\n\ninterface WorkerErrorMessage {\n  type: 'error';\n  message: string;\n  requestId?: string; // Optional: Worker might include ID with error\n}\n\ninterface PendingRequest<T> {\n  resolve: (value: T | PromiseLike<T>) => void; // Allow PromiseLike for better compatibility\n  reject: (reason?: any) => void;\n  timer?: ReturnType<typeof setTimeout>; // Optional: Timeout timer\n}\n\nclass WorkerPool {\n  private static instance: WorkerPool;\n  // Use the more specific type\n  private imageProcessor: ImageProcessorInstance | null = null;\n  private layoutWorker: LayoutWorkerInstance | null = null;\n  private colorExtractorWorker: ColorExtractorWorkerInstance | null = null; // Add state for color worker\n  private groupingWorker: GroupingWorkerInstance | null = null; // Add state for grouping worker\n  private isImageProcessorInitialized = false;\n  private isLayoutWorkerInitialized = false;\n  private isColorExtractorInitialized = false; // Add flag for color worker\n  private isGroupingWorkerInitialized = false; // Add flag for grouping worker\n  private layoutWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for color worker\n  private colorExtractorListeners: Map<string, (event: MessageEvent) => void> = new Map();\n  // Add listeners map for grouping worker\n  private groupingWorkerListeners: Map<string, (event: MessageEvent) => void> = new Map();\n\n  // Initialization Promises\n  private layoutWorkerPromise: Promise<LayoutWorkerInstance> | null = null;\n  private colorExtractorWorkerPromise: Promise<ColorExtractorWorkerInstance> | null = null;\n  private groupingWorkerPromise: Promise<GroupingWorkerInstance> | null = null;\n\n  // Pending Requests Maps\n  private pendingLayoutRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingColorRequests: Map<string, PendingRequest<any>> = new Map();\n  private pendingGroupingRequests: Map<string, PendingRequest<any>> = new Map();\n\n  // --- p-queue Instances --- >\n  private layoutQueue: PQueue;\n  private colorQueue: PQueue;\n  private groupingQueue: PQueue;\n\n  private constructor() {\n    // Initialize queues with desired concurrency\n    // Layout and grouping are likely sequential operations affecting the whole view\n    this.layoutQueue = new PQueue({ concurrency: 1 });\n    this.groupingQueue = new PQueue({ concurrency: 1 });\n    // Color extraction can often run more concurrently\n    this.colorQueue = new PQueue({\n      concurrency: Math.max(1, (navigator.hardwareConcurrency || 4) - 1),\n    });\n    console.log(\n      `[WorkerPool] Initialized queues. Concurrency - Layout: ${this.layoutQueue.concurrency}, Grouping: ${this.groupingQueue.concurrency}, Color: ${this.colorQueue.concurrency}`\n    );\n  }\n\n  public static getInstance(): WorkerPool {\n    if (!WorkerPool.instance) {\n      WorkerPool.instance = new WorkerPool();\n    }\n    return WorkerPool.instance;\n  }\n\n  // --- Generic Worker Initializer ---\n  private initializeWorker<W extends WorkerInstance>(\n    workerType: WorkerType,\n    WorkerConstructor: new () => W,\n    setupListenersFn: (worker: W) => void\n  ): Promise<W> {\n    console.log(`WorkerPool: Initializing ${workerType} Worker...`);\n    return new Promise<W>((resolve, reject) => {\n      try {\n        const worker = new WorkerConstructor();\n        setupListenersFn(worker);\n        console.log(`WorkerPool: ${workerType} Worker initialized successfully.`);\n        resolve(worker);\n      } catch (error) {\n        console.error(`[WorkerPool] Failed to initialize ${workerType} Worker:`, error);\n        reject(new Error(`Failed to initialize ${workerType} Worker`));\n      }\n    });\n  }\n\n  // --- Image Processor Management ---\n\n  public getImageProcessor(): ImageProcessorInstance {\n    if (!this.imageProcessor) {\n      console.log('WorkerPool: Initializing Image Processor...');\n      this.imageProcessor = createImageProcessor();\n      this.isImageProcessorInitialized = true;\n    } else {\n      // console.log('WorkerPool: Returning existing Image Processor.');\n    }\n    return this.imageProcessor;\n  }\n\n  // Add method to cancel pending image processing tasks\n  public cancelPendingImageTasks() {\n    if (this.imageProcessor && this.isImageProcessorInitialized) {\n      console.log('WorkerPool: Cancelling pending image processing tasks...');\n      this.imageProcessor.cancel?.(); // Use optional chaining\n    } else {\n      // console.log('WorkerPool: No active image processor to cancel tasks for.');\n    }\n  }\n\n  // --- Layout Worker Management (Promise-based) ---\n  public getLayoutWorker(): Promise<LayoutWorkerInstance> {\n    if (!this.layoutWorkerPromise) {\n      this.layoutWorkerPromise = this.initializeWorker('layout', LayoutWorker, worker => {\n        this.layoutWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'layout',\n          this.pendingLayoutRequests,\n          this.layoutWorkerListeners\n        );\n      }).catch(err => {\n        this.layoutWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.layoutWorkerPromise;\n  }\n\n  // --- Color Extractor Worker Management (Promise-based) ---\n  public getColorExtractorWorker(): Promise<ColorExtractorWorkerInstance> {\n    if (!this.colorExtractorWorkerPromise) {\n      this.colorExtractorWorkerPromise = this.initializeWorker(\n        'color',\n        ColorExtractorWorker,\n        worker => {\n          this.colorExtractorWorker = worker; // Store the instance\n          this.setupWorkerMessageHandler(\n            worker,\n            'color',\n            this.pendingColorRequests,\n            this.colorExtractorListeners\n          );\n        }\n      ).catch(err => {\n        this.colorExtractorWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.colorExtractorWorkerPromise;\n  }\n\n  // --- Grouping Worker Management (Promise-based) ---\n  public getGroupingWorker(): Promise<GroupingWorkerInstance> {\n    if (!this.groupingWorkerPromise) {\n      this.groupingWorkerPromise = this.initializeWorker('grouping', GroupingWorker, worker => {\n        this.groupingWorker = worker; // Store the instance\n        this.setupWorkerMessageHandler(\n          worker,\n          'grouping',\n          this.pendingGroupingRequests,\n          this.groupingWorkerListeners\n        );\n      }).catch(err => {\n        this.groupingWorkerPromise = null; // Reset promise on failure\n        throw err; // Re-throw error\n      });\n    }\n    return this.groupingWorkerPromise;\n  }\n\n  // --- Generic Message Handler Setup ---\n  private setupWorkerMessageHandler<T>(\n    worker: WorkerInstance,\n    workerType: WorkerType,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    generalListeners: Map<string, (event: MessageEvent) => void>\n  ): void {\n    worker.onmessage = (event: MessageEvent<WorkerResponseMessage<T> | WorkerErrorMessage>) => {\n      const { data } = event;\n      const requestId = data.requestId;\n\n      // console.log(`[WorkerPool] Received message from ${workerType} worker:`, data);\n\n      if (requestId && pendingRequests.has(requestId)) {\n        const request = pendingRequests.get(requestId)!;\n        clearTimeout(request.timer); // Clear timeout if response received\n\n        if (data.type === 'error') {\n          console.error(\n            `[WorkerPool] Error response for request ${requestId} from ${workerType}:`,\n            (data as WorkerErrorMessage).message\n          );\n          request.reject(\n            new Error((data as WorkerErrorMessage).message || 'Worker returned an error')\n          );\n        } else {\n          // Assume other types are successful results\n          // console.log(`[WorkerPool] Resolving request ${requestId} for ${workerType}`);\n          request.resolve((data as WorkerResponseMessage<T>).payload);\n        }\n        pendingRequests.delete(requestId);\n      } else if (requestId) {\n        console.warn(\n          `[WorkerPool] Received message with unknown or stale requestId ${requestId} from ${workerType}:`,\n          data\n        );\n        // Optionally dispatch to general listeners if it's a non-error message?\n        // generalListeners.forEach(listener => listener(event));\n      } else {\n        // Message without requestId - likely a general status or unhandled message\n        // console.log(`[WorkerPool] Received non-request message from ${workerType}:`, data);\n        generalListeners.forEach(listener => listener(event));\n      }\n    };\n\n    worker.onerror = (event: ErrorEvent) => {\n      console.error(`[WorkerPool] Generic error from ${workerType} Worker:`, event.message, event);\n      // Attempt to reject related pending requests, though we lack specific request ID here\n      // This is a limitation if the worker crashes without sending a request-specific error\n      const error = new Error(`Worker ${workerType} encountered an error: ${event.message}`);\n      pendingRequests.forEach((request, requestId) => {\n        console.warn(\n          `[WorkerPool] Rejecting pending request ${requestId} due to generic ${workerType} worker error.`\n        );\n        clearTimeout(request.timer);\n        request.reject(error);\n      });\n      pendingRequests.clear(); // Clear all pending requests for this worker on generic error\n\n      // Also notify general listeners\n      generalListeners.forEach(listener => listener(event as any));\n\n      // Consider terminating and resetting the worker promise here?\n      // worker.terminate(); // Be careful with immediate termination\n      // this[`${workerType}WorkerPromise`] = null;\n      // this[`${workerType}Worker`] = null;\n    };\n  }\n\n  // --- Unified Request Posting (Uses p-queue) ---\n  public postRequest<RequestPayload, ResponsePayload>(\n    workerType: WorkerType,\n    messageType: string,\n    payload: RequestPayload,\n    options?: { priority?: number; timeoutMs?: number }\n  ): Promise<ResponsePayload> {\n    let queue: PQueue;\n    let pendingRequests: Map<string, PendingRequest<ResponsePayload>>;\n    let getWorkerPromise: () => Promise<WorkerInstance>;\n\n    // Select the appropriate queue, map, and getter\n    switch (workerType) {\n      case 'layout':\n        queue = this.layoutQueue;\n        pendingRequests = this.pendingLayoutRequests;\n        getWorkerPromise = this.getLayoutWorker.bind(this);\n        break;\n      case 'color':\n        queue = this.colorQueue;\n        pendingRequests = this.pendingColorRequests;\n        getWorkerPromise = this.getColorExtractorWorker.bind(this);\n        break;\n      case 'grouping':\n        queue = this.groupingQueue;\n        pendingRequests = this.pendingGroupingRequests;\n        getWorkerPromise = this.getGroupingWorker.bind(this);\n        break;\n      default:\n        return Promise.reject(new Error(`Invalid worker type: ${workerType}`));\n    }\n\n    // The task added to the queue - *Removed async keyword here*\n    const task = (): Promise<ResponsePayload> => {\n      // Return a new promise that encapsulates the entire worker interaction\n      return new Promise<ResponsePayload>(async (resolveTask, rejectTask) => {\n        const requestId = uuidv4();\n        // console.log(`[WorkerPool] Starting task ${requestId} (${messageType}) for ${workerType}`);\n\n        let worker: WorkerInstance;\n        try {\n          // Ensure worker is initialized within the promise executor\n          worker = await getWorkerPromise();\n        } catch (initError) {\n          console.error(\n            `[WorkerPool] Failed to initialize worker ${workerType} for task ${requestId}:`,\n            initError\n          );\n          rejectTask(initError); // Reject the task promise if init fails\n          return;\n        }\n\n        // Now, manage the specific response via the pendingRequests map\n        let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n        const responsePromise = new Promise<ResponsePayload>((resolveResponse, rejectResponse) => {\n          // Store the inner promise's resolve/reject for the message handler\n          pendingRequests.set(requestId, {\n            resolve: resolveResponse,\n            reject: rejectResponse,\n            timer,\n          });\n        });\n\n        // Setup timeout if specified for the *response* part\n        if (options?.timeoutMs) {\n          timer = setTimeout(() => {\n            if (pendingRequests.has(requestId)) {\n              console.warn(\n                `[WorkerPool] Request ${requestId} to ${workerType} timed out after ${options.timeoutMs}ms.`\n              );\n              // Reject the *response* promise via the map\n              pendingRequests.get(requestId)?.reject(new Error(`Request ${requestId} timed out`));\n              pendingRequests.delete(requestId);\n            }\n          }, options.timeoutMs);\n          // Update the timer reference in the map\n          if (pendingRequests.has(requestId)) {\n            pendingRequests.get(requestId)!.timer = timer;\n          }\n        }\n\n        // Construct the message\n        const workerMessage: WorkerRequestMessage<RequestPayload> = {\n          type: messageType,\n          payload,\n          requestId,\n        };\n\n        // Post the message to the worker\n        try {\n          // console.log(`[WorkerPool] Posting message for ${requestId} to ${workerType}`);\n          worker.postMessage(workerMessage);\n        } catch (postError) {\n          console.error(\n            `[WorkerPool] Error posting message for request ${requestId} to ${workerType}:`,\n            postError\n          );\n          clearTimeout(timer);\n          pendingRequests.delete(requestId);\n          rejectTask(postError); // Reject the outer task promise if postMessage fails\n          return;\n        }\n\n        // Link the outer task promise to the inner response promise\n        try {\n          const result = await responsePromise;\n          resolveTask(result);\n        } catch (error) {\n          rejectTask(error);\n        } finally {\n          clearTimeout(timer); // Ensure timer is cleared if response promise settles\n        }\n      });\n    };\n\n    // Add the task function to the queue\n    return queue.add(task, { priority: options?.priority ?? 0 }) as Promise<ResponsePayload>;\n  }\n\n  // --- Listener Management (for general messages, if still needed) ---\n\n  public addLayoutWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for LayoutWorker: ${id}`);\n    this.layoutWorkerListeners.set(id, listener);\n    this.getLayoutWorker(); // Ensure worker is initialized to receive potential messages\n  }\n\n  public removeLayoutWorkerListener(id: string): void {\n    if (this.layoutWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for LayoutWorker: ${id}`);\n      this.layoutWorkerListeners.delete(id);\n    }\n  }\n\n  public addColorExtractorListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for ColorExtractorWorker: ${id}`);\n    this.colorExtractorListeners.set(id, listener);\n    this.getColorExtractorWorker();\n  }\n\n  public removeColorExtractorListener(id: string): void {\n    if (this.colorExtractorListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for ColorExtractorWorker: ${id}`);\n      this.colorExtractorListeners.delete(id);\n    }\n  }\n\n  public addGroupingWorkerListener(id: string, listener: (event: MessageEvent) => void): void {\n    console.log(`[WorkerPool] Adding general listener for GroupingWorker: ${id}`);\n    this.groupingWorkerListeners.set(id, listener);\n    this.getGroupingWorker();\n  }\n\n  public removeGroupingWorkerListener(id: string): void {\n    if (this.groupingWorkerListeners.has(id)) {\n      console.log(`[WorkerPool] Removing general listener for GroupingWorker: ${id}`);\n      this.groupingWorkerListeners.delete(id);\n    }\n  }\n\n  // --- Cancellation ---\n\n  public cancelPendingLayoutTasks(all: boolean = false) {\n    this.cancelTasks('layout', this.layoutQueue, this.pendingLayoutRequests, all);\n  }\n  public cancelPendingColorTasks(all: boolean = false) {\n    this.cancelTasks('color', this.colorQueue, this.pendingColorRequests, all);\n  }\n  public cancelPendingGroupingTasks(all: boolean = false) {\n    this.cancelTasks('grouping', this.groupingQueue, this.pendingGroupingRequests, all);\n  }\n\n  private cancelTasks<T>(\n    workerType: WorkerType,\n    queue: PQueue,\n    pendingRequests: Map<string, PendingRequest<T>>,\n    all: boolean = true // Default to cancelling all\n  ) {\n    if (!all) {\n      console.warn(\n        `[WorkerPool] Specific request cancellation via ID is not directly supported with queue.clear(). Use cancelAllPendingTasks() or implement AbortSignal.`\n      );\n      return;\n    }\n\n    console.log(`[WorkerPool] Cancelling pending tasks and clearing queue for ${workerType}...`);\n\n    // 1. Clear tasks waiting in the queue (these haven't started)\n    queue.clear();\n\n    // 2. Reject promises for tasks already sent to the worker (in-flight)\n    pendingRequests.forEach((request, id) => {\n      console.warn(\n        `[WorkerPool] Rejecting in-flight request ${id} for ${workerType} due to cancellation.`\n      );\n      clearTimeout(request.timer);\n      request.reject(new Error(`Request ${id} for ${workerType} was cancelled.`));\n      // Optionally, try to notify the worker if it supports cancellation messages\n      // const worker = this[`${workerType}Worker`];\n      // if (worker) {\n      //     try { worker.postMessage({ type: 'cancel', requestId: id }); } catch(e) {}\n      // }\n    });\n    pendingRequests.clear(); // Clear the map after rejecting\n  }\n\n  // --- General Cleanup ---\n\n  public cleanup() {\n    console.log('WorkerPool: Starting cleanup...');\n    this.cancelAllPendingTasks(); // Cancel everything first\n\n    // Terminate Workers\n    this.terminateWorker('layout', this.layoutWorker);\n    this.layoutWorker = null;\n    this.layoutWorkerPromise = null;\n    this.layoutWorkerListeners.clear();\n\n    this.terminateWorker('color', this.colorExtractorWorker);\n    this.colorExtractorWorker = null;\n    this.colorExtractorWorkerPromise = null;\n    this.colorExtractorListeners.clear();\n\n    this.terminateWorker('grouping', this.groupingWorker);\n    this.groupingWorker = null;\n    this.groupingWorkerPromise = null;\n    this.groupingWorkerListeners.clear();\n\n    // Cleanup Image Processor\n    if (this.imageProcessor) {\n      console.log('WorkerPool: Cleaning up Image Processor...');\n      this.imageProcessor.terminate?.();\n      this.imageProcessor = null;\n    }\n\n    // Clear queues (should be empty after cancelAll, but good practice)\n    this.layoutQueue.clear();\n    this.groupingQueue.clear();\n    this.colorQueue.clear();\n\n    console.log('WorkerPool: Cleanup complete.');\n  }\n\n  private terminateWorker(workerType: WorkerType, worker: WorkerInstance | null) {\n    if (worker) {\n      console.log(`WorkerPool: Terminating ${workerType} worker...`);\n      try {\n        worker.terminate();\n      } catch (e) {\n        console.error(`Error terminating ${workerType} worker:`, e);\n      }\n    }\n  }\n\n  // Optional: Combined cancel function\n  public cancelAllPendingTasks() {\n    this.cancelPendingImageTasks(); // Assuming this one is different\n    this.cancelPendingLayoutTasks(true);\n    this.cancelPendingColorTasks(true);\n    this.cancelPendingGroupingTasks(true);\n  }\n}\n\nexport default WorkerPool;\n// Export types needed by consumers\nexport type { WorkerErrorMessage, WorkerRequestMessage, WorkerResponseMessage, WorkerType };\n","import { DBSchema, IDBPDatabase, openDB } from 'idb';\r\n\r\nconst UI_STATE_DB_NAME = 'mediaFlowUIScrollDB';\r\nconst SCROLL_STATE_STORE_NAME = 'scrollPosition';\r\nconst DB_VERSION = 1;\r\n\r\n// Define the structure of the state we want to store - ONLY scrollTop\r\nexport interface ScrollState {\r\n  scrollTop: number;\r\n  timestamp: number;\r\n}\r\n\r\n// Define the database schema\r\ninterface ScrollStateDB extends DBSchema {\r\n  [SCROLL_STATE_STORE_NAME]: {\r\n    key: string; // folderPath\r\n    value: ScrollState;\r\n  };\r\n}\r\n\r\n// Singleton promise to ensure DB is opened only once\r\nlet dbPromise: Promise<IDBPDatabase<ScrollStateDB>> | null = null;\r\n\r\nfunction openScrollStateDB(): Promise<IDBPDatabase<ScrollStateDB>> {\r\n  if (!dbPromise) {\r\n    dbPromise = openDB<ScrollStateDB>(UI_STATE_DB_NAME, DB_VERSION, {\r\n      upgrade(db) {\r\n        // Create the object store if it doesn't exist\r\n        if (!db.objectStoreNames.contains(SCROLL_STATE_STORE_NAME)) {\r\n          db.createObjectStore(SCROLL_STATE_STORE_NAME);\r\n        }\r\n      },\r\n    });\r\n  }\r\n  return dbPromise;\r\n}\r\n\r\n/**\r\n * Saves the scroll top position for a specific folder path to IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @param scrollTop - The scroll position to save.\r\n */\r\nexport async function saveScrollState(folderPath: string, scrollTop: number): Promise<void> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const stateToSave: ScrollState = {\r\n      scrollTop: scrollTop,\r\n      timestamp: Date.now(),\r\n    };\r\n    await store.put(stateToSave, folderPath);\r\n    await tx.done;\r\n  } catch (error) {\r\n    console.error('Failed to save scroll state for path:', folderPath, error);\r\n  }\r\n}\r\n\r\n/**\r\n * Loads the scroll state for a specific folder path from IndexedDB.\r\n * @param folderPath - The identifier for the folder.\r\n * @returns The saved ScrollState object (containing scrollTop and timestamp) or null.\r\n */\r\nexport async function loadScrollState(folderPath: string): Promise<ScrollState | null> {\r\n  try {\r\n    const db = await openScrollStateDB();\r\n    const tx = db.transaction(SCROLL_STATE_STORE_NAME, 'readonly');\r\n    const store = tx.objectStore(SCROLL_STATE_STORE_NAME);\r\n    const state = await store.get(folderPath);\r\n    await tx.done;\r\n    return state ?? null;\r\n  } catch (error) {\r\n    console.error('Failed to load scroll state for path:', folderPath, error);\r\n    return null;\r\n  }\r\n}\r\n","import gsap from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\n\r\ngsap.registerPlugin(ScrollTrigger);\r\n\r\ninterface AnimationTarget {\r\n  element: HTMLElement;\r\n  animation: gsap.core.Tween | gsap.core.Timeline;\r\n}\r\n\r\nclass ScrollTriggerManager {\r\n  private static instance: ScrollTriggerManager;\r\n  private targets: Map<string, AnimationTarget> = new Map();\r\n  private timeline: gsap.core.Timeline;\r\n  private mainTrigger: ScrollTrigger;\r\n\r\n  private constructor() {\r\n    this.timeline = gsap.timeline({\r\n      paused: true,\r\n      smoothChildTiming: true,\r\n    });\r\n\r\n    // Create one main ScrollTrigger\r\n    this.mainTrigger = ScrollTrigger.create({\r\n      trigger: document.body,\r\n      start: 'top top',\r\n      end: 'bottom bottom',\r\n      onUpdate: self => {\r\n        // Update timeline progress based on scroll\r\n        this.timeline.progress(self.progress);\r\n      },\r\n      markers: false, // Always disable markers\r\n    });\r\n  }\r\n\r\n  static getInstance(): ScrollTriggerManager {\r\n    if (!ScrollTriggerManager.instance) {\r\n      ScrollTriggerManager.instance = new ScrollTriggerManager();\r\n    }\r\n    return ScrollTriggerManager.instance;\r\n  }\r\n\r\n  addAnimation(id: string, element: HTMLElement, animationProps: gsap.TweenVars) {\r\n    // Create the animation but don't play it yet\r\n    const animation = gsap.to(element, {\r\n      ...animationProps,\r\n      paused: true,\r\n    });\r\n\r\n    // Add it to our timeline\r\n    this.timeline.add(animation, 0);\r\n\r\n    // Store reference\r\n    this.targets.set(id, { element, animation });\r\n\r\n    return animation;\r\n  }\r\n\r\n  removeAnimation(id: string) {\r\n    const target = this.targets.get(id);\r\n    if (target) {\r\n      this.timeline.remove(target.animation);\r\n      this.targets.delete(id);\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    // Kill all ScrollTriggers to prevent memory leaks\r\n    this.targets.forEach(({ animation }) => {\r\n      animation.kill();\r\n    });\r\n\r\n    if (this.mainTrigger) {\r\n      this.mainTrigger.kill();\r\n    }\r\n\r\n    this.timeline.kill();\r\n    this.targets.clear();\r\n    ScrollTrigger.getAll().forEach(trigger => trigger.kill());\r\n  }\r\n}\r\n\r\nexport default ScrollTriggerManager;\r\n","import gsap from 'gsap';\nimport { CustomEase } from 'gsap/CustomEase';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport ScrollTriggerManager from './ScrollTriggerManager';\n\ngsap.registerPlugin(ScrollTrigger, CustomEase);\n\n// Simplified animation system without ripples and energy mechanics\nexport class AnimationSystem {\n  private static instance: AnimationSystem;\n  private scrollTriggerManager: ScrollTriggerManager;\n\n  private constructor() {\n    this.initializeCustomEases();\n    this.scrollTriggerManager = ScrollTriggerManager.getInstance();\n  }\n\n  private initializeCustomEases() {\n    CustomEase.create(\n      'smoothOut',\n      'M0,0 C0.126,0.382 0.282,0.674 0.44,0.822 0.632,1.002 0.818,1 1,1'\n    );\n    CustomEase.create('gentleIn', 'M0,0 C0.39,0 0.575,0.565 0.669,0.782 0.762,1 0.846,1 1,1');\n  }\n\n  static getInstance(): AnimationSystem {\n    if (!AnimationSystem.instance) {\n      AnimationSystem.instance = new AnimationSystem();\n    }\n    return AnimationSystem.instance;\n  }\n\n  getAnimationProperties(itemId: string): gsap.TweenVars {\n    return {\n      duration: 0.5,\n      ease: 'power2.out',\n      transformOrigin: 'center center',\n      scale: 1,\n      rotation: 0,\n    };\n  }\n\n  createHoverAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      scale: 1.05,\n      duration: 0.3,\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  createMorphAnimation(element: HTMLElement, itemId: string) {\n    return gsap.to(element, {\n      duration: 0.5,\n      borderRadius: '8px',\n      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n      ease: 'power2.out',\n      force3D: true,\n    });\n  }\n\n  // New method that uses the ScrollTriggerManager for scroll-based animations\n  createScrollAnimation(element: HTMLElement, itemId: string, animationProps: gsap.TweenVars) {\n    return this.scrollTriggerManager.addAnimation(itemId, element, animationProps);\n  }\n}\n\nexport default AnimationSystem;\n","import { ImageInfo, ViewMode } from '../types/index.js';\n\n// Constants\nexport const MIN_IMAGE_WIDTH = 200;\nexport const MAX_COLUMNS = 7;\nexport const MIN_COLUMNS = 1;\nexport const BASE_GAP = 4;\nexport const MIN_GAP = 2;\nexport const MAX_GAP = 12;\nexport const MIN_ZOOM = 0.5;\nexport const MAX_ZOOM = 3;\n\n// Types\nexport interface LayoutConfig {\n  containerWidth: number;\n  zoom: number;\n  viewMode: ViewMode;\n  isGrouped: boolean;\n}\n\nexport interface RowConfig {\n  width: number;\n  height: number;\n  gap: number;\n  images: ImageInfo[];\n  imageWidths?: number[];\n  offset?: number;\n}\n\nexport interface ImageDimensions {\n  width: number;\n  height: number;\n  aspectRatio: number;\n}\n\n// Cache for aspect ratios and dimensions\nconst aspectRatioCache = new WeakMap<ImageInfo, number>();\nconst layoutCache = new Map<string, RowConfig[]>();\n\n// Example: Caching sorted order of images\nconst sortedImagesCache = new Map<string, ImageInfo[]>();\n\nconst getSortedImages = (images: ImageInfo[]): ImageInfo[] => {\n  // Generate an identifier for the current order; could be a hash of ids\n  const cacheKey = images.map(img => img.id).join(',');\n  if (sortedImagesCache.has(cacheKey)) {\n    return sortedImagesCache.get(cacheKey)!;\n  }\n  // Sort images by aspect ratio (or any other criteria)\n  const sorted = [...images].sort((a, b) => a.width / a.height - b.width / b.height);\n  sortedImagesCache.set(cacheKey, sorted);\n  return sorted;\n};\n\n// Enhanced cache key generation with size awareness\nconst generateCacheKey = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  viewMode: string\n): string => {\n  return `${containerWidth}-${zoom}-${viewMode}-${images.map(img => img.id).join(',')}`;\n};\n\n// Cache invalidation threshold (in pixels)\nconst CACHE_INVALIDATION_THRESHOLD = 8;\n\nclass SizeAwareCache<T> {\n  private cache: Map<string, { data: T; width: number }>;\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, width: number): void {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, { data: value, width });\n  }\n\n  get(key: string, currentWidth: number): T | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    // Invalidate cache if width difference exceeds threshold\n    if (Math.abs(entry.width - currentWidth) > CACHE_INVALIDATION_THRESHOLD) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Replace existing caches with size-aware versions\nconst rowLayoutCache = new SizeAwareCache<RowConfig>(100);\nconst dimensionsCache = new SizeAwareCache<ImageDimensions>(500);\n\n// Core calculation functions\nexport const calculateColumns = (containerWidth: number, zoom: number): number => {\n  const effectiveWidth = containerWidth / zoom;\n  const baseColumns = Math.floor(effectiveWidth / (MIN_IMAGE_WIDTH * zoom));\n  return Math.min(Math.max(baseColumns, MIN_COLUMNS), MAX_COLUMNS);\n};\n\n// Add smooth zoom transition helper\nexport const interpolateZoom = (\n  currentZoom: number,\n  targetZoom: number,\n  progress: number\n): number => {\n  return currentZoom + (targetZoom - currentZoom) * progress;\n};\n\nexport const calculateGapSize = (zoom: number): number => {\n  // Normalize zoom level\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  // Calculate base gap size with finer granularity\n  const zoomFactor = (normalizedZoom - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);\n  const baseGap = BASE_GAP * (1 + zoomFactor * 0.25);\n\n  // Round to nearest even number to ensure consistent spacing\n  const roundedGap = Math.round(baseGap * 2) / 2;\n\n  // Ensure gap stays within bounds\n  return Math.min(Math.max(roundedGap, MIN_GAP), MAX_GAP);\n};\n\n// Optimized aspect ratio calculation with caching\nconst getAspectRatio = (image: ImageInfo): number => {\n  let ratio = aspectRatioCache.get(image);\n  if (!ratio) {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      ratio = image.width / image.height;\n      aspectRatioCache.set(image, ratio);\n    } else {\n      ratio = 1; // Default fallback\n    }\n  }\n  return ratio;\n};\n\n// Batch process aspect ratios\nconst batchProcessAspectRatios = (images: ImageInfo[]): number[] => {\n  return images.map(getAspectRatio);\n};\n\n// Optimized image dimensions calculation with caching\nexport const calculateImageDimensions = (\n  image: ImageInfo,\n  containerWidth: number,\n  zoom: number\n): ImageDimensions => {\n  const cacheKey = generateCacheKey([image], containerWidth, zoom, 'dimensions');\n  const cachedDimensions = dimensionsCache.get(cacheKey, containerWidth);\n\n  if (cachedDimensions) {\n    return cachedDimensions;\n  }\n\n  const aspectRatio = getAspectRatio(image);\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n\n  const maxWidth = Math.min(containerWidth, MIN_IMAGE_WIDTH * MAX_COLUMNS);\n  const baseWidth = Math.min(\n    Math.max(MIN_IMAGE_WIDTH * normalizedZoom, containerWidth / MAX_COLUMNS),\n    maxWidth\n  );\n\n  const width = Math.round(baseWidth);\n  const height = Math.round(width / aspectRatio);\n\n  const dimensions = { width, height, aspectRatio };\n  dimensionsCache.set(cacheKey, dimensions, containerWidth);\n\n  return dimensions;\n};\n\nexport const detectOverflow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number\n): boolean => {\n  const gap = calculateGapSize(zoom);\n  const totalWidth = images.reduce((sum, image) => {\n    const { width } = calculateImageDimensions(image, containerWidth, zoom);\n    return sum + width + gap;\n  }, -gap); // Subtract last gap\n\n  return totalWidth > containerWidth;\n};\n\n// Add new helper function for calculating optimal row distribution\nconst calculateOptimalDistribution = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { idealHeight: number; widths: number[] } => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate ideal height that would make images fill the width perfectly\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate widths based on aspect ratios and ideal height\n  const widths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  return { idealHeight, widths };\n};\n\n// Enhanced checkRowFit function\nconst checkRowFit = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): { fits: boolean; idealHeight: number; predictedWidths: number[] } => {\n  const { idealHeight, widths } = calculateOptimalDistribution(images, containerWidth, zoom, gap);\n  const minWidth = MIN_IMAGE_WIDTH * zoom;\n\n  // Check if any image would be too narrow based on aspect ratio\n  const allImagesWideEnough = widths.every(width => width >= minWidth);\n\n  // Calculate total width including gaps\n  const totalWidth = widths.reduce((sum, width) => sum + width, 0) + (images.length - 1) * gap;\n\n  return {\n    fits: allImagesWideEnough && totalWidth <= containerWidth,\n    idealHeight,\n    predictedWidths: widths,\n  };\n};\n\n// Update distributeImages function\nexport const distributeImages = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  targetRowHeight: number = 200\n): RowConfig[] => {\n  if (containerWidth <= 0 || images.length === 0) {\n    console.warn('Invalid input detected');\n    return [];\n  }\n\n  const sortedImages = getSortedImages(images);\n  const gap = calculateGapSize(zoom);\n  const rows: RowConfig[] = [];\n  let currentRow: ImageInfo[] = [];\n  let currentRowAspectRatio = 0;\n\n  for (let i = 0; i < sortedImages.length; i++) {\n    const testRow = [...currentRow, sortedImages[i]];\n    const { fits, idealHeight, predictedWidths } = checkRowFit(testRow, containerWidth, zoom, gap);\n\n    if (!fits && currentRow.length > 0) {\n      // --- Finalize the current row ---\n      const { idealHeight, widths: currentWidths } = calculateOptimalDistribution(\n        currentRow,\n        containerWidth,\n        zoom,\n        gap\n      );\n      const rowHeight = Math.floor(idealHeight);\n      // Adjust widths to fit exactly\n      const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n      let calculatedWidthSum = 0;\n      const adjustedWidths = currentRow.map((img, index) => {\n        const width = Math.floor(getAspectRatio(img) * rowHeight);\n        calculatedWidthSum += width;\n        return width;\n      });\n\n      // Distribute remainder/deficit due to flooring\n      const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n      if (discrepancy !== 0 && adjustedWidths.length > 0) {\n        // Add discrepancy to the last image for simplicity\n        adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n      }\n\n      rows.push({\n        width: containerWidth,\n        height: rowHeight,\n        gap,\n        images: currentRow,\n        imageWidths: adjustedWidths, // Use adjusted widths\n        offset: 0,\n      });\n      // --- End finalize current row ---\n\n      // Start new row with current image\n      currentRow = [sortedImages[i]];\n      currentRowAspectRatio = getAspectRatio(sortedImages[i]);\n    } else {\n      // Add image to current row\n      currentRow = testRow;\n      currentRowAspectRatio += getAspectRatio(sortedImages[i]);\n    }\n  }\n\n  // Handle last row\n  if (currentRow.length > 0) {\n    // --- Finalize the last row ---\n    const { idealHeight, widths: initialWidths } = calculateOptimalDistribution(\n      currentRow,\n      containerWidth,\n      zoom,\n      gap\n    );\n    const rowHeight = Math.floor(idealHeight);\n    // Adjust widths to fit exactly\n    const totalGapWidth = Math.max(0, (currentRow.length - 1) * gap);\n    let calculatedWidthSum = 0;\n    const adjustedWidths = currentRow.map((img, index) => {\n      const width = Math.floor(getAspectRatio(img) * rowHeight);\n      calculatedWidthSum += width;\n      return width;\n    });\n\n    // Distribute remainder/deficit due to flooring\n    const discrepancy = containerWidth - totalGapWidth - calculatedWidthSum;\n    if (discrepancy !== 0 && adjustedWidths.length > 0) {\n      // Add discrepancy to the last image for simplicity\n      adjustedWidths[adjustedWidths.length - 1] += discrepancy;\n    }\n\n    rows.push({\n      width: containerWidth,\n      height: rowHeight,\n      gap,\n      images: currentRow,\n      imageWidths: adjustedWidths, // Use adjusted widths\n      offset: 0,\n    });\n    // --- End finalize last row ---\n  }\n\n  return rows;\n};\n\n// Helper function to create a centered row\nconst createCenteredRow = (\n  images: ImageInfo[],\n  containerWidth: number,\n  zoom: number,\n  gap: number\n): RowConfig => {\n  const aspectRatios = batchProcessAspectRatios(images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  // Calculate row height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n\n  // Calculate image widths based on aspect ratios and available width\n  const imageWidths = aspectRatios.map(ratio => Math.floor(idealHeight * ratio));\n\n  // Calculate actual total width including gaps\n  const totalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n\n  // Distribute any remaining pixels to prevent rounding issues\n  const remainingPixels = containerWidth - totalWidth;\n  if (remainingPixels > 0 && imageWidths.length > 0) {\n    // Add remaining pixels to the first image to maintain alignment\n    imageWidths[0] += remainingPixels;\n  }\n\n  // Calculate centering offset\n  const offset = Math.floor((containerWidth - totalWidth) / 2);\n\n  return {\n    width: containerWidth,\n    height: Math.floor(idealHeight),\n    gap,\n    images,\n    imageWidths,\n    offset,\n  };\n};\n\n// Optimized row layout calculation\nexport const optimizeRowLayout = (\n  row: RowConfig,\n  containerWidth: number,\n  zoom: number\n): RowConfig => {\n  if (containerWidth <= 0) {\n    console.warn('Invalid container width detected in optimizeRowLayout');\n    return row;\n  }\n\n  const cacheKey = generateCacheKey(row.images, containerWidth, zoom, 'row');\n  const cachedLayout = rowLayoutCache.get(cacheKey, containerWidth);\n  if (cachedLayout) {\n    return cachedLayout;\n  }\n\n  const normalizedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));\n  const baseGap = calculateGapSize(normalizedZoom);\n\n  // Ensure integer gaps to prevent rounding issues\n  const gap = Math.round(baseGap);\n\n  // Calculate total gap width for all spaces between images\n  const totalGapWidth = Math.max(0, (row.images.length - 1) * gap);\n\n  // Calculate actual width available for images by subtracting all gaps\n  const availableWidth = Math.max(0, containerWidth - totalGapWidth);\n\n  const aspectRatios = batchProcessAspectRatios(row.images);\n  const totalAspectRatio = aspectRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n  // Calculate ideal height based on available width for images only\n  const idealHeight = availableWidth / totalAspectRatio;\n  const minRequiredHeight = (MIN_IMAGE_WIDTH * zoom) / Math.max(...aspectRatios);\n  const maxAllowedHeight = availableWidth / totalAspectRatio;\n  const rowHeight = Math.round(\n    Math.max(minRequiredHeight, Math.min(maxAllowedHeight, idealHeight))\n  );\n\n  // Calculate initial image widths based on aspect ratios\n  const imageWidths = aspectRatios.map(ratio => Math.floor(rowHeight * ratio));\n\n  // Calculate total width of all images\n  const totalImageWidth = imageWidths.reduce((sum, width) => sum + width, 0);\n\n  // Calculate the remaining width to distribute\n  const remainingWidth = availableWidth - totalImageWidth;\n\n  if (remainingWidth !== 0 && imageWidths.length > 0) {\n    // Distribute remaining width evenly among all images\n    const widthPerImage = Math.floor(remainingWidth / imageWidths.length);\n    const extraPixels = remainingWidth % imageWidths.length;\n\n    // Add base distribution to all images\n    imageWidths.forEach((_, index) => {\n      imageWidths[index] += widthPerImage;\n    });\n\n    // Add any extra pixels to the first few images\n    for (let i = 0; i < extraPixels; i++) {\n      imageWidths[i] += 1;\n    }\n  }\n\n  // Verify total width matches container width exactly\n  const finalTotalWidth = imageWidths.reduce((sum, width) => sum + width, 0) + totalGapWidth;\n  if (finalTotalWidth !== containerWidth && imageWidths.length > 0) {\n    // Add any remaining pixels to the first image\n    const diff = containerWidth - finalTotalWidth;\n    imageWidths[0] += diff;\n  }\n\n  const optimizedRow = {\n    ...row,\n    width: containerWidth,\n    height: rowHeight,\n    gap,\n    imageWidths,\n  };\n\n  rowLayoutCache.set(cacheKey, optimizedRow, containerWidth);\n  return optimizedRow;\n};\n\n// Layout calculation for different view modes\nexport const calculateLayout = (config: LayoutConfig) => {\n  const { containerWidth, zoom, viewMode, isGrouped } = config;\n  const columns = calculateColumns(containerWidth, zoom);\n  const gap = calculateGapSize(zoom);\n\n  return {\n    columns,\n    gap,\n    minImageWidth: MIN_IMAGE_WIDTH * zoom,\n    maxImageWidth: containerWidth / columns - gap,\n  };\n};\n\n// Utility function for maintaining aspect ratio\nexport const maintainAspectRatio = (\n  image: ImageInfo,\n  containerWidth: number,\n  containerHeight: number\n): { width: number; height: number } => {\n  const imgRatio = getAspectRatio(image);\n  const containerRatio = containerWidth / containerHeight;\n  let width: number;\n  let height: number;\n\n  if (imgRatio > containerRatio) {\n    // Image is wider than container\n    width = containerWidth;\n    height = width / imgRatio;\n  } else {\n    // Image is taller than container\n    height = containerHeight;\n    width = height * imgRatio;\n  }\n\n  return { width: Math.round(width), height: Math.round(height) };\n};\n","import { Variants } from 'framer-motion';\r\n\r\n// Type alias for clarity\r\ntype TweenVars = gsap.TweenVars;\r\n\r\n// --- Framer Motion Variants ---\r\n\r\nexport const motionVariants = {\r\n  fadeIn: {\r\n    initial: { opacity: 0, y: 10 },\r\n    animate: { opacity: 1, y: 0 },\r\n    exit: { opacity: 0, y: -10 },\r\n    // Transition properties are typically applied on the motion component itself\r\n    // or within the transition prop, not directly in the variant definition.\r\n  } satisfies Variants,\r\n\r\n  hoverPop: {\r\n    rest: { scale: 1 },\r\n    hover: { scale: 1.05 },\r\n    // Transition properties like stiffness/damping go on the motion component\r\n  } satisfies Variants,\r\n\r\n  // Add more presets as needed...\r\n  // e.g., enterFromBottom, slideInLeft, pulse, etc.\r\n};\r\n\r\n// --- GSAP Configuration Objects ---\r\n// Note: These are simplified examples. You might need more complex configs\r\n// depending on how you integrate them into the pipeline later.\r\n\r\nexport const gsapConfigs = {\r\n  fadeIn: {\r\n    defaults: { duration: 0.5, ease: 'power2.out' },\r\n    vars: { opacity: 1, y: 0 },\r\n    initialVars: { opacity: 0, y: 10 }, // For setting initial state if needed\r\n  } satisfies { defaults?: TweenVars; vars: TweenVars; initialVars?: TweenVars },\r\n\r\n  hoverPop: {\r\n    defaults: { duration: 0.3, ease: 'power2.out', overwrite: 'auto' },\r\n    vars: { scale: 1.05 },\r\n    // You might need a 'rest' state config for GSAP hover-off\r\n    restVars: { scale: 1 },\r\n  } satisfies { defaults?: TweenVars; vars: TweenVars; restVars?: TweenVars },\r\n\r\n  // Add corresponding GSAP configs...\r\n};\r\n\r\n// --- Combined Type for Preset Names (ensures consistency) ---\r\nexport type MotionPresetName = keyof typeof motionVariants & keyof typeof gsapConfigs;\r\n\r\n// Helper function to get variants (example, might not be needed long-term)\r\nexport const getMotionVariant = (name: MotionPresetName): Variants => {\r\n  return motionVariants[name];\r\n};\r\n\r\n// Helper function to get GSAP config (example)\r\nexport const getGsapConfig = (name: MotionPresetName) => {\r\n  return gsapConfigs[name];\r\n};\r\n","import {\r\n  AnimationProps,\r\n  HTMLMotionProps,\r\n  motion,\r\n  TargetAndTransition,\r\n  Transition,\r\n  VariantLabels,\r\n} from 'framer-motion';\r\nimport React from 'react';\r\nimport { MotionPresetName, motionVariants } from './motionPresets';\r\n\r\n// --- Define the supported elements explicitly for type safety ---\r\ntype SupportedMotionElement =\r\n  | 'div'\r\n  | 'span'\r\n  | 'img'\r\n  | 'button'\r\n  | 'li'\r\n  | 'ul'\r\n  | 'p'\r\n  | 'h1'\r\n  | 'h2'\r\n  | 'h3';\r\n\r\nconst motionComponents: {\r\n  [key in SupportedMotionElement]: React.ComponentType<HTMLMotionProps<key>>;\r\n} = {\r\n  div: motion.div,\r\n  span: motion.span,\r\n  img: motion.img,\r\n  button: motion.button,\r\n  li: motion.li,\r\n  ul: motion.ul,\r\n  p: motion.p,\r\n  h1: motion.h1,\r\n  h2: motion.h2,\r\n  h3: motion.h3,\r\n};\r\n\r\n// Props for the MotionPreset component\r\n// Separate standard HTML/React props from MotionProps for clarity\r\ninterface BasePresetProps {\r\n  as?: SupportedMotionElement;\r\n  preset: MotionPresetName;\r\n  children?: React.ReactNode;\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n  onClick?: React.MouseEventHandler<HTMLElement>;\r\n  onMouseEnter?: React.MouseEventHandler<HTMLElement>;\r\n  onMouseLeave?: React.MouseEventHandler<HTMLElement>;\r\n}\r\n\r\n// Combine with relevant MotionProps, excluding 'variants' which we handle internally\r\ntype MotionPresetProps = BasePresetProps &\r\n  Omit<AnimationProps, 'variants'> & {\r\n    // Use AnimationProps for initial, animate, exit\r\n    // Explicitly type hover/tap/drag states\r\n    whileHover?: VariantLabels | TargetAndTransition;\r\n    whileTap?: VariantLabels | TargetAndTransition;\r\n    whileFocus?: VariantLabels | TargetAndTransition;\r\n    whileDrag?: VariantLabels | TargetAndTransition;\r\n    whileInView?: VariantLabels | TargetAndTransition;\r\n    // Allow transition prop override\r\n    transition?: Transition;\r\n    // Capture other valid HTML attributes if necessary\r\n    [key: string]: any;\r\n  };\r\n\r\nconst MotionPreset: React.FC<MotionPresetProps> = ({\r\n  as = 'div',\r\n  preset,\r\n  children,\r\n  className,\r\n  style,\r\n  onClick,\r\n  onMouseEnter,\r\n  onMouseLeave,\r\n  // Destructure AnimationProps\r\n  initial = 'initial',\r\n  animate = 'animate',\r\n  exit,\r\n  // Destructure state props\r\n  whileHover,\r\n  whileTap,\r\n  whileFocus,\r\n  whileDrag,\r\n  whileInView,\r\n  // Destructure transition\r\n  transition,\r\n  ...rest // Capture any remaining valid HTML attributes\r\n}) => {\r\n  const MotionComponent = motionComponents[as];\r\n  if (!MotionComponent) {\r\n    console.warn(`MotionPreset: Element type \"${as}\" is not supported. Defaulting to div.`);\r\n    const FallbackComponent = motion.div;\r\n    // Render children within the fallback\r\n    return (\r\n      <FallbackComponent style={style} className={className} {...rest}>\r\n        {children}\r\n      </FallbackComponent>\r\n    );\r\n  }\r\n\r\n  const variants = motionVariants[preset];\r\n\r\n  // Define default transitions based on preset\r\n  let defaultTransition: Transition = {};\r\n  if (preset === 'hoverPop') {\r\n    defaultTransition = { type: 'spring', stiffness: 300, damping: 15 };\r\n  }\r\n  if (preset === 'fadeIn') {\r\n    defaultTransition = { type: 'spring', stiffness: 120, damping: 20 };\r\n  }\r\n\r\n  const mergedTransition = transition ?? defaultTransition;\r\n\r\n  // Determine hover/tap targets safely\r\n  const hasHoverVariant = 'hover' in variants;\r\n  const hasTapVariant = 'tap' in variants;\r\n  // Use the actual variant name if available, otherwise undefined\r\n  const hoverTarget = whileHover ?? (hasHoverVariant ? 'hover' : undefined);\r\n  const tapTarget = whileTap ?? (hasTapVariant ? 'tap' : undefined);\r\n\r\n  // Note: whileFocus, whileDrag, whileInView would need similar checks\r\n  // if presets included 'focus', 'drag', or 'inView' keys.\r\n\r\n  return (\r\n    <MotionComponent\r\n      className={className}\r\n      style={style}\r\n      onClick={onClick}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseLeave={onMouseLeave}\r\n      variants={variants}\r\n      initial={initial}\r\n      animate={animate}\r\n      exit={exit} // Pass exit directly\r\n      whileHover={hoverTarget}\r\n      whileTap={tapTarget}\r\n      whileFocus={whileFocus} // Pass through directly\r\n      whileDrag={whileDrag} // Pass through directly\r\n      whileInView={whileInView} // Pass through directly\r\n      transition={mergedTransition}\r\n      {...rest} // Pass down remaining props\r\n    >\r\n      {children}\r\n    </MotionComponent>\r\n  );\r\n};\r\n\r\nexport default MotionPreset;\r\n","import { AnimatePresence, motion } from 'framer-motion';\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport MotionPreset from '../animations/MotionPreset';\nimport { ProcessedImageUpdate, useImageProcessing } from '../contexts/ImageProcessingContext';\nimport styles from '../styles/ImageItem.module.scss';\nimport { ImageInfo } from '../types/index.js';\nimport { truncateImageTitle } from '../utils/stringUtils.js';\n\n// Define hover data payload\nexport interface ImageHoverData {\n  isHovering: boolean;\n  position: { x: number; y: number } | null; // Normalized coordinates relative to viewport/background\n  color: string | null; // Dominant color of the image, if available\n  imageId: string;\n}\n\n// Type for the processed image callback data\ninterface ProcessedImageData {\n  id: string;\n  quality: 'low' | 'high';\n  processedImage: string;\n}\n\ninterface ImageItemProps {\n  image: ImageInfo;\n  onClick: (image: ImageInfo) => void;\n  containerWidth: number;\n  containerHeight: number;\n  zoom: number;\n  groupCount?: number;\n  onResize?: (width: number, height: number) => void;\n  width: number;\n  height: number;\n  isCarousel: boolean;\n  groupImages: ImageInfo[];\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColor?: string | null; // Added optional prop for color from worker\n}\n\n// Define animation variants\nconst placeholderVariants = {\n  initial: { opacity: 1, scale: 1, filter: 'blur(0px)' }, // Start fully visible\n  exit: {\n    // Animate out when isHighResLoaded becomes true\n    opacity: 0,\n    scale: 0.98, // Slight scale down\n    // filter: 'blur(10px)', // Optional blur out\n    transition: {\n      type: 'spring',\n      stiffness: 100,\n      damping: 20,\n      duration: 0.3, // Allow spring to resolve faster\n    },\n  },\n};\n\nconst imageVariants = {\n  initial: { opacity: 0, scale: 0.98 }, // Start hidden and slightly smaller\n  animate: {\n    // Animate in when isHighResLoaded becomes true\n    opacity: 1,\n    scale: 1,\n    transition: {\n      type: 'spring',\n      stiffness: 120,\n      damping: 25,\n      delay: 0.05, // Slight delay to ensure placeholder starts exiting\n    },\n  },\n};\n\n// ResponsiveImage component (Refined & Forwarding Ref)\ninterface ResponsiveImageProps {\n  src: string;\n  alt: string;\n  width?: number;\n  isProcessed: boolean;\n  onLoad: () => void;\n  onError: () => void;\n  className?: string;\n  style?: React.CSSProperties;\n  animate?: 'initial' | 'animate'; // Control animation state from parent\n}\n\nconst ResponsiveImage = React.forwardRef<HTMLImageElement, ResponsiveImageProps>(\n  (\n    { src, alt, width, isProcessed, onLoad, onError, className, style, animate = 'initial' },\n    ref\n  ) => {\n    const handleLoad = useCallback(() => {\n      onLoad();\n    }, [onLoad]);\n\n    const handleError = useCallback(() => {\n      onError();\n    }, [onError]);\n\n    const useSrcSet = !isProcessed && width && !src.startsWith('blob:');\n    const srcSet = useSrcSet\n      ? [\n          `${src}&w=${Math.round(width as number)} 1x`,\n          `${src}&w=${Math.round((width as number) * 2)} 2x`,\n          `${src}&w=${Math.round((width as number) * 3)} 3x`,\n        ].join(', ')\n      : undefined;\n    const sizes = useSrcSet ? `${Math.round(width as number)}px` : undefined;\n\n    return (\n      <motion.img\n        ref={ref}\n        key={src}\n        src={src}\n        alt={alt}\n        className={className}\n        style={style}\n        loading=\"lazy\"\n        variants={imageVariants}\n        initial=\"initial\"\n        animate={animate}\n        onLoad={handleLoad}\n        onError={handleError}\n        srcSet={srcSet}\n        sizes={sizes}\n      />\n    );\n  }\n);\nResponsiveImage.displayName = 'ResponsiveImage';\n\nconst ImageItem: React.FC<ImageItemProps> = ({\n  image,\n  onClick,\n  containerWidth,\n  containerHeight,\n  zoom = 1,\n  groupCount,\n  onResize,\n  width,\n  height,\n  isCarousel = false,\n  groupImages = [],\n  onImageHover,\n  onImageLoadError,\n  dominantColor,\n}) => {\n  const imageRef = useRef<HTMLImageElement>(null);\n  const [isHighResLoaded, setIsHighResLoaded] = useState(false);\n  const [processedUrls, setProcessedUrls] = useState<{ low?: string; high?: string }>({});\n  const [hasError, setHasError] = useState(false);\n  const { subscribeToImageUpdates } = useImageProcessing();\n\n  const placeholderColor = useMemo(() => {\n    return dominantColor || '#333';\n  }, [dominantColor]);\n\n  const targetWidth = containerWidth;\n  const targetHeight = containerHeight;\n\n  const aspectRatio = useMemo(() => {\n    if (image.width && image.height && image.width > 0 && image.height > 0) {\n      return `${image.width} / ${image.height}`;\n    }\n    if (targetWidth > 0 && targetHeight > 0) {\n      return `${targetWidth} / ${targetHeight}`;\n    }\n    return '1 / 1';\n  }, [image.width, image.height, targetWidth, targetHeight]);\n\n  useEffect(() => {\n    if (onResize) {\n      onResize(targetWidth, targetHeight);\n    }\n  }, [targetWidth, targetHeight, onResize]);\n\n  const handleMouseEnter = useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      const rect = event.currentTarget.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      const normalizedX = centerX / window.innerWidth;\n      const normalizedY = centerY / window.innerHeight;\n      onImageHover({\n        isHovering: true,\n        position: { x: normalizedX, y: normalizedY },\n        color: dominantColor || null,\n        imageId: image.id,\n      });\n    },\n    [onImageHover, image.id, dominantColor]\n  );\n\n  const handleMouseLeave = useCallback(() => {\n    onImageHover({\n      isHovering: false,\n      position: null,\n      color: null,\n      imageId: image.id,\n    });\n  }, [onImageHover, image.id]);\n\n  const handleProcessedImageUpdate = useCallback(\n    (data: ProcessedImageUpdate) => {\n      console.log(`[ImageItem ${image.id}] Received processed data via context: ${data.quality}`);\n      setProcessedUrls(prev => ({\n        ...prev,\n        [data.quality]: data.imageUrl,\n      }));\n    },\n    [image.id]\n  );\n\n  useEffect(() => {\n    const unsubscribe = subscribeToImageUpdates(image.id, handleProcessedImageUpdate);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [image.id, subscribeToImageUpdates, handleProcessedImageUpdate]);\n\n  useEffect(() => {\n    const currentLowUrl = processedUrls.low;\n    const currentHighUrl = processedUrls.high;\n    if (currentLowUrl) {\n      console.log(`[ImageItem ${image.id}] Revoking low-res blob URL on unmount: ${currentLowUrl}`);\n      URL.revokeObjectURL(currentLowUrl);\n    }\n    if (currentHighUrl) {\n      console.log(\n        `[ImageItem ${image.id}] Revoking high-res blob URL on unmount: ${currentHighUrl}`\n      );\n      URL.revokeObjectURL(currentHighUrl);\n    }\n  }, []);\n\n  const imageUrl = useMemo(() => {\n    if (hasError) return '';\n    if (processedUrls.high) return processedUrls.high;\n    if (processedUrls.low) return processedUrls.low;\n    return image.src;\n  }, [image.src, processedUrls, hasError]);\n\n  const isProcessed = !!(processedUrls.low || processedUrls.high);\n\n  const handleImageLoad = useCallback(() => {\n    if (imageUrl === processedUrls.high || (!processedUrls.high && imageUrl === image.src)) {\n      setIsHighResLoaded(true);\n    }\n    setHasError(false);\n  }, [imageUrl, processedUrls.high, image.src, image.id]);\n\n  const handleImageError = useCallback(() => {\n    console.error(`ImageItem: Failed to load image ${image.id}`, imageUrl);\n    setHasError(true);\n    onImageLoadError(image.id);\n  }, [image.id, imageUrl, onImageLoadError]);\n\n  const truncatedTitle = useMemo(\n    () => truncateImageTitle(image.alt || image.title || 'Untitled'),\n    [image.alt, image.title]\n  );\n\n  return (\n    <MotionPreset\n      as=\"div\"\n      preset=\"hoverPop\"\n      className={`${styles.imageItem} group`}\n      layout\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      onClick={() => onClick(image)}\n      style={{\n        position: 'relative',\n        width: `${width}px`,\n        height: `${height}px`,\n        overflow: 'hidden',\n        cursor: 'pointer',\n        aspectRatio: aspectRatio,\n      }}\n      initial={false}\n      animate={false}\n    >\n      <AnimatePresence>\n        {!isHighResLoaded && !hasError && (\n          <motion.div\n            key=\"placeholder\"\n            className={styles.placeholder}\n            style={{ '--placeholder-color': placeholderColor } as React.CSSProperties}\n            variants={placeholderVariants}\n            initial=\"initial\"\n            exit=\"exit\"\n          />\n        )}\n      </AnimatePresence>\n\n      {!hasError && imageUrl && (\n        <ResponsiveImage\n          ref={imageRef}\n          key={imageUrl}\n          src={imageUrl}\n          alt={image.alt ?? ''}\n          width={targetWidth}\n          isProcessed={isProcessed}\n          onLoad={handleImageLoad}\n          onError={handleImageError}\n          className={`${styles.imageElement}`}\n          style={{ position: 'absolute', inset: 0 }}\n          animate={isHighResLoaded ? 'animate' : 'initial'}\n        />\n      )}\n\n      {hasError && <div className={styles.errorIndicator}>Error</div>}\n\n      {!hasError && (\n        <motion.div\n          className={styles.overlay}\n          initial={{ opacity: 0 }}\n          whileHover={{ opacity: 1 }}\n          transition={{ duration: 0.2 }}\n        >\n          <p className={styles.title}>{truncatedTitle}</p>\n        </motion.div>\n      )}\n\n      {!hasError && groupCount && groupCount > 1 && (\n        <div className={styles.groupIndicator}>{groupCount}</div>\n      )}\n    </MotionPreset>\n  );\n};\n\nexport default memo(ImageItem);\n","export function truncateImageTitle(title: string | undefined): string {\n  if (!title) return 'Untitled';\n\n  // Remove file extensions and common suffixes anywhere in the string\n  const cleanTitle = title\n    // Remove file extensions and version numbers\n    .replace(/\\.(preview|thumbnail|jpg|jpeg|png|gif|webp)/gi, '')\n    .replace(/[-_.](v\\d+|example|intro|concept)[-_.]?\\d*/gi, '')\n    // Remove technical suffixes and common patterns\n    .replace(/[-_.]?(flux|lora|ai|toolkit|preview|example\\d*|poster)[-_.]?/gi, ' ')\n    // Remove numbered suffixes like .0, .1, .2\n    .replace(/\\.\\d+$/, '')\n    // Remove long number sequences and IDs\n    .replace(/[-_.]?\\d{6,}[-_.]?/g, '')\n    // Remove underscore/dash/dot between numbers\n    .replace(/(\\d)[-_.](\\d)/g, '$1$2')\n    // Remove numbers at the end of titles (like \"Character Style 1\")\n    .replace(/\\s+\\d+$/, '')\n    // Clean up remaining underscores, dashes, dots and extra spaces\n    .replace(/[-_.]+/g, ' ')\n    .replace(/\\s+/g, ' ');\n\n  // Split into words and properly capitalize each word\n  const formattedTitle = cleanTitle\n    .split(' ')\n    .map(word => {\n      // Keep acronyms uppercase, capitalize first letter of other words\n      return word.match(/^[A-Z]{2,}$/)\n        ? word\n        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ')\n    .trim();\n\n  // Truncate if necessary\n  const maxLength = 30;\n  return formattedTitle.length > maxLength\n    ? formattedTitle.substring(0, maxLength) + '...'\n    : formattedTitle;\n}\n","import { motion, useAnimation, Variants } from 'framer-motion';\nimport React, { useRef } from 'react';\nimport styles from '../styles/ImageRow.module.scss';\nimport { ImageInfo } from '../types/index.js';\n// import { createImageProcessor } from '../workers/imageProcessor'; // No longer needed directly\nimport WorkerPool from '../workers/workerPool'; // Import WorkerPool type\nimport ImageItem, { ImageHoverData } from './ImageItem.js';\n\n// Define the props interface for the ImageRow component\ninterface ImageRowProps {\n  images: ImageInfo[];\n  imageWidths: number[];\n  onImageClick: (clickedImage: ImageInfo) => void;\n  columns: number;\n  zoom: number;\n  isLastRow: boolean;\n  rowHeight: number;\n  groupedImages: { key: string; images: ImageInfo[]; isCarousel: boolean }[];\n  workerPool: WorkerPool;\n  gap: number;\n  containerWidth: number;\n  onImageHover: (data: ImageHoverData) => void;\n  onImageLoadError: (imageId: string) => void;\n  dominantColorMap?: Map<string, string>; // Added optional prop for colors\n}\n\n// Define a smoother transition for layout animations using a soft spring\nconst smoothLayoutTransition = {\n  type: 'spring', // Back to spring for a more natural feel\n  stiffness: 120, // Lower stiffness for less aggression\n  damping: 30, // Higher damping to reduce oscillation\n  mass: 1, // Standard mass\n  // Removed tween-specific parameters\n};\n\n// Define variants for item entrance animation\nconst itemVariants: Variants = {\n  hidden: { opacity: 0, scale: 0.95 },\n  visible: (i: number) => ({\n    // Accept custom data (index)\n    opacity: 1,\n    scale: 1,\n    transition: {\n      delay: i * 0.03, // Stagger the animation based on index\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  }),\n};\n\n// Define the ImageRow component\nconst ImageRow: React.FC<ImageRowProps> = ({\n  images,\n  imageWidths,\n  onImageClick,\n  columns,\n  zoom,\n  isLastRow,\n  rowHeight,\n  groupedImages,\n  workerPool,\n  gap,\n  containerWidth,\n  onImageHover,\n  onImageLoadError,\n  dominantColorMap, // Destructure the new prop\n}) => {\n  const rowRef = useRef<HTMLDivElement>(null);\n  const controls = useAnimation();\n\n  if (\n    !images ||\n    images.length === 0 ||\n    !imageWidths ||\n    imageWidths.length !== images.length ||\n    rowHeight <= 0\n  ) {\n    return null;\n  }\n\n  return (\n    <motion.div\n      ref={rowRef}\n      className={styles.imageRow}\n      animate={controls}\n      initial={false}\n      style={{\n        display: 'flex',\n        flexWrap: 'nowrap',\n        overflow: 'hidden',\n        gap: `${gap}px`,\n        height: `${rowHeight}px`,\n        marginBottom: `${gap}px`,\n        position: 'relative',\n        willChange: 'transform',\n        width: '100%',\n        maxWidth: `${containerWidth}px`,\n        justifyContent: 'flex-start',\n        alignItems: 'stretch',\n      }}\n      layout\n      transition={smoothLayoutTransition}\n    >\n      {images.map((image, index) => {\n        const group = groupedImages.find(g => g.images.some(img => img.id === image.id));\n        const width = imageWidths[index];\n\n        if (width === undefined || width <= 0) {\n          console.warn(\n            `Invalid width (${width}) calculated for image ${image.id} at index ${index}`\n          );\n          return null;\n        }\n\n        // Get the dominant color for this specific image from the map\n        const dominantColor = dominantColorMap?.get(image.id);\n\n        return (\n          <motion.div\n            key={image.id}\n            className={styles.imageWrapper}\n            custom={index}\n            initial=\"hidden\"\n            animate=\"visible\"\n            variants={itemVariants}\n            style={{\n              width: `${width}px`,\n              height: `${rowHeight}px`,\n              flexShrink: 0,\n              flexGrow: 0,\n              position: 'relative',\n              overflow: 'hidden',\n            }}\n            layout\n            transition={smoothLayoutTransition}\n          >\n            <ImageItem\n              image={image}\n              onClick={() => onImageClick(image)}\n              containerWidth={width}\n              containerHeight={rowHeight}\n              width={width}\n              height={rowHeight}\n              zoom={zoom}\n              isCarousel={group?.isCarousel || false}\n              groupImages={group?.images || []}\n              onImageHover={onImageHover}\n              onImageLoadError={onImageLoadError}\n              dominantColor={dominantColor} // Pass the specific color down\n            />\n          </motion.div>\n        );\n      })}\n    </motion.div>\n  );\n};\n\n// Export the memoized component\nexport default React.memo(ImageRow);\n","import React from 'react';\nimport styles from '../styles/ImageItem.module.scss';\n\ninterface ImageSkeletonProps {\n  containerWidth: number;\n  containerHeight: number;\n  placeholderColor?: string;\n}\n\nconst ImageSkeleton: React.FC<ImageSkeletonProps> = ({\n  containerWidth,\n  containerHeight,\n  placeholderColor,\n}) => {\n  const backgroundStyle = placeholderColor ? { backgroundColor: placeholderColor } : {};\n\n  return (\n    <div\n      className={`${styles.imageItem} ${styles.imageSkeleton}`}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        maxWidth: '100%',\n        maxHeight: '100%',\n        aspectRatio: `${containerWidth} / ${containerHeight}`,\n        ...backgroundStyle,\n      }}\n    >\n      <div className={styles.skeletonAnimation}></div>\n    </div>\n  );\n};\n\nexport default ImageSkeleton;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport { motion } from 'framer-motion';\n\ninterface BannerViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst BannerView: React.FC<BannerViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  return (\n    <div className=\"banner-view space-y-4\">\n      {images.map((image, index) => (\n        <motion.div\n          key={image.id}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.5, delay: index * 0.1 }}\n          className=\"banner-item relative\"\n        >\n          <div\n            className=\"banner-image-container w-full h-[300px] rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-shadow duration-300\"\n            style={{ height: `${300 * zoom}px` }}\n          >\n            <img src={image.src} alt={image.alt} className=\"w-full h-full object-cover\" />\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n              <p className=\"text-white/80 text-sm\">\n                {image.width}  {image.height}\n              </p>\n            </div>\n          </div>\n        </motion.div>\n      ))}\n    </div>\n  );\n};\n\nexport default BannerView;\n","import React from 'react';\nimport { ImageInfo } from '../../types';\nimport Slider from 'react-slick';\nimport { motion } from 'framer-motion';\nimport { FaChevronLeft, FaChevronRight } from 'react-icons/fa';\n\ninterface CarouselViewProps {\n  images: ImageInfo[];\n  zoom: number;\n}\n\nconst NextArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute right-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronRight />\n    </button>\n  );\n};\n\nconst PrevArrow = (props: any) => {\n  const { onClick } = props;\n  return (\n    <button\n      onClick={onClick}\n      className=\"absolute left-4 top-1/2 -translate-y-1/2 z-10 bg-black/50 hover:bg-black/70 text-white p-3 rounded-full transition-colors duration-300\"\n    >\n      <FaChevronLeft />\n    </button>\n  );\n};\n\nconst CarouselView: React.FC<CarouselViewProps> = ({ images, zoom }) => {\n  if (!images.length) {\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\n  }\n\n  const settings = {\n    dots: true,\n    infinite: true,\n    speed: 500,\n    slidesToShow: 1,\n    slidesToScroll: 1,\n    nextArrow: <NextArrow />,\n    prevArrow: <PrevArrow />,\n    adaptiveHeight: true,\n    customPaging: (i: number) => (\n      <div className=\"w-3 h-3 mx-1 rounded-full bg-white/50 hover:bg-white/70 transition-colors duration-300\" />\n    ),\n  };\n\n  return (\n    <div className=\"carousel-view\">\n      <Slider {...settings}>\n        {images.map((image, index) => (\n          <motion.div\n            key={image.id}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ duration: 0.5 }}\n            className=\"outline-none\"\n          >\n            <div className=\"relative aspect-video\">\n              <img\n                src={image.src}\n                alt={image.alt}\n                className=\"w-full h-full object-contain\"\n                style={{\n                  maxHeight: `${600 * zoom}px`,\n                }}\n              />\n              <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4\">\n                <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\n                <p className=\"text-white/80 text-sm\">\n                  {image.width}  {image.height}\n                </p>\n              </div>\n            </div>\n          </motion.div>\n        ))}\n      </Slider>\n    </div>\n  );\n};\n\nexport default CarouselView;\n","import React from 'react';\r\nimport { ImageInfo } from '../../types';\r\nimport Masonry from 'react-masonry-css';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface MasonryViewProps {\r\n  images: ImageInfo[];\r\n  zoom: number;\r\n}\r\n\r\nconst MasonryView: React.FC<MasonryViewProps> = ({ images, zoom }) => {\r\n  const breakpointColumns = {\r\n    default: 4,\r\n    1536: 4,\r\n    1280: 3,\r\n    1024: 3,\r\n    768: 2,\r\n    640: 1,\r\n  };\r\n\r\n  if (!images.length) {\r\n    return <div className=\"text-center text-gray-500 mt-8\">No images to display</div>;\r\n  }\r\n\r\n  return (\r\n    <Masonry\r\n      breakpointCols={breakpointColumns}\r\n      className=\"flex -ml-4 w-auto\"\r\n      columnClassName=\"pl-4 bg-clip-padding\"\r\n    >\r\n      {images.map((image, index) => (\r\n        <motion.div\r\n          key={image.id}\r\n          initial={{ opacity: 0, scale: 0.9 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          transition={{ duration: 0.5, delay: index * 0.1 }}\r\n          className=\"mb-4\"\r\n        >\r\n          <div className=\"relative group rounded-lg overflow-hidden shadow-md hover:shadow-xl transition-shadow duration-300\">\r\n            <img\r\n              src={image.src}\r\n              alt={image.alt}\r\n              className=\"w-full h-auto\"\r\n              style={{\r\n                maxHeight: `${400 * zoom}px`,\r\n                objectFit: 'cover',\r\n              }}\r\n            />\r\n            <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4 transform translate-y-full group-hover:translate-y-0 transition-transform duration-300\">\r\n              <h3 className=\"text-white text-lg font-semibold\">{image.title}</h3>\r\n              <p className=\"text-white/80 text-sm\">\r\n                {image.width}  {image.height}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </motion.div>\r\n      ))}\r\n    </Masonry>\r\n  );\r\n};\r\n\r\nexport default MasonryView;\r\n","import { useVirtualizer } from '@tanstack/react-virtual';\nimport { motion } from 'framer-motion';\nimport React, {\n  CSSProperties,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport Lightbox from 'yet-another-react-lightbox';\nimport Captions from 'yet-another-react-lightbox/plugins/captions';\nimport 'yet-another-react-lightbox/plugins/captions.css';\nimport Counter from 'yet-another-react-lightbox/plugins/counter';\nimport 'yet-another-react-lightbox/plugins/counter.css';\nimport Thumbnails from 'yet-another-react-lightbox/plugins/thumbnails';\nimport 'yet-another-react-lightbox/plugins/thumbnails.css';\nimport Zoom from 'yet-another-react-lightbox/plugins/zoom';\nimport 'yet-another-react-lightbox/styles.css';\nimport { ColorContext } from '../contexts/ColorContext';\nimport { useImageProcessing } from '../contexts/ImageProcessingContext';\nimport { useFolderImages } from '../hooks/query/useFolderImages';\nimport { usePrefetchManager } from '../hooks/usePrefetchManager.js';\nimport useWindowSize from '../hooks/useWindowSize.js';\nimport { loadScrollState, saveScrollState, ScrollState } from '../lib/cache/feedStateCache';\nimport styles from '../styles/ImageFeed.module.scss';\nimport { ImageInfo, ViewMode } from '../types/index.js';\nimport AnimationSystem from '../utils/AnimationSystem';\nimport {\n  calculateGapSize,\n  calculateLayout,\n  LayoutConfig,\n  MIN_IMAGE_WIDTH,\n  RowConfig,\n} from '../utils/layoutCalculator';\nimport WorkerPool, { WorkerType } from '../workers/workerPool';\nimport AuraBackground from './AuraBackground';\nimport { ImageHoverData } from './ImageItem.js';\nimport ImageRow from './ImageRow.js';\nimport ImageSkeleton from './ImageSkeleton.js';\nimport { BannerView, CarouselView, MasonryView } from './views';\n\n// Simple throttle function\nfunction throttle<F extends (...args: any[]) => any>(func: F, limit: number) {\n  let inThrottle: boolean;\n  let lastResult: ReturnType<F>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const throttled = function (this: ThisParameterType<F>, ...args: Parameters<F>): void {\n    const context = this;\n    if (!inThrottle) {\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n      // Call the function but don't worry about returning its result for listener\n      func.apply(context, args);\n    }\n    // Explicitly return void for listener compatibility\n    // return lastResult; // Removed potentially problematic return\n  };\n\n  return throttled;\n}\n\n// Simple debounce function (with cancel)\nfunction debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = (...args: Parameters<F>) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => func(...args), waitFor);\n  };\n\n  // Add the cancel method\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null; // Clear the ID after cancelling\n    }\n  };\n\n  return debounced as F & { cancel: () => void };\n}\n\n// Define the props interface for ImageFeed component\ninterface ImageFeedProps {\n  folderPath: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: React.RefObject<HTMLElement>;\n}\n\ninterface CustomStyle extends CSSProperties {\n  '--energy-color'?: string;\n  '--ripple-x'?: string;\n  '--ripple-y'?: string;\n  '--ripple-strength'?: string;\n}\n\n// Interface for messages from ColorExtractorWorker\ninterface ColorResultData {\n  id: string;\n  color: string | null;\n}\n\n// Interface for messages from GroupingWorker\ninterface ImageGroup {\n  key: string;\n  images: ImageInfo[];\n  isCarousel: boolean;\n}\ninterface GroupingResultData {\n  groupedImages: ImageGroup[];\n}\n\n// Define payload TYPESCRIPT INTERFACES for worker requests if needed for clarity,\n// but use component's internal types for results where appropriate.\ninterface GroupingRequestPayload {\n  images: ImageInfo[];\n  isGrouped: boolean;\n}\ninterface LayoutRequestPayload {\n  images: ImageInfo[];\n  containerWidth: number;\n  zoom: number;\n  targetRowHeight: number;\n}\ninterface ColorRequestPayload {\n  id: string;\n  src: string;\n}\n// Define the TYPE for the expected successful PAYLOAD from the color worker\n// Align this with what the color worker actually sends back in its payload\ninterface ColorWorkerSuccessPayload {\n  id: string;\n  color: string | null;\n}\n\n// Define the ImageFeed component\nconst ImageFeed: React.FC<ImageFeedProps> = ({\n  folderPath,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  const {\n    data: originalImages,\n    isLoading: isLoadingImages,\n    isError,\n    error,\n    isPlaceholderData,\n  } = useFolderImages(folderPath);\n\n  const windowSize = useWindowSize();\n  const feedRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [columns, setColumns] = useState(4);\n  const [lightboxIndex, setLightboxIndex] = useState<number>(-1);\n  const [lightboxImages, setLightboxImages] = useState<ImageInfo[]>([]);\n  const animationSystem = useMemo(() => AnimationSystem.getInstance(), []);\n  const { setDominantColors, setHoverState } = useContext(ColorContext);\n  const [dominantColorMap, setDominantColorMap] = useState<Map<string, string>>(new Map());\n  const requestedColorIds = useRef<Set<string>>(new Set());\n  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const [restoredState, setRestoredState] = useState<ScrollState | null>(null);\n  const previousFolderPathRef = useRef<string | null>(null);\n  const rowHeightsRef = useRef<number[]>([]);\n  const isRestoringScrollRef = useRef(false);\n  const velocityEMARef = useRef(0);\n  const OVERSCAN_BASE = 3;\n  const OVERSCAN_MAX = 15;\n  const EMA_ALPHA = 0.2;\n  const OVERSCAN_FACTOR = 10;\n  const [dynamicOverscan, setDynamicOverscan] = useState(OVERSCAN_BASE);\n  const [failedImageIds, setFailedImageIds] = useState<Set<string>>(new Set());\n  const { publishImageUpdate } = useImageProcessing();\n\n  // --- Define getImageUrl earlier --- >\n  const getImageUrl = useCallback((imagePath: string) => {\n    let path = imagePath.replace(/\\\\/g, '/');\n    if (path.startsWith('/api/image/') || path.startsWith('/')) {\n      return path;\n    }\n    return `/api/image/${path}`;\n  }, []); // Empty dependency array, safe to define early\n\n  // --- Memoized Images & Failed Image Handling --- >\n  const images = useMemo(() => {\n    if (!originalImages) return [];\n    return originalImages.filter(img => img && !failedImageIds.has(img.id)); // Added check for img existence\n  }, [originalImages, failedImageIds]);\n\n  const handleImageLoadError = useCallback((imageId: string) => {\n    setFailedImageIds(prev => {\n      if (prev.has(imageId)) return prev;\n      console.log(`ImageFeed: Registering error for image ${imageId}`);\n      const newSet = new Set(prev);\n      newSet.add(imageId);\n      return newSet;\n    });\n  }, []);\n\n  // --- Worker Pool --- >\n  const workerPool = useMemo(() => WorkerPool.getInstance(), []);\n\n  // --- State for Worker Operations --- >\n  const [calculatedRows, setCalculatedRows] = useState<RowConfig[]>([]);\n  const [isLayoutCalculating, setIsLayoutCalculating] = useState(false);\n  const [processedGroupedImages, setProcessedGroupedImages] = useState<ImageGroup[]>([]);\n  const [isGrouping, setIsGrouping] = useState(false);\n  // Flag to track if an async operation is currently active for a worker type\n  const activeRequestRef = useRef<{ [key in WorkerType]?: boolean }>({});\n\n  // --- Layout Data Map --- >\n  const layoutDataMap = useMemo(() => {\n    const map = new Map<string, { top: number; left: number; width: number; height: number }>();\n    let currentTop = 0;\n    const gap = calculateGapSize(zoom);\n    calculatedRows.forEach(row => {\n      let currentLeft = 0;\n      row.images.forEach((img, index) => {\n        if (!row.imageWidths || row.imageWidths.length <= index) {\n          console.warn(`[ImageFeed] Missing imageWidths for image ${img.id} in row.`);\n          return; // Skip this image if width data is missing\n        }\n        const width = row.imageWidths[index];\n        map.set(img.id, {\n          top: currentTop,\n          left: currentLeft,\n          width: width,\n          height: row.height,\n        });\n        currentLeft += width + gap;\n      });\n      currentTop += row.height + gap;\n    });\n    return map;\n  }, [calculatedRows, zoom]);\n\n  // --- Initialize Prefetch Manager --- >\n  // Only initialize if we have images and the necessary layout data\n  usePrefetchManager({\n    scrollContainerRef,\n    imageList: images, // Use the filtered images\n    layoutData: layoutDataMap,\n    // We can add configuration options here later (lookaheadDistance, concurrency)\n  });\n\n  // --- Debouncing Logic for isGrouped ---\n  const [debouncedIsGrouped, setDebouncedIsGrouped] = useState(isGrouped);\n  const updateDebouncedGrouped = useCallback(\n    // Use the local debounce function now\n    debounce((newValue: boolean) => {\n      setDebouncedIsGrouped(newValue);\n      console.log('[ImageFeed] Applying debounced isGrouped:', newValue);\n    }, 300), // 300ms debounce delay\n    [] // No dependencies needed as debounce is defined outside/statically\n  );\n  useEffect(() => {\n    updateDebouncedGrouped(isGrouped);\n    // Access the cancel method correctly\n    return () => updateDebouncedGrouped.cancel();\n  }, [isGrouped, updateDebouncedGrouped]);\n\n  // --- Scroll Persistence Logic ---\n\n  // Debounced function to save scroll state during active scroll\n  const debouncedSaveScroll = useCallback(\n    debounce((path: string, scroll: number /*, heights: number[], width: number */) => {\n      if (path && !isRestoringScrollRef.current) {\n        saveScrollState(path, scroll);\n      }\n    }, 500),\n    []\n  );\n\n  // Load state on mount/folder change & Save state on unmount/folder change\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadAndSetState = async () => {\n      const loadedState = await loadScrollState(folderPath);\n      if (isMounted) {\n        if (loadedState) {\n          setRestoredState(loadedState);\n          isRestoringScrollRef.current = true;\n        } else {\n          setRestoredState(null);\n          if (scrollContainerRef.current) {\n            scrollContainerRef.current.scrollTop = 0;\n          }\n          isRestoringScrollRef.current = false;\n        }\n      }\n    };\n\n    loadAndSetState();\n\n    const currentPathForCleanup = folderPath;\n    previousFolderPathRef.current = currentPathForCleanup;\n\n    return () => {\n      isMounted = false;\n      const scrollElement = scrollContainerRef.current;\n      const folderToSave = previousFolderPathRef.current;\n\n      if (scrollElement && folderToSave && rowHeightsRef.current.length > 0) {\n        saveScrollState(folderToSave, scrollElement.scrollTop);\n      }\n\n      debouncedSaveScroll.cancel?.();\n      // --- Cancel All Pending Worker Tasks on Unmount --- >\n      console.log('ImageFeed: Unmounting, cancelling all pending worker tasks.');\n      workerPool.cancelAllPendingTasks();\n      // No need to remove listeners here as they are not used for request/response\n    };\n  }, [\n    folderPath,\n    scrollContainerRef,\n    debouncedSaveScroll,\n    workerPool, // Add workerPool as dependency for cleanup\n  ]);\n  // --- End Scroll Persistence Logic ---\n\n  // --- Compute Stable Keys for Memoization --- >\n  const imagesKey = useMemo(() => images.map(i => i.id).join('|'), [images]);\n\n  // --- Avg Aspect Ratio & Layout Metrics (unchanged) --- >\n  const avgAspectRatio = useMemo(() => {\n    if (!originalImages || originalImages.length === 0) return 1; // Default aspect ratio\n    const validImages = originalImages.filter(img => img && img.width > 0 && img.height > 0);\n    if (validImages.length === 0) return 1;\n    const totalRatio = validImages.reduce((sum, img) => sum + img.width / img.height, 0);\n    return totalRatio / validImages.length;\n  }, [originalImages]);\n\n  const layoutMetrics = useMemo(() => {\n    const gapSize = calculateGapSize(zoom);\n    let estimatedRowHeightFallback = 200; // Default\n    if (containerWidth > 0 && columns > 0 && avgAspectRatio > 0) {\n      const totalGapWidth = Math.max(0, columns - 1) * gapSize;\n      const availableWidthForImages = Math.max(0, containerWidth - totalGapWidth);\n      if (availableWidthForImages > 0) {\n        const estimatedAvgImageWidth = availableWidthForImages / columns;\n        estimatedRowHeightFallback = Math.max(\n          50,\n          Math.round(estimatedAvgImageWidth / avgAspectRatio)\n        );\n      }\n    }\n    return {\n      gapSize,\n      estimatedRowHeightFallback,\n    };\n  }, [containerWidth, columns, zoom, avgAspectRatio]);\n\n  // --- Memoize Layout Inputs --- >\n  const layoutInputs = useMemo(\n    () => ({\n      imagesKey,\n      containerWidth,\n      zoom,\n      viewMode,\n      isGrouped: debouncedIsGrouped,\n      // Include estimated height as it affects the worker call\n      targetRowHeight: layoutMetrics.estimatedRowHeightFallback,\n    }),\n    [\n      imagesKey,\n      containerWidth,\n      zoom,\n      viewMode,\n      debouncedIsGrouped,\n      layoutMetrics.estimatedRowHeightFallback,\n    ]\n  );\n\n  // --- UPDATED: Reset/Cancel Effect --- >\n  useEffect(() => {\n    setLightboxIndex(-1);\n    setLightboxImages([]);\n    setDominantColorMap(new Map());\n    requestedColorIds.current.clear();\n    setFailedImageIds(new Set());\n    setCalculatedRows([]);\n    setIsLayoutCalculating(false); // Reset loading state\n    setProcessedGroupedImages([]);\n    setIsGrouping(false); // Reset loading state\n\n    console.log(\n      `ImageFeed: Deps changed (${folderPath}/${viewMode}/${isGrouped}/${zoom}), cancelling pending worker tasks.`\n    );\n    // Cancel tasks related to the previous state\n    workerPool.cancelAllPendingTasks();\n    activeRequestRef.current = {}; // Reset active request flags\n  }, [folderPath, viewMode, isGrouped, zoom, workerPool]); // isGrouped and zoom trigger cancellation now\n\n  // --- Container Width Management (UPDATED: Use debounce) --- >\n  const updateContainerWidthInternal = useCallback(() => {\n    if (!feedRef.current) return;\n    const rect = feedRef.current.getBoundingClientRect();\n    const newWidth = Math.max(MIN_IMAGE_WIDTH, rect.width);\n    setContainerWidth(prevWidth => {\n      if (newWidth !== prevWidth) {\n        const config: LayoutConfig = {\n          containerWidth: newWidth,\n          zoom,\n          viewMode,\n          isGrouped: debouncedIsGrouped, // Use debounced value here\n        };\n        const layout = calculateLayout(config);\n        setColumns(layout.columns);\n        return newWidth;\n      }\n      return prevWidth;\n    });\n  }, [zoom, viewMode, debouncedIsGrouped]); // Keep dependencies of the internal logic\n\n  // --- Memoize the debounced function --- >\n  const debouncedUpdateContainerWidth = useMemo(\n    () => debounce(updateContainerWidthInternal, 100), // 100ms debounce\n    [updateContainerWidthInternal] // Recreate debounce only if internal logic changes\n  );\n\n  // --- Use the debounced function in effects --- >\n  useLayoutEffect(() => {\n    // Run immediately on mount\n    updateContainerWidthInternal();\n    // Ensure cleanup cancels the debounced call\n    return () => debouncedUpdateContainerWidth.cancel();\n  }, [updateContainerWidthInternal, debouncedUpdateContainerWidth]); // Add debounced func to deps\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(debouncedUpdateContainerWidth); // Use debounced version\n    if (feedRef.current) {\n      resizeObserver.observe(feedRef.current);\n    }\n    // Still use the debounced version for window resize\n    window.addEventListener('resize', debouncedUpdateContainerWidth);\n    return () => {\n      resizeObserver.disconnect();\n      window.removeEventListener('resize', debouncedUpdateContainerWidth);\n      debouncedUpdateContainerWidth.cancel(); // Cancel on unmount\n    };\n  }, [debouncedUpdateContainerWidth]); // Depend only on the stable debounced function reference\n  // --- End Container Width Management ---\n\n  // --- Effect for Pre-fetching Placeholder Colors (Now safe to use getImageUrl) --- >\n  useEffect(() => {\n    if (images && images.length > 0 && !isLoadingImages) {\n      const initialImageCount = Math.min(images.length, 30);\n      console.log(`[ImageFeed] Pre-fetching colors for initial ${initialImageCount} images...`);\n\n      for (let i = 0; i < initialImageCount; i++) {\n        const imageInfo = images[i];\n        if (\n          imageInfo &&\n          imageInfo.id &&\n          imageInfo.src &&\n          !dominantColorMap.has(imageInfo.id) &&\n          !requestedColorIds.current.has(imageInfo.id)\n        ) {\n          const imageUrl = getImageUrl(imageInfo.src); // Now defined\n          requestedColorIds.current.add(imageInfo.id);\n          // ... (rest of the postRequest logic)\n          workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              { id: imageInfo.id, src: imageUrl },\n              { priority: 2 }\n            )\n            .then(result => {\n              // ... (update map)\n            })\n            .catch(error => {\n              // ... (log error)\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(imageInfo.id);\n            });\n        }\n      }\n    }\n  }, [images, isLoadingImages, workerPool, getImageUrl]); // Keep getImageUrl in deps\n\n  // --- Combined Grouping & Layout Worker Trigger (Based on Memoized Inputs) --- >\n  useEffect(() => {\n    // Destructure inputs for clarity inside the effect\n    const {\n      imagesKey, // Used implicitly by `images` dependency below\n      containerWidth,\n      zoom,\n      viewMode,\n      isGrouped,\n      targetRowHeight,\n    } = layoutInputs;\n\n    console.log(\n      '[ImageFeed] Layout inputs changed. Triggering group/layout pipeline...',\n      layoutInputs\n    );\n\n    // Cancel any previous pipeline runs\n    // Note: cancelAllPendingTasks might be too broad if other workers run independently.\n    // If needed, use specific cancel functions (e.g., cancelPendingLayoutTasks).\n    workerPool.cancelAllPendingTasks();\n    activeRequestRef.current = {}; // Reset active flags\n    setIsGrouping(true); // Indicate start of pipeline\n    if (viewMode === ViewMode.GRID) {\n      setIsLayoutCalculating(true);\n    }\n\n    // Define the pipeline\n    const runPipeline = async () => {\n      try {\n        // 1. Grouping\n        console.log('[ImageFeed] Pipeline: Requesting grouping...');\n        const groupingResult = await workerPool.postRequest<\n          GroupingRequestPayload,\n          { groupedImages: ImageGroup[] }\n        >(\n          'grouping',\n          'groupImages',\n          { images: images, isGrouped: isGrouped }, // Use current images and isGrouped from layoutInputs\n          { priority: 9 }\n        );\n        console.log('[ImageFeed] Pipeline: Received grouping result.');\n        // Update grouping state immediately (or batch if using batch hook)\n        setProcessedGroupedImages(groupingResult.groupedImages);\n        setIsGrouping(false);\n\n        // 2. Layout (only if GRID view and grouping succeeded)\n        if (viewMode === ViewMode.GRID) {\n          const firstImages = groupingResult.groupedImages\n            .map(group => group.images[0])\n            .filter(image => image && image.width > 0 && image.height > 0);\n\n          if (firstImages.length > 0 && containerWidth > 0) {\n            console.log('[ImageFeed] Pipeline: Requesting layout...');\n            const layoutResult = await workerPool.postRequest<LayoutRequestPayload, RowConfig[]>(\n              'layout',\n              'calculateLayout',\n              {\n                images: firstImages,\n                containerWidth,\n                zoom,\n                targetRowHeight,\n              },\n              { priority: 10 }\n            );\n            console.log('[ImageFeed] Pipeline: Received layout result.');\n            // Update layout state (or batch)\n            setCalculatedRows(layoutResult);\n          } else {\n            console.log(\n              '[ImageFeed] Pipeline: Skipping layout (no valid first images or zero width).'\n            );\n            setCalculatedRows([]); // Clear layout if skipped\n          }\n        } else {\n          setCalculatedRows([]); // Clear layout if not in GRID view\n        }\n      } catch (error) {\n        // Handle errors from either worker\n        console.error('[ImageFeed] Pipeline error:', error);\n        setProcessedGroupedImages([]);\n        setCalculatedRows([]);\n      } finally {\n        // Reset loading flags regardless of success/error\n        setIsGrouping(false);\n        setIsLayoutCalculating(false);\n        // Clear active refs (might need more granular control if tasks overlap)\n        activeRequestRef.current = {};\n      }\n    };\n\n    // Only run the pipeline if we have images and a valid container width\n    if (images && images.length > 0 && containerWidth > 0) {\n      runPipeline();\n    } else {\n      // If no images or width, clear states and loading flags\n      console.log('[ImageFeed] Skipping pipeline (no images or zero width).');\n      setProcessedGroupedImages([]);\n      setCalculatedRows([]);\n      setIsGrouping(false);\n      setIsLayoutCalculating(false);\n      activeRequestRef.current = {};\n    }\n\n    // Cleanup: Cancellation is handled at the start of the effect\n    // and on unmount by the main cleanup effect.\n  }, [layoutInputs, images, workerPool]); // Depend on memoized inputs, images array identity, and workerPool instance\n\n  // Define the useEffect that updates rowHeightsRef HERE, AFTER calculatedRows state\n  useEffect(() => {\n    if (viewMode === ViewMode.GRID && calculatedRows && calculatedRows.length > 0) {\n      rowHeightsRef.current = calculatedRows.map(row => row.height);\n    } else {\n      rowHeightsRef.current = [];\n    }\n  }, [calculatedRows, viewMode, folderPath]);\n\n  // Handle image overflow (wrapped in useCallback)\n  const handleImageOverflow = useCallback((image: ImageInfo) => {\n    console.warn('Image overflow detected:', image.id);\n  }, []);\n\n  // Update handleImageClick to work with grouped images and set lightbox plugins (wrapped in useCallback)\n  const handleImageClick = useCallback(\n    (clickedImage: ImageInfo) => {\n      const groupIndex = processedGroupedImages.findIndex(group =>\n        group.images.some(img => img.id === clickedImage.id)\n      );\n      if (groupIndex !== -1) {\n        const group = processedGroupedImages[groupIndex];\n        const imageIndexInGroup = group.images.findIndex(img => img.id === clickedImage.id);\n        if (imageIndexInGroup !== -1) {\n          setLightboxImages(group.images);\n          setLightboxIndex(imageIndexInGroup);\n        }\n      }\n    },\n    [processedGroupedImages]\n  );\n\n  // --- Scroll Velocity and Dynamic Overscan --- >\n  const lastScrollTopRef = useRef(0);\n  const lastScrollTimeRef = useRef(performance.now());\n\n  const handleScroll = useCallback(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (!scrollElement) return;\n\n    const now = performance.now();\n    const scrollTop = scrollElement.scrollTop;\n    const timeDelta = now - lastScrollTimeRef.current;\n    const scrollDelta = scrollTop - lastScrollTopRef.current;\n\n    if (timeDelta > 10) {\n      const velocity = Math.abs(scrollDelta) / timeDelta;\n      velocityEMARef.current = EMA_ALPHA * velocity + (1 - EMA_ALPHA) * velocityEMARef.current;\n      const calculatedOverscan =\n        OVERSCAN_BASE +\n        Math.min(velocityEMARef.current * OVERSCAN_FACTOR, OVERSCAN_MAX - OVERSCAN_BASE);\n      setDynamicOverscan(Math.round(calculatedOverscan));\n      lastScrollTopRef.current = scrollTop;\n      lastScrollTimeRef.current = now;\n      debouncedSaveScroll(folderPath, scrollTop);\n    }\n  }, [scrollContainerRef, folderPath, debouncedSaveScroll]);\n\n  // Attach scroll listener\n  useEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    if (scrollElement) {\n      // Use throttle for the scroll handler to limit frequency\n      const throttledScrollHandler = throttle(handleScroll, 100); // Throttle to ~10fps\n      scrollElement.addEventListener('scroll', throttledScrollHandler);\n      return () => scrollElement.removeEventListener('scroll', throttledScrollHandler);\n    }\n  }, [scrollContainerRef, handleScroll]);\n  // --- End Scroll Velocity Logic --- >\n\n  // --- Virtualization Setup ---\n  const rowVirtualizer = useVirtualizer({\n    count: calculatedRows.length,\n    getScrollElement: () => scrollContainerRef.current,\n    estimateSize: useCallback(\n      (index: number) => {\n        const rowHeight = calculatedRows[index]?.height ?? layoutMetrics.estimatedRowHeightFallback;\n        return rowHeight + layoutMetrics.gapSize;\n      },\n      [calculatedRows, layoutMetrics.estimatedRowHeightFallback, layoutMetrics.gapSize]\n    ),\n    overscan: dynamicOverscan,\n  });\n\n  // Remeasure rows whenever zoom, containerWidth, row count, row height fallback, gap size, view mode, or grouping changes\n  useLayoutEffect(() => {\n    rowVirtualizer.measure?.();\n  }, [\n    zoom,\n    containerWidth,\n    calculatedRows.length,\n    layoutMetrics.estimatedRowHeightFallback,\n    layoutMetrics.gapSize,\n    viewMode,\n    debouncedIsGrouped,\n    folderPath,\n    rowVirtualizer,\n  ]);\n\n  // Get the virtual items to render\n  const virtualItems = rowVirtualizer.getVirtualItems();\n\n  // --- End Virtualization Setup ---\n\n  // --- Add Scroll Restoration Effect ---\n  useLayoutEffect(() => {\n    const scrollElement = scrollContainerRef.current;\n    // Try to restore scroll only after layout is stable\n    if (isRestoringScrollRef.current && restoredState && rowHeightsRef.current.length > 0) {\n      if (scrollElement) {\n        console.log(`Restoring scroll to: ${restoredState.scrollTop}`);\n        // Wrap scroll restoration in requestAnimationFrame for smoothness\n        requestAnimationFrame(() => {\n          scrollElement.scrollTop = restoredState.scrollTop;\n          // Reset the flag *after* applying the scroll\n          isRestoringScrollRef.current = false;\n        });\n      } else {\n        isRestoringScrollRef.current = false; // Reset if element not found\n      }\n    }\n  }, [restoredState, scrollContainerRef, virtualItems, folderPath]); // Depend on restored state, ref, virtual items, and folderPath\n  // --- End Scroll Restoration Effect ---\n\n  // Callback function for image hover - with delay logic\n  const handleImageHover = useCallback(\n    (data: ImageHoverData) => {\n      // Clear any existing timeout\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n        hoverTimeoutRef.current = null;\n      }\n\n      if (data.isHovering) {\n        // Set a timeout to activate hover state after a delay\n        hoverTimeoutRef.current = setTimeout(() => {\n          // Get color from the state map if available\n          const color = dominantColorMap.get(data.imageId) || null;\n          setHoverState({ isHovering: true, position: data.position, color: color });\n        }, 150); // 150ms delay\n      } else {\n        // If mouse leaves, immediately deactivate hover state\n        setHoverState({ isHovering: false, position: null, color: null });\n      }\n    },\n    [setHoverState, dominantColorMap] // Dependency remains setHoverState\n  );\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    // Clear timeout if component unmounts\n    return () => {\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, []); // Empty dependency array ensures this runs only on mount and unmount\n\n  // --- Color Extraction Worker Integration (Add Priority for visible items) --- >\n  useEffect(() => {\n    // Only run if we have virtual items and rows calculated\n    if (virtualItems.length === 0 || calculatedRows.length === 0 || images.length === 0) {\n      return;\n    }\n\n    const visibleImageIds = new Set<string>();\n    virtualItems.forEach(virtualItem => {\n      const row = calculatedRows[virtualItem.index];\n      row?.images.forEach(img => visibleImageIds.add(img.id));\n    });\n\n    // Track promises for colors requested in this pass\n    const colorPromises: Promise<void>[] = [];\n\n    visibleImageIds.forEach(id => {\n      if (!dominantColorMap.has(id) && !requestedColorIds.current.has(id)) {\n        const imageInfo = images.find(img => img.id === id);\n        if (imageInfo?.src) {\n          const imageUrl = getImageUrl(imageInfo.src);\n          requestedColorIds.current.add(id);\n\n          const promise = workerPool\n            .postRequest<ColorRequestPayload, ColorWorkerSuccessPayload>(\n              'color',\n              'extractColor',\n              {\n                id: imageInfo.id,\n                src: imageUrl,\n              },\n              { priority: 1 }\n            )\n            .then(result => {\n              // Check result and specifically if color is a non-null string\n              if (result && typeof result.color === 'string') {\n                // Assign to a new variable to help TS with type narrowing inside the setter\n                const colorValue: string = result.color;\n                setDominantColorMap(prevMap => {\n                  const newMap = new Map(prevMap);\n                  // Use the explicitly typed colorValue\n                  newMap.set(result.id, colorValue);\n                  return newMap;\n                });\n              } else {\n                // console.log(`[ImageFeed] Color extraction failed or null for ${result?.id}`);\n              }\n            })\n            .catch(error => {\n              console.error(`[ImageFeed] Color worker request failed for image ID ${id}:`, error);\n            })\n            .finally(() => {\n              requestedColorIds.current.delete(id);\n            });\n\n          colorPromises.push(promise);\n        }\n      }\n    });\n\n    // After processing all visible items in this pass, update the context\n    // Use Promise.allSettled to wait for all requests in this batch to finish\n    // before updating context, preventing rapid flickering.\n    if (colorPromises.length > 0) {\n      Promise.allSettled(colorPromises).then(() => {\n        // Re-calculate visible colors *after* potential map updates\n        const currentVisibleColors: string[] = [];\n        virtualItems.forEach(virtualItem => {\n          const row = calculatedRows[virtualItem.index];\n          row?.images.forEach(img => {\n            // Read from the potentially updated dominantColorMap state\n            const itemColor = dominantColorMap.get(img.id);\n            if (itemColor) {\n              currentVisibleColors.push(itemColor);\n            }\n          });\n        });\n        // Update context with the first 1 or 2 valid visible colors\n        if (currentVisibleColors.length > 0) {\n          // console.log('[ImageFeed] Updating context dominantColors after batch:', currentVisibleColors.slice(0, 2));\n          setDominantColors(currentVisibleColors.slice(0, 2));\n        } else {\n          // console.log('[ImageFeed] No dominant colors found after batch, resetting context.');\n          setDominantColors([]); // Reset if no colors found\n        }\n      });\n    } else {\n      // If no new colors were requested, still update context based on current visible colors\n      // This handles scrolling without new requests\n      const currentVisibleColors: string[] = [];\n      virtualItems.forEach(virtualItem => {\n        const row = calculatedRows[virtualItem.index];\n        row?.images.forEach(img => {\n          const itemColor = dominantColorMap.get(img.id);\n          if (itemColor) {\n            currentVisibleColors.push(itemColor);\n          }\n        });\n      });\n      if (currentVisibleColors.length > 0) {\n        // console.log('[ImageFeed] Updating context dominantColors (no new requests):', currentVisibleColors.slice(0, 2));\n        setDominantColors(currentVisibleColors.slice(0, 2));\n      } else {\n        // console.log('[ImageFeed] No dominant colors found (no new requests), resetting context.');\n        setDominantColors([]); // Reset if no colors found\n      }\n    }\n\n    // Cleanup: No specific listener removal needed here.\n    // Cancellation is handled by the main dependency change effect.\n  }, [\n    workerPool,\n    virtualItems, // Re-run when visible items change\n    calculatedRows, // Re-run if row layout changes\n    images, // Re-run if images change\n    getImageUrl,\n    dominantColorMap, // Re-run if the map updates (to potentially update context)\n    setDominantColors, // Context setter\n  ]);\n  // --- End Color Extraction Worker Integration ---\n\n  // --- Effect to set the publisher on the ImageProcessor --- >\n  useEffect(() => {\n    const processor = workerPool.getImageProcessor();\n    // Check if the processor has the setPublisher method (for safety)\n    if (processor && typeof (processor as any).setPublisher === 'function') {\n      (processor as any).setPublisher(publishImageUpdate);\n    } else {\n      console.warn('[ImageFeed] ImageProcessor instance not found or setPublisher method missing.');\n    }\n    // No cleanup needed for this specifically, publisher is set once\n    // Dependencies ensure it runs if publisher or processor instance changes\n  }, [workerPool, publishImageUpdate]);\n\n  // --- Render Logic --- >\n  const renderContent = () => {\n    const { gapSize } = layoutMetrics;\n    if (!containerWidth) return null;\n\n    const showLoadingState =\n      isLoadingImages || isGrouping || (viewMode === ViewMode.GRID && isLayoutCalculating);\n\n    // --- Render Dynamic Skeletons during Loading --- >\n    if (showLoadingState && viewMode === ViewMode.GRID) {\n      return (\n        <div\n          className={styles.gridContainer} // Use a container for skeleton layout\n          style={{\n            gap: `${gapSize}px`,\n            // Basic grid layout for skeletons based on current column count\n            // Note: This won't perfectly match the final layout worker result,\n            // but provides a reasonable placeholder structure.\n            display: 'grid',\n            gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,\n            padding: gapSize / 2, // Optional padding similar to final layout\n          }}\n        >\n          {(images ?? []).map(image => {\n            if (!image || image.width <= 0 || image.height <= 0) return null; // Skip invalid images\n            const color = dominantColorMap.get(image.id);\n            return (\n              <ImageSkeleton\n                key={`skeleton-${image.id}`}\n                containerWidth={image.width} // Use actual image dimensions\n                containerHeight={image.height}\n                placeholderColor={color} // Pass fetched color\n              />\n            );\n          })}\n        </div>\n      );\n    }\n\n    // Handle non-GRID view modes (pass raw images)\n    if (viewMode !== ViewMode.GRID) {\n      let ViewComponent;\n      switch (viewMode) {\n        case ViewMode.MASONRY:\n          ViewComponent = MasonryView;\n          break;\n        case ViewMode.BANNER:\n          ViewComponent = BannerView;\n          break;\n        case ViewMode.CAROUSEL:\n          ViewComponent = CarouselView;\n          break;\n        default:\n          return null;\n      }\n      // Ensure non-grid views also receive potentially filtered images\n      return <ViewComponent images={images} zoom={zoom} />;\n    }\n\n    // --- Render Final Virtualized GRID View --- >\n    // Only render if *not* in loading state and rows are calculated\n    if (!showLoadingState && calculatedRows.length > 0) {\n      return (\n        <div // Outer container: Sets the total scrollable height\n          style={{\n            height: `${rowVirtualizer.getTotalSize()}px`,\n            width: '100%',\n            position: 'relative',\n          }}\n        >\n          <div // Inner container: Absolutely positioned items are placed here\n            style={{\n              width: '100%',\n              position: 'relative',\n            }}\n          >\n            {virtualItems.map(virtualItem => {\n              const row = calculatedRows[virtualItem.index];\n              if (!row) return null;\n              return (\n                <motion.div // Wrapper with animation\n                  key={virtualItem.key}\n                  layout\n                  transition={{ type: 'spring', stiffness: 260, damping: 30 }}\n                  data-index={virtualItem.index}\n                  ref={rowVirtualizer.measureElement}\n                  style={{\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: virtualItem.size,\n                    y: virtualItem.start,\n                  }}\n                >\n                  <ImageRow\n                    // Pass necessary props down\n                    images={row.images}\n                    imageWidths={row.imageWidths ?? []}\n                    onImageClick={handleImageClick}\n                    columns={columns}\n                    zoom={zoom}\n                    isLastRow={virtualItem.index === calculatedRows.length - 1}\n                    rowHeight={row.height}\n                    // Pass processedGroupedImages down for context (e.g., carousel indicator)\n                    groupedImages={processedGroupedImages}\n                    workerPool={workerPool}\n                    gap={gapSize}\n                    containerWidth={containerWidth}\n                    onImageHover={handleImageHover}\n                    onImageLoadError={handleImageLoadError}\n                    // Pass the color map down to ImageRow/ImageItem if needed\n                    dominantColorMap={dominantColorMap}\n                  />\n                </motion.div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    // Fallback if still loading but not caught above, or rows aren't ready\n    // Can render a simpler spinner or nothing\n    return null; // Or a loading indicator\n  };\n\n  // Lightbox configuration\n  const lightboxPlugins = useMemo(() => [Captions, Counter, Thumbnails, Zoom], []);\n\n  // Prepare the lightbox slide objects\n  const slides = useMemo(() => {\n    if (!lightboxImages.length) return [];\n    return lightboxImages.map(image => ({\n      src: getImageUrl(image.src),\n      alt: image.alt,\n      title: image.title,\n      width: image.width,\n      height: image.height,\n    }));\n  }, [lightboxImages, getImageUrl]);\n\n  // --- Render Logic --- > Restored Error/Empty/Main return\n  if (isError) {\n    return (\n      <div ref={feedRef} className={`${styles.container} ${styles.error}`}>\n        Error loading images: {error?.message || 'Unknown error'}\n      </div>\n    );\n  }\n\n  const hasNoImages = !isLoadingImages && (!images || images.length === 0);\n  if (hasNoImages && !isGrouping && !isLayoutCalculating) {\n    return (\n      <div ref={feedRef} className={styles.container}>\n        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className={styles.noImages}>\n          No images found for this folder.\n        </motion.div>\n      </div>\n    );\n  }\n\n  // Main component return\n  return (\n    <div\n      ref={feedRef}\n      className={styles.container}\n      style={{\n        position: 'relative',\n      }}\n    >\n      <AuraBackground />\n      <div className={styles.feed}>{renderContent()}</div>\n\n      <Lightbox\n        open={lightboxIndex !== -1}\n        close={() => setLightboxIndex(-1)}\n        index={lightboxIndex}\n        slides={slides}\n        plugins={lightboxPlugins}\n      />\n    </div>\n  );\n}; // Correct closing brace for the component function\n\nexport default React.memo(ImageFeed);\n","import { useCallback, useEffect, useState } from 'react';\n\n// Define the structure for the window size object\ninterface WindowSize {\n  width: number | undefined;\n  height: number | undefined;\n}\n\n// Debounce timeout in milliseconds\nconst DEBOUNCE_TIMEOUT = 150;\n\n// Custom hook to track and return the current window size\nfunction useWindowSize() {\n  // State to store the current window size\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Memoized resize handler\n  const handleResize = useCallback(() => {\n    const newWidth = window.innerWidth;\n    const newHeight = window.innerHeight;\n\n    // Only update if dimensions actually changed\n    if (newWidth !== windowSize.width || newHeight !== windowSize.height) {\n      // Use RAF for smooth updates\n      requestAnimationFrame(() => {\n        setWindowSize({\n          width: newWidth,\n          height: newHeight,\n        });\n      });\n    }\n  }, [windowSize.width, windowSize.height]);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // Debounced resize handler\n    function debouncedResize() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(handleResize, DEBOUNCE_TIMEOUT);\n    }\n\n    // Initial size calculation\n    handleResize();\n\n    // Add event listener with debouncing\n    window.addEventListener('resize', debouncedResize);\n\n    // Cleanup\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      window.removeEventListener('resize', debouncedResize);\n    };\n  }, [handleResize]);\n\n  return windowSize;\n}\n\nexport default useWindowSize;\n","import throttle from 'lodash/throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ImageInfo } from '../types';\nimport WorkerPool from '../workers/workerPool';\n\ninterface PrefetchManagerOptions {\n  scrollContainerRef: React.RefObject<HTMLElement>;\n  imageList: ImageInfo[];\n  layoutData: Map<string, { top: number; left: number; width: number; height: number }>; // Assuming layout data is available\n  lookaheadDistance?: number; // Pixels or items? Let's start with pixels\n  priorityThreshold?: number; // Minimum priority score to consider prefetching\n  concurrency?: number; // How many items to prefetch concurrently\n  throttleDelay?: number; // ms delay for scroll/resize events\n}\n\ninterface PrefetchCandidate extends ImageInfo {\n  priority: number;\n  layout: { top: number; left: number; width: number; height: number };\n}\n\nconst DEFAULT_LOOKAHEAD = 600; // Look ahead 600px beyond viewport\nconst DEFAULT_CONCURRENCY = 3; // Prefetch up to 3 items at once\nconst DEFAULT_THROTTLE_DELAY = 50; // Throttle event handling to 50ms (was 100ms)\n\nexport function usePrefetchManager({\n  scrollContainerRef,\n  imageList,\n  layoutData,\n  lookaheadDistance = DEFAULT_LOOKAHEAD,\n  concurrency = DEFAULT_CONCURRENCY,\n  throttleDelay = DEFAULT_THROTTLE_DELAY,\n}: PrefetchManagerOptions) {\n  const workerPool = WorkerPool.getInstance();\n  const imageProcessor = workerPool.getImageProcessor();\n  const [viewport, setViewport] = useState({ top: 0, bottom: 0, height: 0 });\n  const processingRef = useRef<Set<string>>(new Set());\n\n  // Ref to store the latest version of the logic function for the throttled call\n  const runPrefetchLogicRef = useRef<() => Promise<void>>();\n\n  const updateViewport = useCallback(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    const { scrollTop, clientHeight } = container;\n    const currentTop = scrollTop;\n    const currentBottom = scrollTop + clientHeight;\n    // Use functional update to potentially avoid depending on viewport in useCallback\n    setViewport(prev => ({ top: currentTop, bottom: currentBottom, height: clientHeight }));\n  }, [scrollContainerRef]);\n\n  const calculatePriority = useCallback(\n    (\n      image: ImageInfo,\n      imageLayout: { top: number; left: number; width: number; height: number }\n    ): number => {\n      const imageCenterY = imageLayout.top + imageLayout.height / 2;\n      // Read viewport directly from state here\n      const viewportCenterY = viewport.top + viewport.height / 2;\n      const distance = Math.abs(imageCenterY - viewportCenterY);\n      return distance;\n    },\n    [viewport] // Dependency on viewport state is correct here\n  );\n\n  // Define the core logic function - this will be updated in the ref\n  const runPrefetchLogicAsyncInternal = useCallback(async () => {\n    // Read viewport state *inside* the function instead of relying on useCallback capture\n    const currentViewport = viewport;\n    if (!scrollContainerRef.current || imageList.length === 0 || layoutData.size === 0) {\n      return;\n    }\n\n    const candidates: PrefetchCandidate[] = [];\n    const prefetchTop = Math.max(0, currentViewport.top - lookaheadDistance);\n    const prefetchBottom = currentViewport.bottom + lookaheadDistance;\n\n    for (const image of imageList) {\n      const imageLayout = layoutData.get(image.id);\n      if (!imageLayout) continue;\n      const imageTop = imageLayout.top;\n      const imageBottom = imageLayout.top + imageLayout.height;\n      if (imageBottom >= prefetchTop && imageTop <= prefetchBottom) {\n        // Use the calculatePriority function (which depends on current viewport state)\n        const priority = calculatePriority(image, imageLayout);\n        candidates.push({ ...image, priority, layout: imageLayout });\n      }\n    }\n\n    candidates.sort((a, b) => a.priority - b.priority);\n\n    let processedCount = 0;\n    for (const candidate of candidates) {\n      if (processedCount >= concurrency) break;\n      if (processingRef.current.has(candidate.id)) continue;\n\n      console.log(\n        `[PrefetchManager] Requesting process for ${candidate.id}, Priority: ${candidate.priority.toFixed(0)}`\n      );\n      processingRef.current.add(candidate.id);\n      processedCount++;\n\n      imageProcessor\n        .processImage(candidate)\n        .catch(err => {\n          console.error(`[PrefetchManager] Error processing ${candidate.id}:`, err);\n        })\n        .finally(() => {\n          processingRef.current.delete(candidate.id);\n        });\n    }\n  }, [\n    // Dependencies that define the logic: Stable references or core data\n    imageList,\n    layoutData,\n    lookaheadDistance,\n    concurrency,\n    imageProcessor, // Assumed stable instance from WorkerPool\n    calculatePriority, // This function still changes when viewport changes, but runPrefetchLogicAsyncInternal doesn't directly depend on viewport state anymore\n    scrollContainerRef,\n    // REMOVED viewport dependency\n  ]);\n\n  // Update the ref whenever the internal logic function changes\n  useEffect(() => {\n    runPrefetchLogicRef.current = runPrefetchLogicAsyncInternal;\n  }, [runPrefetchLogicAsyncInternal]);\n\n  // Create the throttled function once, calling the function from the ref\n  const throttledRunPrefetch = useMemo(\n    () =>\n      throttle(() => {\n        // Added check: only run if the ref is current and component is mounted\n        if (runPrefetchLogicRef.current) {\n          runPrefetchLogicRef.current();\n        }\n      }, throttleDelay),\n    [throttleDelay]\n  );\n\n  // --- Effects ---\n\n  // Effect 1: Setup listeners and initial viewport\n  useEffect(() => {\n    // Initial viewport update on mount\n    updateViewport();\n\n    const container = scrollContainerRef.current;\n    if (container) {\n      // Attach the stable throttled listener\n      container.addEventListener('scroll', throttledRunPrefetch, { passive: true });\n      // Optional: Add resize listener if needed\n      // const handleResize = () => { updateViewport(); throttledRunPrefetch(); };\n      // window.addEventListener('resize', handleResize);\n    }\n\n    return () => {\n      throttledRunPrefetch.cancel();\n      if (container) {\n        container.removeEventListener('scroll', throttledRunPrefetch);\n        // window.removeEventListener('resize', handleResize);\n      }\n    };\n    // Dependencies: only need things required for setup/cleanup\n  }, [scrollContainerRef, updateViewport, throttledRunPrefetch]);\n\n  // Effect 2: Run prefetch logic when core data changes (images, layout)\n  useEffect(() => {\n    // Only run if we have images and layout data\n    // This prevents running unnecessarily when transitioning to empty state\n    if (imageList.length > 0 && layoutData.size > 0) {\n      console.log('[PrefetchManager] Running logic due to imageList/layoutData change.');\n      // Directly call the latest logic function from the ref\n      runPrefetchLogicRef.current?.();\n    }\n    // This effect should ONLY run when the core data list/layout changes.\n    // It intentionally does *not* depend on viewport or functions derived from it.\n  }, [imageList, layoutData]); // Removed runPrefetchLogicAsyncInternal dependency\n\n  // No return value needed, the hook manages prefetching internally\n}\n","import React, { RefObject } from 'react';\nimport styles from '../styles/ImageViewer.module.scss';\nimport { ViewMode } from '../types/index.js';\nimport ImageFeed from './ImageFeed.js';\n\n// Define the props interface for the ImageViewer component\ninterface ImageViewerProps {\n  selectedFolder: string;\n  isGrouped: boolean;\n  zoom: number;\n  viewMode: ViewMode;\n  scrollContainerRef: RefObject<HTMLElement>;\n}\n\n// Define the ImageViewer component\nconst ImageViewer: React.FC<ImageViewerProps> = ({\n  selectedFolder,\n  isGrouped,\n  zoom,\n  viewMode,\n  scrollContainerRef,\n}) => {\n  return (\n    // Main container with flex layout\n    <div className={`${styles.imageViewer} flex flex-col h-full bg-transparent`}>\n      {/* Content container with scrolling */}\n      <div className={`${styles.contentContainer} flex-1`}>\n        {/* Render ImageFeed directly, passing the folderPath and ref */}\n        {/* ImageFeed now handles its own loading, error, and empty states */}\n        <ImageFeed\n          folderPath={selectedFolder}\n          isGrouped={isGrouped}\n          zoom={zoom}\n          viewMode={viewMode}\n          scrollContainerRef={scrollContainerRef}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Export the ImageViewer component\nexport default ImageViewer;\n","import React from 'react';\r\nimport { ViewMode } from '../types/index.js';\r\nimport ImageViewer from './ImageViewer.js';\r\n\r\n// Define the props interface for the MainContent component\r\ninterface MainContentProps {\r\n  // images: ImageInfo[]; // Removed\r\n  selectedFolder: string;\r\n  searchQuery: string; // Kept for now, but its usage needs re-evaluation\r\n  // isLoading: boolean; // Removed\r\n  // error: string | null; // Removed\r\n  zoom: number;\r\n  isGrouped: boolean;\r\n  viewMode: ViewMode;\r\n  scrollContainerRef: React.RefObject<HTMLElement>;\r\n}\r\n\r\n// MainContent component that renders the primary content area of the application\r\nconst MainContent: React.FC<MainContentProps> = ({\r\n  // images, // Removed\r\n  selectedFolder,\r\n  searchQuery, // Kept for now\r\n  // isLoading, // Removed\r\n  // error, // Removed\r\n  zoom,\r\n  isGrouped,\r\n  viewMode,\r\n  scrollContainerRef,\r\n}) => {\r\n  // Removed the filtering logic for now. Search needs to be handled differently.\r\n  // const filteredImages = useMemo(() => {\r\n  //   if (!searchQuery) return images;\r\n  //   return images.filter(image => image.alt.toLowerCase().includes(searchQuery.toLowerCase()));\r\n  // }, [images, searchQuery]);\r\n\r\n  // Render the main content\r\n  return (\r\n    <>\r\n      {/* Render the ImageViewer component */}\r\n      <ImageViewer\r\n        // images={filteredImages} // Removed\r\n        // isLoading={isLoading} // Removed\r\n        // error={error} // Removed\r\n        selectedFolder={selectedFolder}\r\n        zoom={zoom}\r\n        isGrouped={isGrouped}\r\n        viewMode={viewMode}\r\n        scrollContainerRef={scrollContainerRef}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\n// Export the MainContent component\r\nexport default MainContent;\r\n","import { gsap } from 'gsap';\r\nimport { MotionPresetName, gsapConfigs } from './motionPresets';\r\n\r\n// Define the structure for a step in the pipeline\r\ninterface AnimationStepOptions {\r\n  delay?: number | string; // GSAP delay or position parameter like \"+=0.5\"\r\n  duration?: number;\r\n  ease?: string;\r\n  // Add other potential GSAP overrides if needed\r\n}\r\n\r\ninterface AnimationStep {\r\n  id?: string; // Optional ID for the step\r\n  target: gsap.DOMTarget; // Element(s) to animate\r\n  preset: MotionPresetName; // Name of the preset to use\r\n  options?: AnimationStepOptions; // Overrides for this specific step\r\n  // Later: Add 'type' for spring vs preset, 'engine' for Framer vs GSAP\r\n}\r\n\r\n// Type guard to check if a config has initialVars\r\nfunction hasInitialVars(config: any): config is { initialVars: gsap.TweenVars } {\r\n  return config && typeof config === 'object' && 'initialVars' in config;\r\n}\r\n\r\nexport class AnimationPipeline {\r\n  private timeline: gsap.core.Timeline | null;\r\n  private steps: AnimationStep[] = []; // Keep track of added steps\r\n\r\n  constructor(options?: gsap.TimelineVars) {\r\n    this.timeline = gsap.timeline({\r\n      paused: true, // Default to paused, require explicit play()\r\n      smoothChildTiming: true,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds an animation step to the pipeline based on a preset.\r\n   */\r\n  addStep(step: AnimationStep): this {\r\n    if (!this.timeline) return this; // Don't add if killed\r\n\r\n    const { target, preset, options = {} } = step;\r\n    const presetConfig = gsapConfigs[preset];\r\n\r\n    if (!presetConfig) {\r\n      console.warn(`[AnimationPipeline] Preset \"${preset}\" not found in gsapConfigs.`);\r\n      return this;\r\n    }\r\n\r\n    // Combine defaults, step options, and preset variables\r\n    const tweenVars: gsap.TweenVars = {\r\n      ...presetConfig.defaults,\r\n      ...options,\r\n      ...presetConfig.vars,\r\n    };\r\n\r\n    // Handle initial state using the type guard\r\n    if (hasInitialVars(presetConfig)) {\r\n      gsap.set(target, presetConfig.initialVars);\r\n    }\r\n\r\n    // Add the tween to the timeline\r\n    this.timeline.to(target, tweenVars, options?.delay);\r\n    this.steps.push(step); // Store the step definition\r\n\r\n    return this; // Allow chaining\r\n  }\r\n\r\n  /**\r\n   * Plays the animation pipeline from the current position.\r\n   */\r\n  play(): Promise<void> {\r\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\r\n    // Return a promise that resolves when the timeline completes\r\n    return new Promise(resolve => {\r\n      // Ensure timeline exists before setting callback\r\n      if (!this.timeline) {\r\n        resolve();\r\n        return;\r\n      }\r\n      this.timeline.eventCallback('onComplete', () => {\r\n        resolve();\r\n        this.timeline?.eventCallback('onComplete', null); // Clean up listener safely\r\n      });\r\n      this.timeline.play();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Pauses the animation pipeline.\r\n   */\r\n  pause(): this {\r\n    this.timeline?.pause(); // Use optional chaining\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Reverses the animation pipeline from the current position.\r\n   */\r\n  reverse(): Promise<void> {\r\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\r\n    return new Promise(resolve => {\r\n      if (!this.timeline) {\r\n        resolve();\r\n        return;\r\n      }\r\n      this.timeline.eventCallback('onReverseComplete', () => {\r\n        resolve();\r\n        this.timeline?.eventCallback('onReverseComplete', null); // Clean up listener safely\r\n      });\r\n      this.timeline.reverse();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restarts the animation pipeline from the beginning.\r\n   */\r\n  restart(): Promise<void> {\r\n    if (!this.timeline) return Promise.resolve(); // Handle killed timeline\r\n    this.timeline.pause(); // Ensure it's paused before restarting\r\n    this.timeline.seek(0);\r\n    return this.play(); // play() already handles killed timeline\r\n  }\r\n\r\n  /**\r\n   * Kills the timeline and removes tweens, freeing resources.\r\n   * Should be called when the component using the pipeline unmounts.\r\n   */\r\n  kill(): void {\r\n    if (this.timeline) {\r\n      this.timeline.kill();\r\n      this.timeline = null; // Set to null after killing\r\n    }\r\n    this.steps = [];\r\n  }\r\n\r\n  // --- Future additions ---\r\n  // addFramerStep(...) - To control Framer Motion components\r\n  // addSpringStep(...) - To integrate react-spring\r\n  // clear() - To remove steps without killing the timeline instance\r\n  // seek() - To jump to a specific time/label\r\n  // progress() - To get/set progress\r\n}\r\n","import React, { useEffect, useRef, useState } from 'react';\nimport Layout from '../components/Layout.js';\nimport MainContent from '../components/MainContent.js';\nimport { useAnimationController } from '../contexts/AnimationControllerContext'; // Import controller hook\nimport { useAnimationPipeline } from '../hooks/useAnimationPipeline';\n// import { getFolders, getImages } from '../lib/api.js'; // getFolders no longer needed here\nimport { ViewMode } from '../types/index.js';\n// Import the settings utilities\nimport { getHomeDirectory } from '../utils/settings.js';\n\n/**\n * Home component - the main page of the application.\n * It manages the overall state and layout of the app.\n *\n * @component\n * @returns {JSX.Element} The main application page.\n */\nconst Home: React.FC = () => {\n  // State declarations for managing application data and UI\n  // const [folders, setFolders] = useState<FolderInfo[]>([]); // Removed: Managed by useFolders in Sidebar\n  const [selectedFolder, setSelectedFolder] = useState<string>(() => {\n    return getHomeDirectory() || '';\n  });\n  // const [images, setImages] = useState<ImageInfo[]>([]); // Removed\n  const [zoom, setZoom] = useState<number>(1);\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  // const [currentDirectory, setCurrentDirectory] = useState<string>(''); // Removed: Managed by useCurrentDirectory\n  // const [isLoading, setIsLoading] = useState<boolean>(false); // Removed\n  // const [error, setError] = useState<string | null>(null); // Removed\n  const [isGrouped, setIsGrouped] = useState<boolean>(true);\n  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.GRID);\n\n  // Refs\n  const mainScrollRef = useRef<HTMLElement>(null);\n  const layoutWrapperRef = useRef<HTMLDivElement>(null); // Ref for the outer wrapper div\n  const sidebarRef = useRef<HTMLDivElement>(null); // Ref for Sidebar\n  const navbarRef = useRef<HTMLDivElement>(null); // Ref for Navbar\n  const contentAreaRef = useRef<HTMLDivElement>(null); // Ref for MainContent wrapper area\n\n  // --- Animation Setup ---\n  const homeEnterPipeline = useAnimationPipeline();\n  const { registerPipeline } = useAnimationController(); // Get registration function\n\n  // Add steps and register the pipeline on mount\n  useEffect(() => {\n    let unregister: (() => void) | null = null;\n\n    // Ensure all refs are available before defining steps\n    if (\n      layoutWrapperRef.current &&\n      sidebarRef.current &&\n      navbarRef.current &&\n      contentAreaRef.current\n    ) {\n      // Define the staggered pipeline steps\n      homeEnterPipeline\n        .addStep({\n          // 1. Fade in the main wrapper (slight delay)\n          target: layoutWrapperRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.1, duration: 0.4 },\n        })\n        .addStep({\n          // 2. Fade in Sidebar (starts shortly after wrapper begins fade-in)\n          target: sidebarRef.current,\n          preset: 'fadeIn', // Could use slideInLeft later\n          options: { delay: 0.2, duration: 0.4 }, // Staggered start time\n        })\n        .addStep({\n          // 3. Fade in Navbar (starts with Sidebar)\n          target: navbarRef.current,\n          preset: 'fadeIn', // Could use slideInTop later\n          options: { delay: 0.2, duration: 0.4 }, // Staggered start time\n        })\n        .addStep({\n          // 4. Fade in Main Content area (starts slightly after nav/sidebar)\n          target: contentAreaRef.current,\n          preset: 'fadeIn',\n          options: { delay: 0.3, duration: 0.5 },\n        });\n\n      // Register the pipeline to be triggered by the 'homeEnter' event\n      unregister = registerPipeline('homeEnterAnimation', homeEnterPipeline, ['homeEnter']);\n    }\n\n    // Cleanup: Unregister the pipeline\n    return () => {\n      unregister?.();\n    };\n  }, [homeEnterPipeline, registerPipeline]);\n\n  /**\n   * Effect hook to fetch the list of folders when the component mounts.\n   * Sets the first folder as selected if available.\n   * Removed: This is now handled by Sidebar component via useFolders hook.\n   */\n  // useEffect(() => {\n  //   const fetchFolders = async () => {\n  //     try {\n  //       const folderList = await getFolders();\n  //       setFolders(folderList);\n  //       if (folderList.length > 0 && !selectedFolder) { // Only set initial folder if none selected\n  //         setSelectedFolder(folderList[0].name);\n  //       }\n  //     } catch (error) {\n  //       console.error('Error fetching folders:', error);\n  //       // setError('Failed to fetch folders'); // setError removed\n  //     }\n  //   };\n\n  //   fetchFolders();\n  // }, [selectedFolder]);\n\n  /**\n   * Effect hook to fetch images when the selected folder changes.\n   * Updates loading state and handles errors.\n   * Removed: This is now handled by ImageFeed component via useFolderImages hook.\n   */\n  // ... (Removed image fetching useEffect)\n\n  /**\n   * Handler for folder selection change.\n   * Updates the selected folder state.\n   * @param {string} folder - The newly selected folder.\n   */\n  const handleFolderChange = (folder: string) => {\n    setSelectedFolder(folder);\n    // No need to fetch images here manually anymore\n  };\n\n  /**\n   * Handler for zoom level change.\n   * Updates the zoom state.\n   * @param {number} newZoom - The new zoom level.\n   */\n  const handleZoomChange = (newZoom: number) => {\n    setZoom(newZoom);\n  };\n\n  /**\n   * Handler for search query change.\n   * Updates the search query state.\n   * @param {string} query - The new search query.\n   */\n  const handleSearch = (query: string) => {\n    setSearchQuery(query);\n    // Search result display needs to be handled\n  };\n\n  /**\n   * Handler for file upload completion.\n   * Refreshes the images in the current folder.\n   * TODO: Replace with query invalidation using queryClient\n   */\n  const handleUploadComplete = () => {\n    // Example: queryClient.invalidateQueries(['images', selectedFolder]);\n    console.log('TODO: Invalidate query for folder:', selectedFolder);\n  };\n\n  /**\n   * Handler for grouping toggle.\n   * Toggles the grouping state.\n   */\n  const handleGroupToggle = () => {\n    setIsGrouped(prevState => !prevState);\n  };\n\n  const handleViewModeChange = (newMode: ViewMode) => {\n    setViewMode(newMode);\n  };\n\n  // Render the main layout with all necessary props\n  // Note: 'folders' & 'currentDirectory' props are removed from Layout\n  return (\n    // Apply ref and initial style to the wrapper\n    <div ref={layoutWrapperRef} style={{ opacity: 0 }}>\n      <Layout\n        ref={layoutWrapperRef} // Pass the *outer* wrapper ref to Layout if Layout needs it\n        selectedFolder={selectedFolder}\n        onFolderChange={handleFolderChange}\n        // currentDirectory={selectedFolder} // Removed\n        onSearch={handleSearch}\n        zoom={zoom}\n        onZoomChange={handleZoomChange}\n        isGrouped={isGrouped}\n        onGroupToggle={handleGroupToggle}\n        viewMode={viewMode}\n        onViewModeChange={handleViewModeChange}\n        mainRef={mainScrollRef} // For scrolling\n        // Pass down refs for internal elements\n        sidebarRef={sidebarRef}\n        navbarRef={navbarRef}\n        contentAreaRef={contentAreaRef}\n      >\n        {/* MainContent is rendered inside Layout as children */}\n        <MainContent\n          // images={images} // Removed\n          zoom={zoom}\n          searchQuery={searchQuery}\n          // isLoading={isLoading} // Removed\n          // error={error} // Removed\n          selectedFolder={selectedFolder}\n          isGrouped={isGrouped}\n          viewMode={viewMode}\n          scrollContainerRef={mainScrollRef}\n        />\n      </Layout>\n    </div>\n  );\n};\n\nexport default Home;\n","import { useEffect, useMemo, useRef } from 'react';\r\nimport { AnimationPipeline } from '../animations/AnimationPipeline';\r\n\r\n/**\r\n * Custom hook to create and manage an AnimationPipeline instance.\r\n *\r\n * @param options Optional GSAP TimelineVars for the pipeline.\r\n * @returns An instance of AnimationPipeline.\r\n */\r\nexport function useAnimationPipeline(options?: gsap.TimelineVars): AnimationPipeline {\r\n  // Use useRef to hold the pipeline instance so it persists across renders\r\n  // without causing re-renders itself when its internal state changes.\r\n  const pipelineRef = useRef<AnimationPipeline | null>(null);\r\n\r\n  // Memoize the options object to prevent unnecessary pipeline recreation\r\n  // Note: A deep comparison might be needed if options are complex and change often.\r\n  // For typical timeline options (like paused, onComplete), this shallow comparison is usually sufficient.\r\n  const memoizedOptions = useMemo(() => options, [JSON.stringify(options)]); // Simple serialization for comparison\r\n\r\n  // Initialize the pipeline only once or if options change\r\n  if (pipelineRef.current === null) {\r\n    pipelineRef.current = new AnimationPipeline(memoizedOptions);\r\n  }\r\n\r\n  // Cleanup function to kill the timeline when the component unmounts\r\n  useEffect(() => {\r\n    const pipeline = pipelineRef.current;\r\n    // Return the cleanup function\r\n    return () => {\r\n      if (pipeline) {\r\n        // console.log('[useAnimationPipeline] Cleaning up pipeline');\r\n        pipeline.kill();\r\n        pipelineRef.current = null; // Clear the ref\r\n      }\r\n    };\r\n  }, [memoizedOptions]); // Re-run effect only if memoized options change (unlikely for constructor options)\r\n\r\n  // Ensure we always return a valid instance (or handle error)\r\n  if (!pipelineRef.current) {\r\n    // This case should ideally not happen if initialization logic is correct\r\n    // but provides a fallback.\r\n    pipelineRef.current = new AnimationPipeline(memoizedOptions);\r\n    console.error('[useAnimationPipeline] Pipeline was null after initialization. Recreated.');\r\n  }\r\n\r\n  return pipelineRef.current;\r\n}\r\n","import { useEffect } from 'react';\nimport {\n  AnimationControllerProvider,\n  useAnimationController,\n} from './contexts/AnimationControllerContext';\nimport { ColorProvider } from './contexts/ColorContext';\nimport { ImageProcessingProvider } from './contexts/ImageProcessingContext';\nimport Home from './pages/Home.js';\nimport './styles/views.css';\n\nfunction AppContent() {\n  const { trigger } = useAnimationController();\n\n  useEffect(() => {\n    trigger('homeEnter');\n  }, [trigger]);\n\n  return (\n    <div className=\"App\">\n      <Home />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <AnimationControllerProvider>\n      <ColorProvider>\n        <ImageProcessingProvider>\n          <AppContent />\n        </ImageProcessingProvider>\n      </ColorProvider>\n    </AnimationControllerProvider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App.js';\n\nexport function render() {\n  const html = ReactDOMServer.renderToString(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n  return { html };\n}\n"],"names":["AnimationControllerContext","createContext","AnimationControllerProvider","children","pipelinesRef","useRef","Map","trigger","useCallback","eventName","console","log","current","forEach","registered","triggerEvents","includes","id","playOnTrigger","pipeline","play","catch","err","error","restart","registerPipeline","has","warn","set","delete","contextValue","useMemo","Provider","value","useAnimationController","context","useContext","Error","initialDefaultColor","initialHoverState","isHovering","position","color","ColorContext","dominantColors","setDominantColors","hoverState","setHoverState","ColorProvider","setDominantColorsState","useState","setHoverStateInternal","newState","prevState","ImageProcessingContext","subscriptions","ImageProcessingProvider","subscribeToImageUpdates","imageId","callback","Set","get","add","size","publishImageUpdate","data","useImageProcessing","ViewMode","api","axios","create","baseURL","async","getFolders","map","folder","name","path","getCurrentDirectory","currentDirectory","CurrentDirectoryButton","isLoading","isError","useQuery","queryKey","queryFn","staleTime","refetchOnWindowFocus","buttonContent","buttonClass","iconColor","jsxs","motion","button","className","whileHover","scale","whileTap","disabled","jsx","IconFolder","div","initial","opacity","animate","transition","duration","SearchBar","onSearch","query","setQuery","useAnimation","form","onSubmit","e","preventDefault","styles","width","type","stiffness","damping","background","input","onChange","target","placeholder","whileFocus","ZoomSlider","zoom","onZoomChange","isDragging","setIsDragging","controls","sliderWidth","glowOpacity","glowScale","useEffect","start","style","boxShadow","onClick","Math","max","svg","height","viewBox","fill","xmlns","rotate","d","stroke","strokeWidth","strokeLinecap","strokeLinejoin","top","left","transform","pointerEvents","precision","min","step","parseFloat","onMouseDown","onMouseUp","onTouchStart","onTouchEnd","Navbar","forwardRef","isGrouped","onGroupToggle","viewMode","onViewModeChange","ref","svgRef","querySelector","length","getTotalLength","strokeDasharray","strokeDashoffset","getBoundingClientRect","y","values","mode","charAt","toUpperCase","slice","displayName","HOME_DIRECTORY_KEY","getHomeDirectory","localStorage","getItem","Sidebar","selectedFolder","onFolderChange","folders","currentHomeDir","setCurrentHomeDir","handleSetHome","folderPath","event","stopPropagation","setItem","setHomeDirectory","x","sidebar","loading","message","sidebarInner","logo","folderList","folderItem","folderButton","folderName","setHomeButton","isHome","title","FaHome","uploadButton","CUSTOM_PROPERTIES","DEFAULT_CUSTOM_PROPERTY_VALUES","CUSTOM_PROPERTIES_SCROLL_Y","CUSTOM_PROPERTIES_MOUSE_X","CUSTOM_PROPERTIES_MOUSE_Y","hexToVec3","hex","r","g","b","parseInt","lerpArray","end","t","val","i","lerp","AuraBackground$1","React","memo","canvasRef","glRef","programRef","bufferRef","attribLocationsRef","uniformLocationsRef","animationFrameRef","animatedColor1","animatedColor2","animatedMixFactor","animatedHoverPos","animatedIsHovering","createShader","gl","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","VERTEX_SHADER","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","renderLoop","time","requestAnimationFrame","timeSeconds","lerpSpeed","targetColor1","targetColor2","targetMix","targetIsHovering","targetPos","viewport","canvas","useProgram","bindBuffer","ARRAY_BUFFER","posLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","uniform2f","resolution","uniform1f","uniform3fv","colorTarget1","colorTarget2","colorMixFactor","uniform2fv","hoverPos","drawArrays","TRIANGLES","canvasElement","getContext","alpha","antialias","FRAGMENT_SHADER","detachShader","positions","Float32Array","createBuffer","bufferData","STATIC_DRAW","getAttribLocation","getUniformLocation","hoverColor","resizeObserver","ResizeObserver","entries","contentRect","observe","cancelAnimationFrame","disconnect","currentGl","deleteBuffer","overflow","zIndex","gsap","registerPlugin","ScrollToPlugin","Layout","mainRef","navbarRef","sidebarRef","contentAreaRef","updateCustomProperties","mouseX","clientX","mouseY","clientY","document","documentElement","setProperty","updateScrollProperty","scrollY","window","Object","property","addEventListener","removeEventListener","AuraBackground","useFolderImages","response","encodeURIComponent","Array","isArray","_a","statusText","request","getImages","enabled","placeholderData","previousData","STORE_NAME","dbPromise","getDb","dbPromise$1","openDB","upgrade","db","objectStoreNames","contains","createObjectStore","keyPath","ImageProcessor","constructor","options","__publicField","this","onError","concurrency","navigator","hardwareConcurrency","queue","PQueue","worker","Worker","URL","url","proxy","wrap","onerror","call","initializeCacheCheck","checkCacheForStaleBlobs","setPublisher","publisher","getCacheEntry","setCacheEntry","entry","put","deleteCacheEntry","allEntries","getAll","staleCount","shouldDelete","lowResUrl","startsWith","fetch","ok","highResUrl","processImage","image","src","cachedEntry","lowResMatches","lowResWidth","round","lowResHeight","highResMatches","_b","quality","imageUrl","_c","cacheError","activeRequests","controller","AbortController","createdBitmap","signal","aborted","DOMException","reason","blob","createImageBitmap","fetchError","_d","result","Comlink","transfer","imageBitmap","revokeObjectURL","finalEntry","timestamp","Date","now","_e","_f","_g","close","processBatch","images","batchId","random","toString","imagesToProcess","transferList","preCheckPromises","createdBitmaps","batchError","push","localBitmap","index","indexOf","splice","Promise","all","batchResults","cacheUpdatePromises","resultId","originalItem","find","item","originalWidth","originalHeight","existingEntry","bitmap","cancel","abort","clear","cancelAll","terminate","releaseProxy","then","_WorkerPool","layoutQueue","groupingQueue","colorQueue","getInstance","instance","initializeWorker","workerType","WorkerConstructor","setupListenersFn","resolve","reject","getImageProcessor","imageProcessor","isImageProcessorInitialized","cancelPendingImageTasks","getLayoutWorker","layoutWorkerPromise","LayoutWorker","layoutWorker","setupWorkerMessageHandler","pendingLayoutRequests","layoutWorkerListeners","getColorExtractorWorker","colorExtractorWorkerPromise","ColorExtractorWorker","colorExtractorWorker","pendingColorRequests","colorExtractorListeners","getGroupingWorker","groupingWorkerPromise","GroupingWorker","groupingWorker","pendingGroupingRequests","groupingWorkerListeners","pendingRequests","generalListeners","onmessage","requestId","clearTimeout","timer","payload","listener","postRequest","messageType","getWorkerPromise","bind","resolveTask","rejectTask","uuidv4","initError","responsePromise","resolveResponse","rejectResponse","timeoutMs","setTimeout","workerMessage","postMessage","postError","priority","addLayoutWorkerListener","removeLayoutWorkerListener","addColorExtractorListener","removeColorExtractorListener","addGroupingWorkerListener","removeGroupingWorkerListener","cancelPendingLayoutTasks","cancelTasks","cancelPendingColorTasks","cancelPendingGroupingTasks","cleanup","cancelAllPendingTasks","terminateWorker","WorkerPool","SCROLL_STATE_STORE_NAME","openScrollStateDB","saveScrollState","scrollTop","tx","transaction","store","objectStore","stateToSave","done","ScrollTrigger","_ScrollTriggerManager","timeline","paused","smoothChildTiming","mainTrigger","body","onUpdate","self","progress","markers","addAnimation","element","animationProps","animation","to","targets","removeAnimation","remove","kill","ScrollTriggerManager","CustomEase","_AnimationSystem","initializeCustomEases","scrollTriggerManager","getAnimationProperties","itemId","ease","transformOrigin","rotation","createHoverAnimation","force3D","createMorphAnimation","borderRadius","createScrollAnimation","AnimationSystem","calculateGapSize","baseGap","roundedGap","calculateLayout","config","containerWidth","columns","effectiveWidth","baseColumns","floor","calculateColumns","gap","minImageWidth","maxImageWidth","motionVariants","fadeIn","exit","hoverPop","rest","hover","gsapConfigs","defaults","vars","initialVars","overwrite","restVars","motionComponents","span","img","li","ul","p","h1","h2","h3","MotionPreset","as","preset","onMouseEnter","onMouseLeave","whileDrag","whileInView","MotionComponent","FallbackComponent","variants","defaultTransition","placeholderVariants","filter","imageVariants","delay","ResponsiveImage","alt","isProcessed","onLoad","handleLoad","handleError","useSrcSet","srcSet","join","sizes","ImageItem$1","containerHeight","groupCount","onResize","isCarousel","groupImages","onImageHover","onImageLoadError","dominantColor","imageRef","isHighResLoaded","setIsHighResLoaded","processedUrls","setProcessedUrls","hasError","setHasError","placeholderColor","targetWidth","targetHeight","aspectRatio","handleMouseEnter","rect","currentTarget","centerX","centerY","normalizedX","innerWidth","normalizedY","innerHeight","handleMouseLeave","handleProcessedImageUpdate","prev","unsubscribe","currentLowUrl","low","currentHighUrl","high","handleImageLoad","handleImageError","truncatedTitle","formattedTitle","replace","split","word","match","toLowerCase","trim","substring","truncateImageTitle","imageItem","layout","cursor","AnimatePresence","imageElement","inset","errorIndicator","overlay","groupIndicator","smoothLayoutTransition","mass","itemVariants","hidden","visible","ImageRow$1","imageWidths","onImageClick","isLastRow","rowHeight","groupedImages","workerPool","dominantColorMap","rowRef","display","flexWrap","marginBottom","willChange","maxWidth","justifyContent","alignItems","group","some","custom","flexShrink","flexGrow","ImageItem","ImageSkeleton","imageSkeleton","maxHeight","backgroundColor","skeletonAnimation","BannerView","NextArrow","props","FaChevronRight","PrevArrow","FaChevronLeft","CarouselView","Slider","dots","infinite","speed","slidesToShow","slidesToScroll","nextArrow","prevArrow","adaptiveHeight","customPaging","MasonryView","Masonry","breakpointCols","default","columnClassName","objectFit","debounce","func","waitFor","timeoutId","debounced","args","ImageFeed$1","scrollContainerRef","originalImages","isLoadingImages","isPlaceholderData","windowSize","setWindowSize","handleResize","newWidth","newHeight","debouncedResize","useWindowSize","feedRef","setContainerWidth","setColumns","lightboxIndex","setLightboxIndex","lightboxImages","setLightboxImages","setDominantColorMap","requestedColorIds","hoverTimeoutRef","restoredState","setRestoredState","previousFolderPathRef","rowHeightsRef","isRestoringScrollRef","velocityEMARef","dynamicOverscan","setDynamicOverscan","failedImageIds","setFailedImageIds","getImageUrl","imagePath","handleImageLoadError","newSet","calculatedRows","setCalculatedRows","isLayoutCalculating","setIsLayoutCalculating","processedGroupedImages","setProcessedGroupedImages","isGrouping","setIsGrouping","activeRequestRef","layoutDataMap","currentTop","row","currentLeft","imageList","layoutData","lookaheadDistance","throttleDelay","setViewport","bottom","processingRef","runPrefetchLogicRef","updateViewport","container","clientHeight","currentBottom","calculatePriority","imageLayout","imageCenterY","viewportCenterY","abs","runPrefetchLogicAsyncInternal","currentViewport","candidates","prefetchTop","prefetchBottom","imageTop","sort","a","processedCount","candidate","toFixed","finally","throttledRunPrefetch","throttle","passive","usePrefetchManager","debouncedIsGrouped","setDebouncedIsGrouped","updateDebouncedGrouped","newValue","debouncedSaveScroll","scroll","isMounted","loadedState","state","loadScrollState","loadAndSetState","currentPathForCleanup","scrollElement","folderToSave","imagesKey","avgAspectRatio","validImages","reduce","sum","layoutMetrics","gapSize","estimatedRowHeightFallback","totalGapWidth","availableWidthForImages","estimatedAvgImageWidth","layoutInputs","targetRowHeight","updateContainerWidthInternal","prevWidth","debouncedUpdateContainerWidth","useLayoutEffect","initialImageCount","imageInfo","GRID","groupingResult","firstImages","layoutResult","runPipeline","handleImageClick","clickedImage","groupIndex","findIndex","imageIndexInGroup","lastScrollTopRef","lastScrollTimeRef","performance","handleScroll","timeDelta","scrollDelta","velocity","calculatedOverscan","OVERSCAN_MAX","throttledScrollHandler","limit","inThrottle","apply","rowVirtualizer","useVirtualizer","count","getScrollElement","estimateSize","overscan","measure","virtualItems","getVirtualItems","handleImageHover","visibleImageIds","virtualItem","colorPromises","promise","colorValue","prevMap","newMap","allSettled","currentVisibleColors","itemColor","processor","lightboxPlugins","Captions","Counter","Thumbnails","Zoom","slides","feed","showLoadingState","gridContainer","gridTemplateColumns","padding","ViewComponent","MASONRY","BANNER","CAROUSEL","getTotalSize","measureElement","ImageRow","key","Lightbox","open","plugins","noImages","ImageViewer","ImageFeed","MainContent","searchQuery","Fragment","AnimationPipeline","addStep","presetConfig","tweenVars","gsap$1","steps","eventCallback","pause","reverse","seek","Home","setSelectedFolder","setZoom","setSearchQuery","setIsGrouped","setViewMode","mainScrollRef","layoutWrapperRef","homeEnterPipeline","pipelineRef","memoizedOptions","JSON","stringify","useAnimationPipeline","unregister","newZoom","newMode","AppContent","App","render","html","ReactDOMServer","renderToString","StrictMode"],"mappings":"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"}